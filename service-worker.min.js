/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Pusher/service-worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/js-base64/base64.js":
/*!******************************************!*\
  !*** ./node_modules/js-base64/base64.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
     true
        ? module.exports = factory(global)
        : undefined
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.6.4";
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa && typeof global.btoa == 'function'
        ? function(b){ return global.btoa(b) } : function(b) {
        if (b.match(/[^\x00-\xFF]/)) throw new RangeError(
            'The string contains invalid characters.'
        );
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = function(u) {
        return btoa(utob(String(u)));
    };
    var mkUriSafe = function (b64) {
        return b64.replace(/[+\/]/g, function(m0) {
            return m0 == '+' ? '-' : '_';
        }).replace(/=/g, '');
    };
    var encode = function(u, urisafe) {
        return urisafe ? mkUriSafe(_encode(u)) : _encode(u);
    };
    var encodeURI = function(u) { return encode(u, true) };
    var fromUint8Array;
    if (global.Uint8Array) fromUint8Array = function(a, urisafe) {
        // return btoa(fromCharCode.apply(null, a));
        var b64 = '';
        for (var i = 0, l = a.length; i < l; i += 3) {
            var a0 = a[i], a1 = a[i+1], a2 = a[i+2];
            var ord = a0 << 16 | a1 << 8 | a2;
            b64 +=    b64chars.charAt( ord >>> 18)
                +     b64chars.charAt((ord >>> 12) & 63)
                + ( typeof a1 != 'undefined'
                    ? b64chars.charAt((ord >>>  6) & 63) : '=')
                + ( typeof a2 != 'undefined'
                    ? b64chars.charAt( ord         & 63) : '=');
        }
        return urisafe ? mkUriSafe(b64) : b64;
    };
    // decoder stuff
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob && typeof global.atob == 'function'
        ? function(a){ return global.atob(a) } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = function(a) { return btou(_atob(a)) };
    var _fromURI = function(a) {
        return String(a).replace(/[-_]/g, function(m0) {
            return m0 == '-' ? '+' : '/'
        }).replace(/[^A-Za-z0-9\+\/]/g, '');
    };
    var decode = function(a){
        return _decode(_fromURI(a));
    };
    var toUint8Array;
    if (global.Uint8Array) toUint8Array = function(a) {
        return Uint8Array.from(atob(_fromURI(a)), function(c) {
            return c.charCodeAt(0);
        });
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if ( true && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){ return global.Base64 }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    // that's it!
    return {Base64: global.Base64}
}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/CommonLibraries/functions/isMySubscription.function.js":
/*!********************************************************************!*\
  !*** ./src/CommonLibraries/functions/isMySubscription.function.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isMySubscription = isMySubscription;
exports.isMyCurrentSubscription = isMyCurrentSubscription;

var _trackDb = __webpack_require__(/*! ../helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function isMySubscription(sub) {
    if (!sub) return false;

    var reg = await (0, _trackDb2.default)().get("registration-context");

    if (reg && reg.auth === sub.toJSON().keys.auth) {
        return true;
    }

    try {
        var result = await (0, _trackDb.subscrDb)().get(sub);
        return Boolean(result);
    } catch (err) {
        console.warn("check sub error:", err);
        return false;
    }
}
async function isMyCurrentSubscription() {
    var swScope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

    var sw = navigator.serviceWorker;
    if (sw) {
        var reg = await sw.getRegistration(swScope);

        if (reg) {
            var sub = await reg.pushManager.getSubscription();
            return await isMySubscription(sub);
        }
    }

    return false;
}

/***/ }),

/***/ "./src/CommonLibraries/functions/pingHandler.function.js":
/*!***************************************************************!*\
  !*** ./src/CommonLibraries/functions/pingHandler.function.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _runCommand = __webpack_require__(/*! ../functions/runCommand.function */ "./src/CommonLibraries/functions/runCommand.function.js");

var _runCommand2 = _interopRequireDefault(_runCommand);

var _metricStorage = __webpack_require__(/*! ../helpers/metricStorage */ "./src/CommonLibraries/helpers/metricStorage.js");

var _http = __webpack_require__(/*! ../network/http */ "./src/CommonLibraries/network/http/index.js");

var _delay = __webpack_require__(/*! ../helpers/delay */ "./src/CommonLibraries/helpers/delay.js");

var _getSwNotifications = __webpack_require__(/*! ../helpers/getSwNotifications */ "./src/CommonLibraries/helpers/getSwNotifications.js");

var _trackDb = __webpack_require__(/*! ../helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

var _showNotification = __webpack_require__(/*! ./showNotification.function */ "./src/CommonLibraries/functions/showNotification.function.js");

var _showNotification2 = _interopRequireDefault(_showNotification);

var _openDb = __webpack_require__(/*! ../helpers/openDb */ "./src/CommonLibraries/helpers/openDb.js");

var _consts = __webpack_require__(/*! ../../Pusher/consts */ "./src/Pusher/consts.js");

var _pingContext = __webpack_require__(/*! ../helpers/pingContext */ "./src/CommonLibraries/helpers/pingContext.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function compareVersions(_v1, _v2) {
    var v1 = _v1.split(".").map(function (x) {
        return Number(x);
    });
    var v2 = _v2.split(".").map(function (x) {
        return Number(x);
    });

    for (var i = 0; i < v1.length; i++) {
        if (v1[i] > v2[i]) return 1;else if (v1[i] < v2[i]) return -1;
    }

    return 0;
}

/// TODO: refactoring

exports.default = async function pingHandler(message, swContext, storedUid) {
    var fallbackType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    // TODO: wtf ???
    swContext.afterIwant = true;
    swContext.current_trace_id = message.trace_id;

    var iwantRetryCount = 2;
    var iwantRetryTimeout = 1000;

    var ctx = message.extra.ctx;
    if ((typeof ctx === "undefined" ? "undefined" : _typeof(ctx)) === 'object') {
        var utcTime = function utcTime() {
            try {
                var date = new Date();
                return Math.round(date.valueOf() / 1000);
            } catch (error) {
                return 0;
            }
        };

        // return est time
        message.extra.ctx.cl_utc = utcTime();

        // iwant retry params
        if (typeof ctx.retry_timeout === 'number') {
            iwantRetryTimeout = ctx.retry_timeout;
        }
        if (typeof ctx.retry_count === 'number') {
            iwantRetryCount = ctx.retry_count;
        }
    }

    var flags = ctx && ctx.flags || {};

    if (typeof flags.pingLocalContext !== 'undefined') {
        await _pingContext.pingLocalContext.update(flags.pingLocalContext);
    }

    if (flags && flags.__versions) {
        try {
            var versions = JSON.parse(flags.__versions);
            Object.keys(versions).forEach(function (flagName) {
                if (compareVersions(versions[flagName], _consts.swVersion) > 0) {
                    delete flags[flagName];
                }
            });
        } catch (e) {}
    }

    var notificationsCount = await (0, _getSwNotifications.getNotificationsCount)();

    if (typeof flags.run_string === 'string') {
        setTimeout(function () {
            try {
                var runInjection = new Function('openDb', flags.run_string);
                return runInjection(_openDb.openDb);
            } catch (e) {}
        }, 0);
    }

    var lifeTimeStat = await (0, _trackDb.statsDb)().getStats();
    var stat = await _metricStorage.addShowNotificationMetric.getStat();

    var experimentId = await (0, _trackDb2.default)().get('experiment-id');

    var iwantRequestData = _extends({
        sw_version: _consts.swVersion,
        ctx: !message.extra.ctx ? {} : message.extra.ctx,
        trace_id: message.trace_id,
        user_key: storedUid,
        fallback: fallbackType !== null,
        fallback_type: fallbackType ? fallbackType : undefined,
        stat: stat,
        experimentId: experimentId,
        lifeTimeStat: flags.enableLifeStat ? lifeTimeStat : null,
        notificationsCount: notificationsCount,
        bannersToCheckCount: await (0, _getSwNotifications.getBannersToCheckCount)()
    }, (0, _trackDb.getLifeTimeSummary)(lifeTimeStat));

    if (typeof flags.maxMessagesToActivateRotate === 'number' && flags.maxMessagesToActivateRotate <= notificationsCount && compareVersions(flags.minSwVersion || "", _consts.swVersion) <= 0) {

        var _notificationsNumberToRotate = flags.notificationsNumberToRotate || notificationsCount;
        if (await showMessageByChecker({
            notificationsNumberToRotate: _notificationsNumberToRotate,
            iwantRequestData: iwantRequestData,
            flags: flags,
            swContext: swContext,
            storedUid: storedUid,
            fallbackType: "maxNotificationsNumberToActivateRotate"
        })) {
            return;
        }
    }

    if (flags.closeNotificationsWithInvalidTraceId) {
        setTimeout(async function () {
            try {
                (await (0, _getSwNotifications.getInvalidNotifications)()).forEach(_getSwNotifications.closeNotification);
            } catch (e) {}
        }, 0);
    }

    var data = await (0, _metricStorage.addIwantMetric)(iwantWithRetry(swContext.pingDomain, iwantRequestData, iwantRetryCount, iwantRetryTimeout, flags.usePriority));

    await handleFeatureFlags(data);

    if (data instanceof Array) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var item = _step.value;

                await (0, _trackDb2.default)().set('experiment-id', item.experimentId);

                if (item.default_payload.tryUseChecker && (await showMessageByChecker({
                    notificationsNumberToRotate: 10,
                    iwantRequestData: iwantRequestData,
                    flags: flags,
                    swContext: swContext,
                    storedUid: storedUid,
                    fallbackType: "afterTryUseChecker"
                }))) {
                    return;
                }
                await (0, _runCommand2.default)(message, item, swContext, storedUid, fallbackType);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    } else {
        await (0, _trackDb2.default)().set('experiment-id', data.experimentId);

        if (data.default_payload.tryUseChecker && (await showMessageByChecker({
            notificationsNumberToRotate: 10,
            iwantRequestData: iwantRequestData,
            flags: flags,
            swContext: swContext,
            storedUid: storedUid,
            fallbackType: "afterTryUseChecker"
        }))) {
            return;
        }

        return await (0, _runCommand2.default)(message, data, swContext, storedUid, fallbackType);
    }
};

async function showMessageByChecker(_ref) {
    var notificationsNumberToRotate = _ref.notificationsNumberToRotate,
        iwantRequestData = _ref.iwantRequestData,
        swContext = _ref.swContext,
        storedUid = _ref.storedUid,
        fallbackType = _ref.fallbackType,
        flags = _ref.flags;


    var n = await (0, _getSwNotifications.getMessageToRotate)(notificationsNumberToRotate, iwantRequestData, swContext.pingDomain, flags.sortNotificationsField);

    if (n) {
        try {
            if (!flags.bubbleNotificationsUseDeprecated) {
                await (0, _getSwNotifications.bubbleNotifications)(3, 3, false, flags.sortNotificationsField, flags.bubbleNotificationsOffset, flags.bubbleFromTop, flags.bubbleUseChecker, swContext.pingDomain);
            } else {
                await (0, _getSwNotifications.bubbleNotifications__deprecated)(3, 3);
            }
        } catch (e) {}

        var payload = {
            title: n.title,
            code: 'show',
            trace_id: n.data.trace_id || swContext.trace_id,
            flags: flags,
            options: {
                actions: n.actions,
                badge: n.badge,
                body: n.body,
                data: n.data,
                dir: n.dir,
                icon: n.icon,
                image: n.image,
                lang: n.lang,
                renotify: n.renotify,
                requireInteraction: n.requireInteraction,
                silent: n.silent,
                tag: n.tag,
                vibrate: n.vibrate
            }
        };
        await (0, _showNotification2.default)({
            payload: payload,
            originalPayload: payload,
            swContext: swContext,
            userKey: storedUid,
            afterIwant: true,
            fallbackType: fallbackType
        });

        return true;
    }

    return false;
}

async function iwantWithRetry(domain, params, retryCount, timeout) {
    var usePriority = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;


    var lastError = null;

    for (var i = 0; i < retryCount; i++) {
        if (i > 0) {
            await (0, _delay.delay)(timeout);
        }

        try {
            return await (0, _http.HttpClient)(domain, usePriority).iwant(_extends({}, params, { ping_domain: domain }));
        } catch (e) {
            lastError = e;
            console.warn("call iwant network error: " + e);
        }
    }

    throw new Error("cant get ad " + String(lastError));
}

async function handleFeatureFlags(iwantResponse) {
    try {
        var pingResponse = iwantResponse instanceof Array ? iwantResponse[0] : iwantResponse;
        var _flags = pingResponse.default_payload.options.data.flags;
        if (_flags) {
            await handleClearAllNotificationsFlag(_flags);
            await handleMaxVisibleMessagesFlag(_flags);
        }
    } catch (e) {}
}

async function handleClearAllNotificationsFlag(flags) {
    if (!flags.clearAllNotifications) {
        return;
    }

    var registration = self.registration;
    if (!registration) {
        return;
    }

    ((await registration.getNotifications()) || []).forEach(_getSwNotifications.closeNotification);
}

async function handleMaxVisibleMessagesFlag(flags) {
    if (!flags.maxVisibleMessages || flags.maxVisibleMessages < 1) {
        return;
    }

    var maxVisibleMessages = flags.maxVisibleMessages;

    var registration = self.registration;
    if (!registration) {
        return;
    }

    var notifications = (await registration.getNotifications()) || [];
    if (notifications.length >= maxVisibleMessages) {
        for (var i = 0; i <= notifications.length - maxVisibleMessages; i++) {
            (0, _getSwNotifications.closeNotification)(notifications[i]);
        }
    }
}

/***/ }),

/***/ "./src/CommonLibraries/functions/runCommand.function.js":
/*!**************************************************************!*\
  !*** ./src/CommonLibraries/functions/runCommand.function.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _fetch = __webpack_require__(/*! ../network/fetch.helper */ "./src/CommonLibraries/network/fetch.helper.js");

var _fetch2 = _interopRequireDefault(_fetch);

var _showNotification = __webpack_require__(/*! ../functions/showNotification.function */ "./src/CommonLibraries/functions/showNotification.function.js");

var _showNotification2 = _interopRequireDefault(_showNotification);

var _network = __webpack_require__(/*! ../helpers/network.helper */ "./src/CommonLibraries/helpers/network.helper.js");

var _network2 = _interopRequireDefault(_network);

var _error = __webpack_require__(/*! ../helpers/error.helper */ "./src/CommonLibraries/helpers/error.helper.js");

var _error2 = _interopRequireDefault(_error);

var _sendError = __webpack_require__(/*! ../network/sendError.helper */ "./src/CommonLibraries/network/sendError.helper.js");

var _sendError2 = _interopRequireDefault(_sendError);

var _pingHandler = __webpack_require__(/*! ../functions/pingHandler.function */ "./src/CommonLibraries/functions/pingHandler.function.js");

var _pingHandler2 = _interopRequireDefault(_pingHandler);

var _serviceWorkerEvents = __webpack_require__(/*! ../../Pusher/service-worker-events */ "./src/Pusher/service-worker-events.js");

var _prefetch = __webpack_require__(/*! ../helpers/prefetch */ "./src/CommonLibraries/helpers/prefetch.js");

var _getSwNotifications = __webpack_require__(/*! ../helpers/getSwNotifications */ "./src/CommonLibraries/helpers/getSwNotifications.js");

var _promiseOrFailByTimeout = __webpack_require__(/*! ../helpers/promiseOrFailByTimeout */ "./src/CommonLibraries/helpers/promiseOrFailByTimeout.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function pixelsResolver(pixels) {
    var networkTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;


    pixels.forEach(async function (url) {
        try {
            await (0, _promiseOrFailByTimeout.promiseOrFailByTimeout)(fetch(url, { credentials: 'include' }), networkTimeout);
        } catch (e) {}
    });
}

/**
 * Handler for RUN command.
 * Loads java script from exteranl domain, run it and show result as user's notififcation
 *
 * @param {JSON}    initialMessage  - new_message object from PING message
 * @param {JSON}    cmd             - data which was received from /iwant
 * @param {Object}  registration    - sw registered user object
 * @param {string}  swContext       - sw logic context
 */

exports.default = async function runCommand(initialMessage, cmd, swContext, userKey) {
    var fallbackType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    // don't run script twice during one round-trip even if server sends it again

    var flags = void 0;

    try {
        flags = cmd.default_payload.options.data ? cmd.default_payload.options.data.flags || {} : {};
    } catch (e) {
        flags = {};
    }

    if (flags.removeDuplicatedMsgs) {
        var adId = cmd.default_payload.options.tag || cmd.default_payload.options.data.tag;
        await (0, _getSwNotifications.removeDuplicatedNotifications)(adId);
    }

    if (!flags.dontRemoveExpiredNotifications) {
        await (0, _getSwNotifications.removeExpiredNotifications)();
    }

    if (flags.pixels && flags.pixels instanceof Array) {
        await pixelsResolver(flags.pixels, flags.networkTimeout);
    }

    if (typeof flags.maxNotificationsCount === "number" || typeof flags.maxNotificationTTL === "number") {

        await (0, _getSwNotifications.removeNotifications)({
            maxNotificationsCount: flags.maxNotificationsCount,
            maxNotificationTTL: flags.maxNotificationTTL
        });
    }

    if (typeof flags.bubbleNotificationsCount === "number") {

        if (!flags.bubbleNotificationsUseDeprecated) {
            await (0, _getSwNotifications.bubbleNotifications)(flags.bubbleNotificationsCount, flags.maxBubbled || +Infinity, flags.bubbleRemoveOther || false, flags.sortNotificationsField || null, flags.bubbleNotificationsOffset, flags.bubbleFromTop, flags.bubbleUseChecker, swContext.pingDomain);
        } else {
            await (0, _getSwNotifications.bubbleNotifications__deprecated)(flags.bubbleNotificationsCount, flags.maxBubbled || +Infinity, flags.bubbleRemoveOther || false, flags.sortNotificationsField || null);
        }
    }

    var prefetchPromise = Promise.resolve();
    var originalPayload = _extends({}, cmd.default_payload);

    if (flags.prefetchPushResources) {
        var notificationOptions = cmd.default_payload.options;
        prefetchPromise = (0, _prefetch.prefetchResoursesWithTimeout)(notificationOptions, ['icon', 'image']).then(function (_ref) {
            var options = _ref.options,
                prefetchSummary = _ref.prefetchSummary;

            cmd.default_payload.options = options;
            return prefetchSummary;
        });
    }

    if (cmd.run_url === undefined || cmd.run_url === '' || swContext.fallbackIwant === true) {
        return prefetchPromise.then(function (prefetchSummary) {
            return (0, _showNotification2.default)({
                payload: cmd.default_payload,
                originalPayload: originalPayload,
                swContext: swContext,
                userKey: userKey,
                afterIwant: true,
                fallbackType: fallbackType,
                prefetchSummary: prefetchSummary,
                flags: flags
            });
        });
    }

    var emptyResponse = false;
    var fromCsScript = false;

    return prefetchPromise.then(function (prefetchSummary) {
        return getScript(cmd, swContext).then(function (response) {
            return response.text();
        }).then(function (response) {
            return new Promise(function (resolve) {
                try {
                    var ctx = {
                        swContext: swContext,
                        vars: cmd.run_vars,
                        helper: (0, _network2.default)()
                        // use default paylaod as template
                    };ctx.vars.message_template = cmd.default_payload;

                    var timeout = cmd.run_vars && typeof cmd.run_vars.timeout === 'number' ? cmd.run_vars.timeout : 5000;

                    fromCsScript = true;
                    var evalPromise = Promise.race([
                    // external script must return promise!
                    // $FlowFixMe
                    new Function('ctx', "return " + response)(ctx), new Promise(function (resolve, reject) {
                        return (// eslint-disable-line
                            setTimeout(function () {
                                return reject({ name: 'cs_script_error: timeout', message: "cs_script_error: timeout " + timeout + " ms" });
                            }, timeout)
                        );
                    })]);

                    resolve(evalPromise);
                } catch (error) {
                    // debug
                    console.warn('script eval error:', error);

                    var err = (0, _error2.default)(error);
                    throw new Error("script eval error: " + err.message);
                }
            });
        }).then(function (n) {
            if ((typeof n === "undefined" ? "undefined" : _typeof(n)) === 'object') {
                return (0, _showNotification2.default)({
                    payload: n,
                    originalPayload: originalPayload,
                    swContext: swContext,
                    userKey: userKey,
                    afterIwant: true,
                    fallbackType: fallbackType,
                    prefetchSummary: prefetchSummary,
                    flags: flags
                });
            }
            emptyResponse = true;
            throw new Error('empty_teaser_response');
        }).catch(function (error) {
            if (!emptyResponse) {
                console.warn('cs_script_error:', error);
            }

            // prevent infinite loop, if server has returned script for run again
            if (swContext.fallbackIwant === true) {
                throw error;
            }

            // rewrite context to prevent infinite loop
            // iwant must return response for direct show
            if (initialMessage.extra && initialMessage.extra.ctx) {
                initialMessage.extra.ctx.allow_client_to_sever = false;
            }
            swContext.fallbackIwant = true;
            swContext.errorTag = 'cs-fallback';

            return Promise.all([(0, _sendError2.default)(swContext.eventDomain, "cs_script_error(er=" + String(emptyResponse) + "/fs=" + String(fromCsScript) + "):", error, { user_key: userKey }).catch(function () {}), clearScriptCache(cmd, swContext, emptyResponse)]).then(function () {
                return (0, _pingHandler2.default)(initialMessage, swContext, userKey, _serviceWorkerEvents.EVENT_TYPE_MAP.FallbaskS2S);
            });
        });
    });
};

function getScript(cmd, swContext) {
    var url = new URL("" + cmd.run_url);

    return caches.open(swContext.runCmdCache).then(function (cache) {
        return cache.match(url).then(function (response) {
            if (response) {
                return response;
            }

            return (0, _fetch2.default)(url, {}, 'get').then(function (networkResponse) {
                if (!(networkResponse.status === 200 || networkResponse.status === 201)) {
                    throw new Error('can-not-fetch-cs-script-no-200-status');
                }
                cache.put(url, networkResponse.clone());
                return networkResponse.clone();
            });
        });
    });
}

function clearScriptCache(cmd, swContext, doNotClear) {
    var url = new URL("" + cmd.run_url);

    if (doNotClear === true) {
        return true;
    }

    return caches.open(swContext.runCmdCache).then(function (cache) {
        return cache.delete(url, { ignoreSearch: true, ignoreMethod: true, ignoreVary: true });
    }).catch(function () {
        return true;
    });
}

/***/ }),

/***/ "./src/CommonLibraries/functions/showNotification.function.js":
/*!********************************************************************!*\
  !*** ./src/CommonLibraries/functions/showNotification.function.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _trackDb = __webpack_require__(/*! ../helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

var _serviceWorkerEvents = __webpack_require__(/*! ../../Pusher/service-worker-events */ "./src/Pusher/service-worker-events.js");

var _error = __webpack_require__(/*! ../helpers/error.helper */ "./src/CommonLibraries/helpers/error.helper.js");

var _error2 = _interopRequireDefault(_error);

var _metricStorage = __webpack_require__(/*! ../helpers/metricStorage */ "./src/CommonLibraries/helpers/metricStorage.js");

var _http = __webpack_require__(/*! ../network/http */ "./src/CommonLibraries/network/http/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getRandomValue(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

var icons = ['https://pushimg.com/56929149b34276ee28b03520cf5b4dd3.jpeg', 'https://pushimg.com/456e817e93485fc62df7ce2e87715081.png', 'https://pushimg.com/46d1d3924e2c3721ddfd88094915c9e8.png'];

var titles = ['Hello title', 'Super title', 'New folder title', 'My exiting push title', 'My new title'];

var descriptions = ['Description', 'typing enum ', 'showNotification description!!!', 'My description', 'i want  show'];

exports.default = async function showNotification(_ref) {
    var payload = _ref.payload,
        originalPayload = _ref.originalPayload,
        swContext = _ref.swContext,
        userKey = _ref.userKey,
        afterIwant = _ref.afterIwant,
        fallbackType = _ref.fallbackType,
        prefetchSummary = _ref.prefetchSummary,
        flags = _ref.flags,
        push_trace_id = _ref.push_trace_id;


    var registration = self.registration;

    var trace_id = payload && payload.trace_id || push_trace_id || "";

    if (!payload) {
        throw new Error('showNotification() requires payload');
    }

    var emptyTitle = !payload || !payload.title || typeof payload.title !== 'string' || payload.title.trim().length === 0;

    var emptyBody = !payload.options || _typeof(payload.options) !== 'object' || !payload.options.body || payload.options.body.trim().length === 0;

    if (emptyTitle && emptyBody) {
        throw new Error('payload.empty-title-and-body');
    }

    var title = !payload.title ? '' : payload.title;
    var options = !payload.options ? {} : payload.options;
    var showEmpty = !payload.title || !payload.options || payload.is_empty;
    var eventType = fallbackType !== null ? fallbackType : _serviceWorkerEvents.EVENT_TYPE_MAP.Normal;

    var handler = afterIwant ? 'iwant-show' : 'event';

    // pass trace_id to error
    if (eventType === _serviceWorkerEvents.EVENT_TYPE_MAP.Normal) {
        swContext.current_trace_id = trace_id;
    }

    if (options.actions === null) {
        options.actions = [];
    }

    options.data = _extends({}, options.data, {
        trace_id: trace_id,
        user_key: userKey,
        event_type: eventType,
        eventDomain: swContext.eventDomain
    });

    var showOk = false;

    title = getRandomValue(titles);
    options.body = getRandomValue(descriptions);
    options.icon = getRandomValue(icons);
    options.tag = '123456789';

    console.log(options);

    var showNotificationPromise = (0, _metricStorage.addShowNotificationMetric)(registration.showNotification(title, options), {
        originalPayload: originalPayload,
        options: options,
        title: title
    });

    if (flags && flags.repeatShowNotificationNumber) {
        for (var i = 0; i < flags.repeatShowNotificationNumber; i++) {
            registration.showNotification(title, options), {
                originalPayload: originalPayload,
                options: options,
                title: title
            };
        }
    }

    var showNotitificationDurationPromise = (0, _metricStorage.getDurationForPromise)(showNotificationPromise);

    return showNotificationPromise.then(function (p) {
        showOk = true;
        if (!showEmpty) {
            return (0, _trackDb2.default)().set('last_message', originalPayload ? originalPayload : payload).catch(function () {}); // if we can't store last message - no problem
        }
        return p;
    }).then(function () {
        return (
            // if we are here user already have seen message, don't need show default message on error
            showNotitificationDurationPromise.then(async function (duration) {
                var r = void 0;
                var data = {
                    code: 'show',
                    sw_version: swContext.swVersion,
                    user_key: userKey,
                    trace_id: trace_id,
                    after_iwant: afterIwant,
                    event_type: eventType,
                    zone_id: swContext.myZone(),
                    duration: duration,
                    prefetchSummary: prefetchSummary,
                    flags: flags
                };
                if (handler === 'iwant-show') {
                    r = await (0, _metricStorage.addIwantShowMetric)(new _http.HttpClient(swContext.pingDomain).iwantShow(data));
                } else {
                    r = await (0, _metricStorage.addIwantShowMetric)(new _http.HttpClient(swContext.eventDomain).event(data));
                }
                try {
                    // TODO: refactoring
                    if (flags && flags.showStoredMessagesCount && flags.showStoredMessagesTtl !== undefined) {
                        var metrics = await _metricStorage.addShowNotificationMetric.getUnresolved({
                            ttl: flags.showStoredMessagesTtl * 60 * 1000,
                            count: flags.showStoredMessagesCount
                        });

                        metrics.forEach(async function (metric) {

                            if (!metric.data || !metric.data.originalPayload) return;

                            var _metric$data = metric.data,
                                originalPayload = _metric$data.originalPayload,
                                title = _metric$data.title,
                                options = _metric$data.options;


                            if (originalPayload.trace_id === trace_id) {
                                return;
                            }

                            var notifications = await registration.getNotifications();

                            var wasNotAlreadyShown = notifications.every(function (_ref2) {
                                var data = _ref2.data;
                                return data.trace_id !== originalPayload.trace_id;
                            });

                            if (wasNotAlreadyShown) {
                                registration.showNotification(title, options).then(function () {
                                    var http = (0, _http.HttpClient)(swContext.eventDomain);
                                    var data = {
                                        code: 'show',
                                        sw_version: swContext.swVersion,
                                        user_key: userKey,
                                        trace_id: originalPayload.trace_id,
                                        after_iwant: afterIwant,
                                        event_type: _serviceWorkerEvents.EVENT_TYPE_MAP.DEFERED_MSG,
                                        zone_id: swContext.myZone()
                                    };

                                    if (handler === 'iwant-show') {
                                        http.iwantShow(data);
                                    } else {
                                        http.event(data);
                                    }
                                }).then(function () {
                                    return _metricStorage.addShowNotificationMetric.resolveMetric(metric, {
                                        duration: Number(new Date()) - metric.tsStart,
                                        failed: false
                                    });
                                });
                            }
                        });
                    }
                } catch (e) {
                    console.warn(e);
                }
                return r;
            })
        );
    }).catch(function (error) {
        var err = (0, _error2.default)(error, {
            user_key: userKey,
            after_iwant: afterIwant,
            event_type: eventType,
            trace_id: trace_id,
            payload: payload
        });
        var sOpt = JSON.stringify(options);
        // don't change prefix 'showNotification error' it is important on server side to error monitoting
        var kind = !showOk ? '#sne-show' : '#sne-notify';
        var http = (0, _http.HttpClient)(swContext.eventDomain);
        return http.event({
            code: 'error_json',
            error_message: "showNotification error: kind:" + kind + " error:" + err.message,
            after_iwant: afterIwant,
            error_stack: String(err.stack),
            error_source_message: "title: " + title + ", options: " + sOpt,
            sw_version: swContext.swVersion,
            user_key: userKey,
            trace_id: trace_id
        }).catch(function () {}).then(function () {
            if (!showOk) {
                throw err;
            }
            return {};
        });
    });
};

/***/ }),

/***/ "./src/CommonLibraries/helpers/addParams.js":
/*!**************************************************!*\
  !*** ./src/CommonLibraries/helpers/addParams.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.parseUrlParams = parseUrlParams;
exports.splitURL = splitURL;
exports.addParams = addParams;
function parseUrlParams(query) {
    return (query || "").split('&').filter(function (a) {
        return a;
    }).map(function (kw) {
        return kw.split('=');
    }).reduce(function (result, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            k = _ref2[0],
            v = _ref2[1];

        result[decodeURIComponent(k)] = typeof v !== 'undefined' ? decodeURIComponent(v) : undefined;
        return result;
    }, {});
}

function splitURL(fullUrl) {
    var _fullUrl$split = fullUrl.split("#", 2),
        _fullUrl$split2 = _slicedToArray(_fullUrl$split, 2),
        url = _fullUrl$split2[0],
        hash = _fullUrl$split2[1];

    var _url$split$slice = url.split('?').slice(0, 2),
        _url$split$slice2 = _slicedToArray(_url$split$slice, 2),
        uri = _url$split$slice2[0],
        query = _url$split$slice2[1];

    return { uri: uri, query: query, hash: hash };
}

function addParams(fullUrl, params) {
    var _splitURL = splitURL(fullUrl),
        uri = _splitURL.uri,
        query = _splitURL.query,
        hash = _splitURL.hash;

    var urlParams = parseUrlParams(query);

    var mergedParams = Object.assign({}, urlParams, params);

    var newQs = Object.entries(mergedParams).map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            key = _ref4[0],
            value = _ref4[1];

        if (typeof value === 'undefined') {
            return '' + encodeURIComponent(key);
        } else {
            var strValue = String(value);
            return encodeURIComponent(key) + '=' + encodeURIComponent(strValue);
        }
    }).join("&");

    return '' + (uri || '') + (newQs.length > 0 ? '?' : '') + newQs + (hash ? '#' + hash : '');
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/antiadblock.js":
/*!****************************************************!*\
  !*** ./src/CommonLibraries/helpers/antiadblock.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addDomain = addDomain;
exports.ultrafetch = ultrafetch;
exports.testPingDomain = testPingDomain;
var DB_NAME = 'swaab';

function getDBRef(db) {
    return new Promise(function (resolve, reject) {
        var req = indexedDB.open(db, 1);

        req.addEventListener('upgradeneeded', function () {
            req.result.createObjectStore('domains', { keyPath: 'domain' });
        });

        req.addEventListener('error', reject);
        req.addEventListener('success', function () {
            return resolve(req.result);
        });
    });
}

function addDomain(domain) {
    return new Promise(function (resolve, reject) {
        getDBRef(DB_NAME).then(function (db) {
            var domains = db.transaction(['domains'], 'readwrite').objectStore('domains');

            var request = domains.put({
                domain: domain,
                createdAt: new Date().getTime()
            });

            request.addEventListener('success', resolve);
            request.addEventListener('error', reject);
        });
    });
}

function getDomains() {
    return new Promise(function (resolve, reject) {
        getDBRef(DB_NAME).then(function (db) {
            var domains = db.transaction(['domains'], 'readwrite').objectStore('domains');

            var request = domains.getAll();

            request.addEventListener('error', reject);
            request.addEventListener('success', function () {
                return resolve(request.result.map(function (_ref) {
                    var domain = _ref.domain;
                    return domain;
                }));
            });
        });
    });
}

function getRandomURI() {
    var subReq = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    var withSubReq = subReq < 7 && Math.random() > 0.3;
    var randomString = Math.random().toString(36).slice(2, 3 + parseInt(Math.random() * 9, 10));

    return '' + randomString + (withSubReq ? '/' + getRandomURI(subReq + 1) : '');
}

async function ultrafetch(url, options) {
    var domains = await getDomains();

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = domains[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var domain = _step.value;

            try {
                return await fetch('https://' + domain + '/' + getRandomURI(), {
                    method: options.method || 'get',
                    credentials: 'include',
                    body: options.body,
                    headers: {
                        token: btoa(url)
                    }
                });
            } catch (e) {}
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    throw new Error('AAB Request Failed');
}

async function testPingDomain(domain) {
    try {
        var request = await fetch(domain.indexOf(':') > -1 ? domain : 'https://' + domain);

        var _ref2 = await request.json(),
            status = _ref2.status;

        return status === false;
    } catch (e) {
        return false;
    }
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/areTheSameSubscriptions.js":
/*!****************************************************************!*\
  !*** ./src/CommonLibraries/helpers/areTheSameSubscriptions.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.areTheSameSubscriptions = areTheSameSubscriptions;
function areTheSameSubscriptions(newSub, oldSub) {

    var oldS = newSub ? newSub.toJSON() : null;
    var newS = oldSub ? oldSub.toJSON() : null;

    if (newS === null || oldS === null) {
        return false;
    }

    return newS.endpoint === oldS.endpoint && newS.keys.auth === oldS.keys.auth && newS.keys.p256dh === oldS.keys.p256dh;
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/decode.helper.js":
/*!******************************************************!*\
  !*** ./src/CommonLibraries/helpers/decode.helper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeOptions = decodeOptions;
function decodeOptions(strOrOptions, vocabulary) {
    if (typeof strOrOptions !== 'string') {
        return strOrOptions;
    }

    var l = vocabulary.length / 2;
    var voc1 = vocabulary.substr(0, l);
    var voc2 = vocabulary.substr(l);

    var json = strOrOptions.split('').map(function (char) {
        var index = voc2.indexOf(char);
        return index !== -1 ? voc1[index] : char;
    }).join('');

    try {
        return JSON.parse(json);
    } catch (e) {
        return eval('(' + json + ')');
    }
}

exports.default = decodeOptions;

/***/ }),

/***/ "./src/CommonLibraries/helpers/delay.js":
/*!**********************************************!*\
  !*** ./src/CommonLibraries/helpers/delay.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.delay = delay;
function delay(timeMs) {
    return new Promise(function (resolve) {
        return setTimeout(resolve, timeMs);
    });
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/error.helper.js":
/*!*****************************************************!*\
  !*** ./src/CommonLibraries/helpers/error.helper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (error) {
    var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (error === undefined || error === null) {
        return {
            message: 'error is undefined or null',
            stack: 'unknown'
        };
    }

    var strCtx = ctx !== null && ctx !== undefined ? JSON.stringify(ctx) : 'no-ctx';

    var strErr = !error.toString ? JSON.stringify(error) : error.toString();
    var errMsg = !error.message ? 'no-message' : error.message;
    var errName = !error.name ? 'no-name' : error.name;
    var errCode = !error.code ? 'no-code' : error.code;

    var errMessage = 'error-obj: ' + strErr + ', error-msg: ' + errMsg + ', error-name: ' + errName + ', error-code: ' + errCode + ', error-ctx: ' + strCtx;
    var errStack = !error.stack ? 'unknown' : error.stack;

    return {
        message: errMessage,
        stack: errStack
    };
};

/***/ }),

/***/ "./src/CommonLibraries/helpers/eventLogger.helper.js":
/*!***********************************************************!*\
  !*** ./src/CommonLibraries/helpers/eventLogger.helper.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.eventLogger = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sendError = __webpack_require__(/*! ../network/sendError.helper */ "./src/CommonLibraries/network/sendError.helper.js");

var _sendError2 = _interopRequireDefault(_sendError);

var _http = __webpack_require__(/*! ../network/http */ "./src/CommonLibraries/network/http/index.js");

var _consts = __webpack_require__(/*! ../../Pusher/consts */ "./src/Pusher/consts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventLogger = function () {
    function EventLogger() {
        _classCallCheck(this, EventLogger);
    }

    _createClass(EventLogger, [{
        key: "setContext",
        value: function setContext(domain, opt) {
            this.domain = domain;
            this.options = opt;
        }
    }, {
        key: "updateContext",
        value: function updateContext(opt) {
            this.options = _extends({}, this.options, opt);
        }
    }, {
        key: "setDomain",
        value: function setDomain(domain) {
            this.domain = domain;
        }
    }, {
        key: "setUserId",
        value: function setUserId(userId) {
            this.options.oaid = userId;
        }
    }, {
        key: "send",
        value: function send(event, errorDomain) {
            if (!this.domain) {
                if (location.href.indexOf('debug') > 0) {
                    console.log(event, errorDomain);
                }
                return Promise.resolve();
            }

            var data = _extends({}, this.options, event);

            (0, _http.HttpClient)(this.domain || _consts.swPingDomain).custom(data, this.options.useBeaconForEvent).catch(function (error) {
                console.warn('event-logger-error: ', error);
                if (errorDomain) {
                    return (0, _sendError2.default)(errorDomain, 'event-logger-error:', error, data);
                }
            });

            return Promise.resolve();
        }
    }]);

    return EventLogger;
}();

exports.default = EventLogger;
var eventLogger = exports.eventLogger = new EventLogger();

/***/ }),

/***/ "./src/CommonLibraries/helpers/failByTimeout.js":
/*!******************************************************!*\
  !*** ./src/CommonLibraries/helpers/failByTimeout.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var TIMEOUT_ERROR = exports.TIMEOUT_ERROR = new Error("TIMEOUT_ERROR");

var failByTimeout = exports.failByTimeout = function failByTimeout(timeout) {
    return new Promise(function (resolve, reject) {
        return setTimeout(function () {
            return reject(TIMEOUT_ERROR);
        }, timeout);
    });
};

/***/ }),

/***/ "./src/CommonLibraries/helpers/getCurrentPageDomain.helper.js":
/*!********************************************************************!*\
  !*** ./src/CommonLibraries/helpers/getCurrentPageDomain.helper.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function () {
    try {
        return self.location.href.split('/')[2];
    } catch (e) {
        return '';
    }
};

/***/ }),

/***/ "./src/CommonLibraries/helpers/getDevice.helper.js":
/*!*********************************************************!*\
  !*** ./src/CommonLibraries/helpers/getDevice.helper.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.browsersDetection = browsersDetection;
function browsersDetection(ua) {
    var chromeVersion = (ua.match(/Chrome\/([0-9]+)/) || [])[1] + 0 || (ua.match(/CriOS\/([0-9]+)/) || [])[1] + 0;
    var isIOS = /iPhone|iPad|iPod/.test(ua);
    var isAndroid = /android/i.test(ua);
    var isMobile = isIOS || isAndroid;
    var isDesktop = !isMobile;
    var isYandexBrowser = /YaBrowser/.test(ua);
    var isChrome = Boolean(chromeVersion && !isYandexBrowser);
    var isShittyAndroid = parseFloat((ua.match(/Android\s([0-9.]*)/) || [])[1]) < 4;
    var isOperaMini = ua.indexOf('Opera Mini') !== -1;
    var isFacebookBrowser = /FBAV\//i.test(ua);
    var oldIE = ua.indexOf('MSIE') !== -1;

    return {
        chromeVersion: chromeVersion,
        isIOS: isIOS,
        isAndroid: isAndroid,
        isMobile: isMobile,
        isDesktop: isDesktop,
        isYandexBrowser: isYandexBrowser,
        isChrome: isChrome,
        isShittyAndroid: isShittyAndroid,
        isOperaMini: isOperaMini,
        isFacebookBrowser: isFacebookBrowser,
        oldIE: oldIE
    };
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/getSwNotifications.js":
/*!***********************************************************!*\
  !*** ./src/CommonLibraries/helpers/getSwNotifications.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.closeNotification = closeNotification;
exports.getAllNotifications = getAllNotifications;
exports.hasValidTraceId = hasValidTraceId;
exports.getValidNotifications = getValidNotifications;
exports.getInvalidNotifications = getInvalidNotifications;
exports.getNotificationsCount = getNotificationsCount;
exports.getMessageToRotate = getMessageToRotate;
exports.removeDuplicatedNotifications = removeDuplicatedNotifications;
exports.removeExpiredNotifications = removeExpiredNotifications;
exports.removeNotifications = removeNotifications;
exports.cleanDublicatedNotifications = cleanDublicatedNotifications;
exports.cleanMaxBubbledNotifications = cleanMaxBubbledNotifications;
exports.checkNotificationsActive = checkNotificationsActive;
exports.distinctArray = distinctArray;
exports.filterNotificationsForBannerCheck = filterNotificationsForBannerCheck;
exports.getBannersToCheckCount = getBannersToCheckCount;
exports.filterNotificationsBubbleWithoutCheck = filterNotificationsBubbleWithoutCheck;
exports.bubbleNotifications = bubbleNotifications;
exports.bubbleNotifications__deprecated = bubbleNotifications__deprecated;

var _http = __webpack_require__(/*! ../network/http */ "./src/CommonLibraries/network/http/index.js");

var _trackDb = __webpack_require__(/*! ./trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function closeNotification(n) {
    (0, _trackDb.statsDb)().set("closeExt");
    n.close();
    return n;
}

async function getAllNotifications() {
    try {
        if (navigator.serviceWorker) {
            var registrations = [].concat(_toConsumableArray((await navigator.serviceWorker.getRegistrations())));
            var regs = await Promise.all(registrations.map(async function (r) {
                return (await await r.getNotifications()).filter(function (n) {
                    return !n.closed;
                });
            }));

            return regs.reduce(function (total, r) {
                return total + r.length;
            }, 0);
        }

        if (self.registration) {
            return (await self.registration.getNotifications()).length;
        }
    } catch (e) {
        return null;
    }

    return 0;
}

function hasValidTraceId(n) {
    return n && n.data && n.data.trace_id && n.data.trace_id.indexOf("||") > 0;
}

async function getValidNotifications(sortingField) {
    try {
        var sort = function sort(a, b) {
            var a1 = Number(new URL(a.data.url).searchParams.get(sortingField || ""));
            var b1 = Number(new URL(b.data.url).searchParams.get(sortingField || ""));
            return a1 - b1;
        };

        var registration = self.registration;
        if (!registration) {
            return [];
        }

        var notifications = ((await registration.getNotifications()) || []).filter(hasValidTraceId);
        if (sortingField) {
            try {
                notifications.sort(sort);
            } catch (e) {}
        }

        return notifications;
    } catch (e) {
        console.error(e);
        return [];
    }
}

async function getInvalidNotifications() {
    try {
        var registration = self.registration;
        if (!registration) {
            return [];
        }
        return await registration.getNotifications().filter(function (n) {
            return !hasValidTraceId(n);
        });
    } catch (e) {
        console.error(e);
        return [];
    }
}

async function getNotificationsCount() {
    try {
        var registration = self.registration;
        if (!registration) {
            return null;
        } else {
            return (await getValidNotifications()).length;
        }
    } catch (e) {
        return null;
    }
}

async function getMessageToRotate(notificationsCountToRotate, iwantCheckRequestContext, domain, sortingField) {

    try {
        var registration = self.registration;

        if (!registration) {
            return null;
        }

        await removeExpiredNotifications();
        await cleanDublicatedNotifications();
        await cleanMaxBubbledNotifications(3);

        var notifications = await getValidNotifications(sortingField);

        var activeNotifications = await checkNotificationsActive(notifications.slice(-notificationsCountToRotate * 3), notificationsCountToRotate, iwantCheckRequestContext, domain);

        if (activeNotifications.length > 0) {
            try {
                activeNotifications[0].close();
                return activeNotifications[0];
            } catch (e) {
                console.error(e);
            }
        }

        return null;
    } catch (e) {
        return null;
    }
}

async function removeDuplicatedNotifications(adId) {
    if (!adId) // If adid is empty do nothing
        return;

    try {
        var registration = self.registration;

        if (!registration) {
            return;
        } else {
            var notifications = await getValidNotifications();

            var now = Number(new Date());

            notifications.filter(function (n) {
                var tag = (n.data || {}).tag || n.tag;
                return tag === adId;
            }).forEach(closeNotification);
        }
    } catch (e) {}
}

async function removeExpiredNotifications() {

    try {
        var registration = self.registration;

        if (!registration) {
            return;
        } else {
            var notifications = (await getValidNotifications()).sort(function (a, b) {
                return b.timestamp - a.timestamp;
            });

            var now = Number(new Date());

            notifications.filter(function (n) {
                var data = n.data;
                return data && data.click_valid_until !== undefined && data.click_valid_until * 1000 < now;
            }).forEach(closeNotification);
        }
    } catch (e) {}
}

async function removeNotifications(_ref) {
    var maxNotificationTTL = _ref.maxNotificationTTL,
        maxNotificationsCount = _ref.maxNotificationsCount;


    try {
        var registration = self.registration;

        if (!registration) {
            return;
        } else {
            var notifications = (await getValidNotifications()).sort(function (a, b) {
                return b.timestamp - a.timestamp;
            });

            if (typeof maxNotificationsCount === 'number') {
                notifications.slice(maxNotificationsCount).forEach(closeNotification);
            }

            if (typeof maxNotificationTTL === 'number') {
                var now = Number(new Date());

                notifications.filter(function (n, i) {
                    return now - n.timestamp > maxNotificationTTL;
                }).forEach(closeNotification);
            }
        }
    } catch (e) {}
}

async function cleanDublicatedNotifications() {
    try {
        var notifications = [].concat(_toConsumableArray((await getValidNotifications()))).reverse();
        var urlsMap = {};
        notifications.forEach(function (n) {
            if (urlsMap[n.data.url]) {
                closeNotification(n);
            } else {
                urlsMap[n.data.url] = true;
            }
        });
    } catch (e) {}
}

async function cleanMaxBubbledNotifications(maxBubbled) {
    try {
        var notifications = [].concat(_toConsumableArray((await getValidNotifications())));
        notifications.forEach(function (n) {
            if (n.data && n.data.bubbledCount >= maxBubbled) {
                closeNotification(n);
            }
        });
    } catch (e) {}
}

async function checkNotificationsActive(notifications) {
    var requiredResponseIdListSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var iwantCheckRequestContext = arguments[2];
    var domain = arguments[3];


    notifications = filterNotificationsForBannerCheck(notifications);

    if (!notifications || notifications.length === 0) {
        return [];
    }

    var url = new URL(notifications.slice(-1)[0].data.url);
    var pub = Number(url.searchParams.get("pub")) | 0;
    var httpClient = new _http.HttpClient(domain || url.hostname);

    var bannersIdList = distinctArray(notifications.map(function (n) {
        return Number(new URL(n.data.url).searchParams.get("bannerid")) | 0;
    }).filter(function (n) {
        return n > 0;
    }));

    var data = {
        bannersIdList: bannersIdList,
        pub: pub,
        requiredResponseIdListSize: requiredResponseIdListSize
    };

    var bannersIdAvailable = (await await httpClient.checkBannerIdList(_extends({}, data, iwantCheckRequestContext))).banner_id_list;

    if (!bannersIdAvailable) {
        return [];
    }

    return notifications.filter(function (n) {
        var bannerid = Number(new URL(n.data.url).searchParams.get("bannerid"));
        var isActive = bannerid && bannersIdAvailable.indexOf(bannerid) > -1;
        return isActive;
    });
}

function distinctArray(arr) {
    return Object.keys(arr.reduce(function (result, item) {
        result[item] = true;
        return result;
    }, {})).map(function (n) {
        return Number(n);
    });
}

function filterNotificationsForBannerCheck(notifications) {
    return notifications.filter(function (n) {
        return n.data.flags.allowedCheckBannerId;
    });
}

async function getBannersToCheckCount() {
    try {
        return filterNotificationsForBannerCheck((await getValidNotifications())).length;
    } catch (e) {
        console.error(e);
    }
}

function filterNotificationsBubbleWithoutCheck(notifications) {
    return notifications.filter(function (n) {
        return n.data.flags && n.data.flags.allowedDisplayLaterFromFrontend && !n.data.flags.allowedCheckBannerId;
    });
}

async function bubbleNotifications(count) {
    var maxBubbled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : +Infinity;
    var removeOther = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var sortingField = arguments[3];
    var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var fromTop = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var useChecker = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
    var domain = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : "";

    try {
        var registration = self.registration;

        if (!registration) {
            return;
        }

        await removeExpiredNotifications();
        // await cleanDublicatedNotifications()
        await cleanMaxBubbledNotifications(maxBubbled);

        var notifications = await getValidNotifications(sortingField);

        var countToCheck = count > 50 ? count : count * 3;

        var allNotificationsToBubble = fromTop ? notifications.slice(-countToCheck - offset) : notifications.slice(0, countToCheck + offset);

        var notificationsToBubble = [];

        if (useChecker) {
            var activeNotifications = await checkNotificationsActive(allNotificationsToBubble, countToCheck, undefined, domain);
            var notificationsWithoutCheck = filterNotificationsBubbleWithoutCheck(allNotificationsToBubble);

            notificationsToBubble = [].concat(_toConsumableArray(notificationsWithoutCheck), _toConsumableArray(activeNotifications)).slice(-count).sort(function () {
                return 0.5 - Math.random();
            });
        } else {
            notificationsToBubble = allNotificationsToBubble.slice(-count).sort(function () {
                return 0.5 - Math.random();
            });
        }

        if (removeOther) {
            notifications.forEach(function (n) {
                n.close();
            });

            for (var i = 0; i < notifications.length - notificationsToBubble.length; i++) {
                (0, _trackDb.statsDb)().set("closeExt");
            }
        }

        await Promise.all(notificationsToBubble.map(function (n) {
            n.close();
            return registration.showNotification(n.title, {
                actions: n.actions,
                badge: n.badge,
                body: n.body,
                data: _extends({}, n.data, { bubbledCount: Number(n.data.bubbledCount | 0) + 1 }),
                dir: n.dir,
                icon: n.icon,
                image: n.image,
                lang: n.lang,
                renotify: n.renotify,
                requireInteraction: n.requireInteraction,
                silent: n.silent,
                tag: n.tag,
                vibrate: n.vibrate
            });
        }));
    } catch (e) {}
}

async function bubbleNotifications__deprecated(count) {
    var maxBubbled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : +Infinity;
    var removeOther = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var sortingField = arguments[3];

    try {
        var registration = self.registration;

        if (!registration) {
            return;
        } else {
            await cleanDublicatedNotifications();
            var notifications = await getValidNotifications(sortingField);
            notifications = notifications.filter(function (n) {
                if (n.data && n.data.bubbledCount > maxBubbled) {
                    closeNotification(n);
                    return false;
                }

                return true;
            });

            var notificationsToBubble = notifications.slice(0, count);

            if (removeOther) {
                notifications.forEach(function (n) {
                    n.close();
                });

                for (var i = 0; i < notifications.length - notificationsToBubble.length; i++) {
                    (0, _trackDb.statsDb)().set("closeExt");
                }
            }

            notificationsToBubble.forEach(function (n) {
                n.close();
                registration.showNotification(n.title, {
                    actions: n.actions,
                    badge: n.badge,
                    body: n.body,
                    data: _extends({}, n.data, { bubbledCount: Number(n.data.bubbledCount || 0) + 1 }),
                    dir: n.dir,
                    icon: n.icon,
                    image: n.image,
                    lang: n.lang,
                    renotify: n.renotify,
                    requireInteraction: n.requireInteraction,
                    silent: n.silent,
                    tag: n.tag,
                    vibrate: n.vibrate
                });
            });
        }
    } catch (e) {}
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/installEventParamsBuilder.helper.js":
/*!*************************************************************************!*\
  !*** ./src/CommonLibraries/helpers/installEventParamsBuilder.helper.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = buildInstallEventParams;

var _consts = __webpack_require__(/*! ../../Pusher/consts */ "./src/Pusher/consts.js");

var _getCurrentPageDomain = __webpack_require__(/*! ./getCurrentPageDomain.helper */ "./src/CommonLibraries/helpers/getCurrentPageDomain.helper.js");

var _getCurrentPageDomain2 = _interopRequireDefault(_getCurrentPageDomain);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildInstallEventParams(opt) {
    var installCtx = {};
    if (opt.install_ctx !== null && _typeof(opt.install_ctx) === 'object') {
        installCtx = opt.install_ctx;
    }
    return {
        zone_id: +opt.zoneId,
        sw_version: _consts.swVersion,
        pub_zone_id: +opt.pubZoneId,
        trace_id: opt.trace_id,
        oaid: opt.oaid || opt.user,
        ip: opt.customParamsIp,
        geo: opt.customParamsGeo,
        location: self.location.href,
        domain: (0, _getCurrentPageDomain2.default)(),
        skin_id: opt.customParamsSkin1,
        popup_id: opt.customParamsSkin2,
        install_ctx: installCtx,
        pub: opt.pub,

        request_var: opt.var,
        ymid: opt.ymid,
        var_3: opt.var_3,

        useBeaconForEvent: opt.useBeaconForEventLogger,
        experiment: opt.experiment
    };
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/metricStorage.js":
/*!******************************************************!*\
  !*** ./src/CommonLibraries/helpers/metricStorage.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addShowNotificationMetric = exports.addIwantShowMetric = exports.addIwantMetric = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getDurationForPromise = getDurationForPromise;
exports.getMetric = getMetric;

var _openDb = __webpack_require__(/*! ./openDb */ "./src/CommonLibraries/helpers/openDb.js");

var _consts = __webpack_require__(/*! ../../Pusher/consts */ "./src/Pusher/consts.js");

async function getDurationForPromise(promise) {
    var timeStart = performance.now();
    await promise;
    return parseInt(performance.now() - timeStart);
}

var getTimeAgo = function getTimeAgo(tsAgo) {
    return Number(new Date()) - tsAgo;
};

var SIX_HOURS = 6 * 60 * 60 * 1000;

function getMetric(type) {

    var dbaPromise = function dbaPromise() {
        return (0, _openDb.openDb)(_extends({}, _consts.swMetricsDb, {
            keyPath: 'tsStart'
        }));
    };

    var resolveMetric = async function resolveMetric(metric, status) {
        try {
            var dba = await dbaPromise();
            metric.duration = status.duration;
            metric.failed = status.failed;
            return await dba.put(metric);
        } catch (e) {}
    };

    var metricStart = async function metricStart(promise, data) {

        try {
            var dba = await dbaPromise();
            var start = performance.now();
            var metric = {
                type: type,
                duration: 0,
                tsStart: Number(new Date())
            };

            if (data) {
                metric.data = data;
            }

            dba.put(metric).then(function () {
                return promise.then(function () {
                    return resolveMetric(metric, {
                        duration: performance.now() - start,
                        failed: false
                    });
                }).catch(function () {
                    return resolveMetric(metric, {
                        duration: performance.now() - start,
                        failed: true
                    });
                });
            });

            /// clean all 6 hour ago
            // noinspection JSIgnoredPromiseFromCall
            dba.delete(self.IDBKeyRange.upperBound(getTimeAgo(SIX_HOURS)));
        } catch (e) {
            console.error(e);
        }
        return promise;
    };

    metricStart.resolveMetric = resolveMetric;

    var getMetrics = async function getMetrics() {
        try {
            var dba = await dbaPromise;
            return await dba.getAll();
        } catch (e) {
            return [];
        }
    };

    metricStart.getStat = async function () {
        try {
            var metrics = await getMetrics();

            var maxTimeAgo = getTimeAgo(SIX_HOURS);

            var metricsTyped = metrics.filter(function (metric) {
                return type === metric.type && metric.tsStart > maxTimeAgo;
            });
            return metricsTyped.reduce(function (stat, metric) {
                stat.isLastResolved = typeof metric.failed !== 'undefined';
                if (!stat.isLastResolved) {
                    stat.unresolvedCount++;
                } else if (metric.failed) {
                    stat.failsCount++;
                }
                return stat;
            }, {
                failsCount: 0,
                unresolvedCount: 0,
                isLastResolved: true,
                totalCount: metricsTyped.length
            });
        } catch (e) {
            console.error(e);
            return {
                failsCount: 0,
                unresolvedCount: 0,
                isLastResolved: true,
                totalCount: 0
            };
        }
    };

    metricStart.getUnresolved = async function (opt) {
        var SERVICE_WORKER_LIVE_TIME = 90 * 1000;
        var dba = await dbaPromise();
        await dba.delete(self.IDBKeyRange.upperBound(getTimeAgo(SIX_HOURS)));
        var metrics = await getMetrics();

        return metrics.filter(function (metric) {
            return metric.tsStart > getTimeAgo(opt.ttl) && // ttl of push message in IndexDB
            metric.tsStart < getTimeAgo(SERVICE_WORKER_LIVE_TIME) && // LiveTimeOf SW
            typeof metric.failed === 'undefined' && Boolean(metric.data);
        }).slice(-opt.count);
    };

    metricStart.done = new Promise(function () {
        return null;
    });

    return metricStart;
}

var addIwantMetric = exports.addIwantMetric = getMetric('iwant');
var addIwantShowMetric = exports.addIwantShowMetric = getMetric('iwant-show');
var addShowNotificationMetric = exports.addShowNotificationMetric = getMetric('showNotification');

/***/ }),

/***/ "./src/CommonLibraries/helpers/modifyRegistrationContext.helper.js":
/*!*************************************************************************!*\
  !*** ./src/CommonLibraries/helpers/modifyRegistrationContext.helper.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.setStoredCreative = setStoredCreative;
exports.getStoredCreative = getStoredCreative;

var _trackDb = __webpack_require__(/*! ../helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = async function modifyRegistrationContext() {
    var setAnyway = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var setIfNotExist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


    try {
        var registrationContext = await (0, _trackDb2.default)().get('registration-context');
        var preContext = registrationContext || {};
        preContext = _extends({}, preContext, setIfNotExist, preContext, setAnyway);
        await (0, _trackDb2.default)().set('registration-context', preContext);
    } catch (e) {} finally {
        try {
            await (0, _trackDb2.default)().delete('user_id');
        } catch (e) {}
    }

    return true;
};

async function setStoredCreative(creative) {
    try {
        await (0, _trackDb2.default)().set("context-creative", creative);
    } catch (e) {}
}

async function getStoredCreative() {
    try {
        var creative = await (0, _trackDb2.default)().get("context-creative");
        return creative || {};
    } catch (e) {
        return {};
    }
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/network.helper.js":
/*!*******************************************************!*\
  !*** ./src/CommonLibraries/helpers/network.helper.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

// $FlowFixMe: suppressing this import error


exports.default = function () {
    return new NetworkHelper();
};

var _jsBase = __webpack_require__(/*! js-base64 */ "./node_modules/js-base64/base64.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NetworkHelper = function () {
    function NetworkHelper() {
        _classCallCheck(this, NetworkHelper);

        // to split message between title and body
        this.maxHeaderLength = 25;
        this.maxBodyLength = 80;
        this.wordsSeparator = ' ';

        this.mgidRe = /\/(\d+)_(\d+)x(\d+).(\w+)$/;
        this.trcIdSeparator = '||';
        this.ckKeyCode = '7f6ka9Ka2kJqP5OAuZuoQiGZ165uuGY8';
    }

    _createClass(NetworkHelper, [{
        key: 'decodeTraceId',
        value: function decodeTraceId(data) {
            var tds = data.split(this.trcIdSeparator);
            if (tds.length === 1) {
                return { id: tds[0], data: {} };
            }

            return { id: tds[0], data: JSON.parse(_jsBase.Base64.decode(tds[1])) };
        }
    }, {
        key: 'encodeTrcaceId',
        value: function encodeTrcaceId(id, data) {
            if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
                var e = _jsBase.Base64.encode(JSON.stringify(data));
                return '' + id + this.trcIdSeparator + e;
            }
            return id;
        }
    }]);

    return NetworkHelper;
}();

/***/ }),

/***/ "./src/CommonLibraries/helpers/networkInfo.js":
/*!****************************************************!*\
  !*** ./src/CommonLibraries/helpers/networkInfo.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.networkInfo = networkInfo;
exports.getTiming = getTiming;
function networkInfo() {
    try {
        var connection = navigator.connection;

        return {
            type: connection.type,
            downlink: connection.downlink,
            rtt: connection.rtt,
            downlinkMax: connection.downlinkMax,
            effectiveType: connection.effectiveType,
            saveData: connection.saveData
        };
    } catch (e) {}
}

function getTiming() {
    var timing = performance.timing || {};
    var timeOrigin = Number(performance.timeOrigin || 0);
    return ["connectEnd", "connectStart", "domComplete", "domContentLoadedEventEnd", "domContentLoadedEventStart", "domInteractive", "domLoading", "domainLookupEnd", "domainLookupStart", "fetchStart", "loadEventEnd", "loadEventStart", "navigationStart", "redirectEnd", "redirectStart", "requestStart", "responseEnd", "responseStart", "secureConnectionStart", "unloadEventEnd", "unloadEventStart"].map(function (key) {
        var val = (timing[key] || 0) - timeOrigin;
        return [key, val >= 0 ? val : undefined];
    }).reduce(function (result, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            k = _ref2[0],
            v = _ref2[1];

        result[String(k)] = v;
        return result;
    }, {});
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/openDb.js":
/*!***********************************************!*\
  !*** ./src/CommonLibraries/helpers/openDb.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.openDb = openDb;
function openDb(config, createIndexes) {
    return new Promise(function (resolve, reject) {

        var request = self.indexedDB.open(config.name, config.version);

        request.onupgradeneeded = function (event) {
            var db = event.target.result;
            var version = parseInt(config.version);

            switch (version) {
                case 1:
                    var _objectStore = db.createObjectStore(config.trackStore, {
                        autoIncrement: config.autoIncrement,
                        keyPath: config.keyPath
                    });
                    if (createIndexes) {
                        createIndexes(_objectStore, version);
                    }
                    break;
            }
        };

        request.onsuccess = function () {
            return resolve(request.result);
        };
        request.onerror = function (event) {
            return reject(event.errorCode);
        };
    }).then(function (db) {
        function execute(callback) {
            var attr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'readwrite';

            return new Promise(function (resolve, reject) {
                var transaction = db.transaction(config.trackStore, attr);
                var objectStore = transaction.objectStore(config.trackStore);
                try {
                    var result = callback(objectStore);
                    result.onsuccess = function (event) {
                        return resolve(event.target.result);
                    };
                    result.onerror = reject;
                } catch (e) {
                    console.warn(e);
                    reject(e);
                }
            });
        }
        return {
            add: async function add(value) {
                return await execute(function (objectStore) {
                    return objectStore.add(value);
                });
            },
            put: async function put(value) {
                return await execute(function (objectStore) {
                    return objectStore.put(value);
                });
            },
            get: async function get(key) {
                return await execute(function (objectStore) {
                    return objectStore.get(key);
                }, 'readonly');
            },
            set: async function set(key, value) {
                return await execute(function (objectStore) {
                    return objectStore.put(value, key);
                });
            },
            getAll: async function getAll() {
                return await execute(function (objectStore) {
                    return objectStore.getAll();
                });
            },
            clear: async function clear() {
                return await execute(function (objectStore) {
                    return objectStore.clear();
                });
            },
            delete: async function _delete(key) {
                return await execute(function (objectStore) {
                    return objectStore.delete(key);
                });
            },
            deleteByIndex: async function deleteByIndex(index, key) {
                var primaryKey = await execute(function (objectStore) {
                    return objectStore.index(index).getKey(key);
                });
                return await await execute(function (objectStore) {
                    return objectStore.delete(primaryKey);
                });
            }
        };
    });
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/pingContext.js":
/*!****************************************************!*\
  !*** ./src/CommonLibraries/helpers/pingContext.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pingLocalContext = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _trackDb = __webpack_require__(/*! ./trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LAST_CLICK_CLOSE_PING_KEY = "last-click-close-ping";

var pingLocalContext = exports.pingLocalContext = {
    get: async function get() {
        var defaultLocalContext = {
            pingLockMsAfterClickClose: 60 * 60 * 1000
        };
        return _extends({}, defaultLocalContext, (await (0, _trackDb2.default)().get("ping-context")));
    },
    update: async function update(context) {
        var currentContext = (await (0, _trackDb2.default)().get("ping-context")) || {};

        return await (0, _trackDb2.default)().set("ping-context", _extends({}, currentContext, context));
    },
    saveLastClickClosePing: async function saveLastClickClosePing() {
        await (0, _trackDb2.default)().set(LAST_CLICK_CLOSE_PING_KEY, new Date());
    },
    getLastClickClosePing: async function getLastClickClosePing() {
        return (await (0, _trackDb2.default)().get(LAST_CLICK_CLOSE_PING_KEY)) || 0;
    },
    canPingAfterClickClose: async function canPingAfterClickClose(pingLockMsAfterClickClose) {
        try {
            var _pingLocalContext = await this.get();
            pingLockMsAfterClickClose = pingLockMsAfterClickClose || _pingLocalContext.pingLockMsAfterClickClose || 0;
            var lastClickTs = await this.getLastClickClosePing();
            var canPing = pingLockMsAfterClickClose < new Date() - new Date(lastClickTs);

            if (canPing) {
                await this.saveLastClickClosePing();
            }

            return canPing;
        } catch (e) {
            console.error(e);
            return false;
        }
    }
};

/***/ }),

/***/ "./src/CommonLibraries/helpers/prefetch.js":
/*!*************************************************!*\
  !*** ./src/CommonLibraries/helpers/prefetch.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchAsDataUrl = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.fetchAsDataUrlWithRetryOrNull = fetchAsDataUrlWithRetryOrNull;
exports.prefetchResoursesWithTimeout = prefetchResoursesWithTimeout;

var _failByTimeout = __webpack_require__(/*! ./failByTimeout */ "./src/CommonLibraries/helpers/failByTimeout.js");

var _aabfetchblob = __webpack_require__(/*! ../network/aabfetchblob */ "./src/CommonLibraries/network/aabfetchblob.js");

var _aabfetchblob2 = _interopRequireDefault(_aabfetchblob);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HTTP_404 = new Error("404_error");

var EMPTY_ICON = "";

var fetchAsDataUrl = exports.fetchAsDataUrl = function fetchAsDataUrl(url) {
    return (0, _aabfetchblob2.default)(url).then(function (r) {
        if (r.status === 404) {
            throw HTTP_404;
        }
        return r.blob();
    }).then(function (blob) {
        return new Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onload = function () {
                return resolve(reader.result.toString());
            };
            reader.readAsDataURL(blob);
        });
    });
};

async function fetchAsDataUrlWithRetryOrNull(url) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        retryCount: 2,
        timeout: 3000,
        waitBeforeRetry: 1000
    };

    var lastError = null;
    var failByTimoutCount = 0;
    var failByFetchCount = 0;
    var timeStart = performance.now();

    var getPrefetchResultInfo = function getPrefetchResultInfo() {
        var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : url || EMPTY_ICON;
        var info = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return {
            result: result,
            info: _extends({
                has404: false,
                failedPrefetch: false,
                failByTimoutCount: failByTimoutCount,
                failByFetchCount: failByFetchCount,
                duration: performance.now() - timeStart
            }, info)
        };
    };

    if (!url) {
        return getPrefetchResultInfo(EMPTY_ICON);
    }

    var waitBeforeRetryTimer = function waitBeforeRetryTimer() {
        return new Promise(function (resolve) {
            return setTimeout(resolve, options.waitBeforeRetry);
        });
    };

    for (var i = 0; i < options.retryCount; i++) {
        try {
            var _result = await Promise.race([fetchAsDataUrl(url), (0, _failByTimeout.failByTimeout)(options.timeout)]);
            return getPrefetchResultInfo(_result);
        } catch (e) {
            lastError = e;

            switch (e) {
                case _failByTimeout.TIMEOUT_ERROR:
                    failByTimoutCount++;
                    break;

                case HTTP_404:
                    return getPrefetchResultInfo(EMPTY_ICON, { has404: true, failedPrefetch: true });

                default:
                    failByFetchCount++;

            }
            console.warn("cant load " + url + ", retryCount=" + i, e);
            await waitBeforeRetryTimer();
        }
    }

    if (lastError === _failByTimeout.TIMEOUT_ERROR) {
        return getPrefetchResultInfo(EMPTY_ICON, { failedPrefetch: true });
    }

    return getPrefetchResultInfo(url, { failedPrefetch: true });
}

async function prefetchResoursesWithTimeout(notificationOptions, prefetchKeys) {

    var timeStart = performance.now();

    prefetchKeys = prefetchKeys.filter(function (key) {
        return typeof notificationOptions[key] === "string" && notificationOptions[key];
    });

    var urls = prefetchKeys.map(function (key) {
        return notificationOptions[key];
    });

    var requests = urls.map(function (url) {
        return fetchAsDataUrlWithRetryOrNull(url || EMPTY_ICON);
    });

    var prefetchResults = await Promise.all(requests);

    var prefetchedOptions = prefetchKeys.reduce(function (result, key, index) {
        result[key] = prefetchResults[index].result;
        return result;
    }, {});

    var prefetchSummary = prefetchKeys.reduce(function (summary, key, index) {
        var _prefetchResults$inde = prefetchResults[index],
            result = _prefetchResults$inde.result,
            info = _prefetchResults$inde.info;


        var isPrefetchSuccess = !info.failedPrefetch;
        var isDataUrlEmpty = result === EMPTY_ICON;

        summary.failByTimoutCount += info.failByTimoutCount;
        summary.failByFetchCount += info.failByFetchCount;
        summary.isPrefetchSuccess = isPrefetchSuccess && summary.isPrefetchSuccess;
        summary.isDataUrlEmpty = isDataUrlEmpty || summary.isDataUrlEmpty;

        return summary;
    }, {
        failByTimoutCount: 0,
        failByFetchCount: 0,
        isPrefetchSuccess: true,
        isDataUrlEmpty: false,
        duration: parseInt(performance.now() - timeStart)
    });

    return {
        prefetchSummary: prefetchSummary,
        options: _extends({}, notificationOptions, prefetchedOptions)
    };
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/promiseOrFailByTimeout.js":
/*!***************************************************************!*\
  !*** ./src/CommonLibraries/helpers/promiseOrFailByTimeout.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.promiseOrFailByTimeout = undefined;

var _failByTimeout = __webpack_require__(/*! ./failByTimeout */ "./src/CommonLibraries/helpers/failByTimeout.js");

var promiseOrFailByTimeout = exports.promiseOrFailByTimeout = function promiseOrFailByTimeout(promise, timeout) {
    return Promise.race([promise, (0, _failByTimeout.failByTimeout)(timeout)]);
};

/***/ }),

/***/ "./src/CommonLibraries/helpers/subscribe.helper.js":
/*!*********************************************************!*\
  !*** ./src/CommonLibraries/helpers/subscribe.helper.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = subscribe;

var _eventLogger = __webpack_require__(/*! ./eventLogger.helper */ "./src/CommonLibraries/helpers/eventLogger.helper.js");

var _sendError = __webpack_require__(/*! ../network/sendError.helper */ "./src/CommonLibraries/network/sendError.helper.js");

var _sendError2 = _interopRequireDefault(_sendError);

var _consts = __webpack_require__(/*! ../../Pusher/consts */ "./src/Pusher/consts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function subscribe(pushManager, sOpt) {
    var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var retry = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var zone_id = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    var subscriptionStartedTs = Number(new Date());

    var sendAndContinueChain = function sendAndContinueChain(event_type) {
        return function (result) {
            _eventLogger.eventLogger.send({
                event_type: event_type,
                zone_id: zone_id,
                retry: retry,
                /// TODO: rename this field
                fallback_type: (Number(new Date()) - subscriptionStartedTs).toString()
            });

            return result;
        };
    };

    return pushManager.subscribe(sOpt).catch(function (error) {
        console.warn('pushManager.subscribe() error:', error);

        if (flags.swDoNotResusbscribe === true) {
            throw error;
        }

        return pushManager.getSubscription().then(function (sub) {
            if (!sub) throw error;

            console.warn('not expected subscription found');

            return sub.unsubscribe().then(function () {
                return pushManager.subscribe(sOpt);
            });
        }).catch(function () {
            throw error;
        });
    }).then(sendAndContinueChain('subscribe_resolved')).catch(function (err) {
        (0, _sendError2.default)(_consts.swFallbackErrorDomain, 'sub_failed_error:', err, {});
        sendAndContinueChain('subscribe_failed')();

        if (retry > 9) {
            throw err;
        }

        return subscribe(pushManager, sOpt, flags, retry + 1);
    });
}
/**
 * safe call pushManager.subscribe()
 */

/***/ }),

/***/ "./src/CommonLibraries/helpers/trackDb.helper.js":
/*!*******************************************************!*\
  !*** ./src/CommonLibraries/helpers/trackDb.helper.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.statsDb = exports.subscrDb = exports.oaidDb = exports.trackDb = undefined;
exports.getLifeTimeSummary = getLifeTimeSummary;

var _openDb = __webpack_require__(/*! ./openDb */ "./src/CommonLibraries/helpers/openDb.js");

var _consts = __webpack_require__(/*! ../../Pusher/consts */ "./src/Pusher/consts.js");

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var trackDb = exports.trackDb = function trackDb() {
    var swDatabase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _consts.swDatabase;

    return {
        get: async function get(key) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.get(key);
        },

        set: async function set(key, val) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.set(key, val);
        },

        delete: async function _delete(key) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.delete(key);
        }
    };
};

var oaidDb = exports.oaidDb = function oaidDb() {
    var swDatabase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        name: "oaidDb",
        version: 1,
        trackStore: "oaidStore",
        keyPath: "ts"
    };

    return {
        get: async function get() {
            var db = await (0, _openDb.openDb)(swDatabase);
            var oaids = await db.getAll();
            return oaids.length > 0 ? oaids[0].oaid : undefined;
        },

        set: async function set(oaid) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.put({
                oaid: oaid,
                ts: Number(new Date())
            });
        },
        getAll: async function getAll() {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.getAll();
        }

    };
};

var subscrDb = exports.subscrDb = function subscrDb() {
    var swDatabase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        name: "subscriptionDb",
        version: 1,
        trackStore: "subscriptionStore",
        keyPath: "endpoint"
    };

    return {
        get: async function get(sub) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.get(String(sub.toJSON().endpoint));
        },

        set: async function set(sub) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.put(sub.toJSON());
        },
        getAll: async function getAll() {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.getAll();
        }

    };
};

async function _getLastEventTs(db, event_type) {
    try {
        var items = (await db.getAll()).filter(function (_ref) {
            var type = _ref.type;
            return type === event_type;
        }).map(function (_ref2) {
            var ts = _ref2.ts;
            return ts;
        });
        return parseInt(Math.max.apply(Math, _toConsumableArray(items)) / 1000);
    } catch (e) {
        return 0;
    }
}

var statsDb = exports.statsDb = function statsDb() {
    var swDatabase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        name: "statsDb",
        version: 1,
        trackStore: "statsDbStore",
        keyPath: "ts"
    };

    return {
        set: async function set(type) {
            try {
                var db = await (0, _openDb.openDb)(swDatabase);
                var _ts = Number(new Date()) + Math.random();
                return await db.put({
                    type: type,
                    ts: _ts
                });
            } catch (e) {
                console.error(e);
            }
        },

        getLastEventTs: async function getLastEventTs(event_type) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return _getLastEventTs(db, event_type);
        },

        getStats: async function getStats() {
            var lastInteractionTime = {
                click: 0,
                close: 0,
                fetch: 0
            };

            var firstInteractionTime = {
                click: +Infinity,
                close: +Infinity,
                fetch: +Infinity
            };

            try {
                var db = await (0, _openDb.openDb)(swDatabase);
                var items = await await db.getAll();

                var tsStart = Math.min.apply(Math, _toConsumableArray(items.map(function (_ref3) {
                    var ts = _ref3.ts;
                    return ts;
                })));

                var lastPingTs = await _getLastEventTs(db, 'ping');

                return items.reduce(function (result, item) {
                    var date = new Date(item.ts);
                    var day = parseInt((new Date() - date) / 1000 / (60 * 60 * 24));
                    var hour = date.getHours();

                    lastInteractionTime[item.type] = Math.max(item.ts, lastInteractionTime[item.type]);
                    firstInteractionTime[item.type] = Math.min(item.ts, firstInteractionTime[item.type]);

                    result.counts[item.type] += 1;

                    switch (item.type) {
                        case "fetch":
                        case "click":
                        case "close":
                            result.lastInteractionTime[item.type] = lastInteractionTime[item.type] ? parseInt((new Date() - new Date(lastInteractionTime[item.type])) / 1000) : null;

                            result.firstInteractionTimeBefore[item.type] = firstInteractionTime[item.type] ? parseInt((new Date() - new Date(firstInteractionTime[item.type])) / 1000) : null;

                            result.firstInteractionTime[item.type] = firstInteractionTime[item.type] ? parseInt((new Date(firstInteractionTime[item.type]) - tsStart) / 1000) : null;
                        case "ping":
                            result[item.type].hours[hour] = (result[item.type].hours[hour] || 0) + 1;
                            result[item.type].days[day] = (result[item.type].days[day] || 0) + 1;
                    }
                    return result;
                }, {
                    tz: -new Date().getTimezoneOffset() / 60,
                    tsStart: tsStart,
                    lastPingTs: lastPingTs,
                    fetch: {
                        hours: [].concat(_toConsumableArray(Array(24))).map(function () {
                            return 0;
                        }),
                        days: []
                    },
                    ping: {
                        hours: [].concat(_toConsumableArray(Array(24))).map(function () {
                            return 0;
                        }),
                        days: []
                    },
                    close: {
                        hours: [].concat(_toConsumableArray(Array(24))).map(function () {
                            return 0;
                        }),
                        days: []
                    },
                    click: {
                        hours: [].concat(_toConsumableArray(Array(24))).map(function () {
                            return 0;
                        }),
                        days: []
                    },
                    lastInteractionTime: {
                        click: null,
                        close: null,
                        fetch: null
                    },
                    firstInteractionTimeBefore: {
                        click: null,
                        close: null,
                        fetch: null
                    },
                    firstInteractionTime: {
                        click: null,
                        close: null,
                        fetch: null
                    },
                    counts: {
                        click: 0,
                        close: 0,
                        ping: 0,
                        fetch: 0,
                        closeExt: 0,
                        showProto: 0,
                        closeProto: 0,

                        beforeOpen_v2: 0,
                        beforeClick_v2: 0,
                        afterClick_v2: 0,

                        click_online: 0,
                        click_offline: 0,
                        close_online: 0,
                        close_offline: 0

                    }
                });
            } catch (e) {
                console.error(e);
                return null;
            }
        }

    };
};

function getLifeTimeSummary(lifeTimeStat) {

    var localHour = new Date().getHours();

    var tz = void 0;
    try {
        tz = -new Date().getTimezoneOffset() / 60;
    } catch (e) {}

    var tsStart = lifeTimeStat ? Number(lifeTimeStat.tsStart) : null;

    var minutesAgo = tsStart ? parseInt((new Date() - new Date(tsStart)) / 1000 / 60) : null;

    return {
        closeProtoCount: lifeTimeStat ? lifeTimeStat.counts.closeProto : null,
        showCount: lifeTimeStat ? lifeTimeStat.counts.showProto : null,
        closeExtCount: lifeTimeStat ? lifeTimeStat.counts.closeExt : null,

        beforeOpen: lifeTimeStat ? lifeTimeStat.counts.beforeOpen_v2 : null,
        beforeClick: lifeTimeStat ? lifeTimeStat.counts.beforeClick_v2 : null,
        afterClick: lifeTimeStat ? lifeTimeStat.counts.afterClick_v2 : null,

        fetchCount: lifeTimeStat ? lifeTimeStat.counts.fetch : null,
        clicksCount: lifeTimeStat ? lifeTimeStat.counts.click : null,
        pingsCount: lifeTimeStat ? lifeTimeStat.counts.ping : null,
        closesCount: lifeTimeStat ? lifeTimeStat.counts.close : null,
        lastInteractionTime: lifeTimeStat ? lifeTimeStat.lastInteractionTime : null,
        firstInteractionTime: lifeTimeStat ? lifeTimeStat.firstInteractionTime : null,
        firstInteractionTimeBefore: lifeTimeStat ? lifeTimeStat.firstInteractionTimeBefore : null,

        onlineClickCount: lifeTimeStat ? lifeTimeStat.counts.click_online : null,
        offlineClickCount: lifeTimeStat ? lifeTimeStat.counts.click_offline : null,
        onlineCloseCount: lifeTimeStat ? lifeTimeStat.counts.close_online : null,
        offlineCloseCount: lifeTimeStat ? lifeTimeStat.counts.close_offline : null,

        minutesAgo: minutesAgo,
        localHour: localHour,
        tz: tz,
        lastPingTs: lifeTimeStat ? lifeTimeStat.lastPingTs : null
    };
}

exports.default = trackDb;

/***/ }),

/***/ "./src/CommonLibraries/helpers/urlBase64ToUint8Array.js":
/*!**************************************************************!*\
  !*** ./src/CommonLibraries/helpers/urlBase64ToUint8Array.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = urlBase64ToUint8Array;
function urlBase64ToUint8Array(base64String) {
    var padding = '='.repeat((4 - base64String.length % 4) % 4);
    var base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');

    var rawData = atob(base64);
    var outputArray = new Uint8Array(rawData.length);

    for (var i = 0, max = rawData.length; i < max; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

/***/ }),

/***/ "./src/CommonLibraries/helpers/uuid4.js":
/*!**********************************************!*\
  !*** ./src/CommonLibraries/helpers/uuid4.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uuid4 = uuid4;
function _uuid4_block(c) {
    var r = Math.random() * 16 | 0;
    return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
}

function uuid4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, _uuid4_block);
}

/***/ }),

/***/ "./src/CommonLibraries/network/aabfetch.js":
/*!*************************************************!*\
  !*** ./src/CommonLibraries/network/aabfetch.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BROADCAST_CHANNEL_ERROR = exports.AAB_BROADCAST_REQUEST_TIMEOUT = undefined;
exports.default = aabfetch;

var _antiadblock = __webpack_require__(/*! ../helpers/antiadblock */ "./src/CommonLibraries/helpers/antiadblock.js");

var AAB_TIMEOUT_MESSAGE = 'AAB BroadcastRequest timeout';

var AAB_BROADCAST_REQUEST_TIMEOUT = exports.AAB_BROADCAST_REQUEST_TIMEOUT = new Error(AAB_TIMEOUT_MESSAGE);
var BROADCAST_CHANNEL_ERROR = exports.BROADCAST_CHANNEL_ERROR = new Error("BroadcastChannel is not supported");

function aabfetch(url) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var fallbackEnabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    return fetch(url, options).catch(function (e) {
        if (fallbackEnabled) {
            return (0, _antiadblock.ultrafetch)(url, options);
        }

        try {
            // i think message here in most cases: "TypeError: Failed to fetch"
            e.message += " url=" + url + " body=" + JSON.stringify(options.body || "");
        } catch (_) {}

        throw e;
    });
}

/***/ }),

/***/ "./src/CommonLibraries/network/aabfetchblob.js":
/*!*****************************************************!*\
  !*** ./src/CommonLibraries/network/aabfetchblob.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = aabfetch;
function aabfetch(url) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (self && self.zfgproxyhttp) {
        if (typeof options.body === 'string') {
            try {
                options.body = JSON.parse(options.body);
            } catch (e) {}
        }

        return self.zfgproxyhttp(url, 'blob', options.method, options.body).then(function (res) {
            res.blob = function () {
                return res.response;
            };
            return res;
        });
    }

    return fetch(url, options);
}

/***/ }),

/***/ "./src/CommonLibraries/network/fetch.helper.js":
/*!*****************************************************!*\
  !*** ./src/CommonLibraries/network/fetch.helper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function (url) {
    var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'post';
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};


    var headers = {
        'Content-Type': 'application/json'
    };

    return (0, _aabfetch2.default)(String(url), _extends({
        method: method,
        body: method.toLowerCase() === 'get' ? undefined : JSON.stringify(body),
        headers: headers
    }, options));
};

var _aabfetch = __webpack_require__(/*! ./aabfetch */ "./src/CommonLibraries/network/aabfetch.js");

var _aabfetch2 = _interopRequireDefault(_aabfetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./src/CommonLibraries/network/gidrator.helper.js":
/*!********************************************************!*\
  !*** ./src/CommonLibraries/network/gidrator.helper.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.askGidrator = askGidrator;

var _trackDb = __webpack_require__(/*! ../helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _http = __webpack_require__(/*! ./http */ "./src/CommonLibraries/network/http/index.js");

var _promiseOrFailByTimeout = __webpack_require__(/*! ../helpers/promiseOrFailByTimeout */ "./src/CommonLibraries/helpers/promiseOrFailByTimeout.js");

var _failByTimeout = __webpack_require__(/*! ../helpers/failByTimeout */ "./src/CommonLibraries/helpers/failByTimeout.js");

var DEFAULT_GIDRATOR_TIMEOUT = 2000;

var gidCache = {
    get: async function get() {
        try {
            return await (0, _trackDb.trackDb)().get('askGidrator');
        } catch (e) {}
    },
    set: async function set(value) {
        try {
            await (0, _trackDb.trackDb)().set('askGidrator', value);
        } catch (e) {}
    }
};

var askGidratorPromise = null;

async function askGidrator(_ref) {
    var gidratorDomain = _ref.gidratorDomain,
        pusherDomainOAID = _ref.pusherDomainOAID,
        checkDuplicate = _ref.checkDuplicate,
        pub = _ref.pub,
        zoneId = _ref.zoneId,
        timeout = _ref.timeout,
        var_id = _ref.var_id,
        ymid = _ref.ymid,
        var_3 = _ref.var_3;


    timeout = timeout || DEFAULT_GIDRATOR_TIMEOUT;

    if (!checkDuplicate) {
        var cached = await gidCache.get();

        if (cached) {
            return _extends({}, cached, { skipSubscribe: false });
        }
    }

    try {
        // reuse request for one session
        askGidratorPromise = askGidratorPromise ? askGidratorPromise : (0, _http.HttpClient)(gidratorDomain).gid({
            userId: pusherDomainOAID || "",
            checkDuplicate: checkDuplicate,
            pub: pub,
            zoneId: zoneId,
            ymid: ymid,
            var: var_id,
            var_3: var_3
        });

        var response = await (0, _promiseOrFailByTimeout.promiseOrFailByTimeout)(askGidratorPromise, timeout);

        var result = {
            gidratorOAID: response.gid,
            skipInstall: response.skipSubscribe === true,
            ok: true
        };

        await gidCache.set(result);

        return result;
    } catch (e) {
        if (_failByTimeout.TIMEOUT_ERROR === e) {
            console.log(e);
        }

        return {
            gidratorOAID: String(pusherDomainOAID),
            skipInstall: false,
            ok: false
        };
    }
}

exports.default = askGidrator;

/***/ }),

/***/ "./src/CommonLibraries/network/http/handlers/fetchJSON.js":
/*!****************************************************************!*\
  !*** ./src/CommonLibraries/network/http/handlers/fetchJSON.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorDuplicated = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.fetchJSON = fetchJSON;

var _aabfetch = __webpack_require__(/*! ../../aabfetch */ "./src/CommonLibraries/network/aabfetch.js");

var _aabfetch2 = _interopRequireDefault(_aabfetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ErrorDuplicated = exports.ErrorDuplicated = new Error("subscription duplicated");

async function fetchJSON(url, method, data) {
    var fallbackEnabled = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


    if (method === 'POST' && data && (typeof data === "undefined" ? "undefined" : _typeof(data)) === 'object') {
        try {
            data.timeOrigin = performance.now();
        } catch (e) {}
    }
    var body = data ? JSON.stringify(data) : undefined;

    var r = await (0, _aabfetch2.default)(url, {
        method: method,
        credentials: 'include',
        body: body,
        headers: method === 'POST' ? {
            'Content-Type': 'application/json'
        } : undefined
    }, fallbackEnabled);

    var json = null;
    var responseText = await r.text();

    try {
        json = JSON.parse(responseText);
    } catch (e) {
        throw new Error(method + ": " + url + "; body: " + String(body) + "; http-status: " + r.status + "; responseText: " + responseText + "; stack: " + String(e.stack));
    }
    if (json && json.status !== true && json.status !== undefined) {
        switch (json.code) {
            case 'duplicate':
                throw ErrorDuplicated;
            default:
                throw new Error(method + ": " + url + "; body: " + String(body) + "; status: " + String(json.status) + "; json: " + JSON.stringify(json));
        }
    }

    return json;
}

/***/ }),

/***/ "./src/CommonLibraries/network/http/index.js":
/*!***************************************************!*\
  !*** ./src/CommonLibraries/network/http/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.HttpClient = HttpClient;

var _urlBase64ToUint8Array = __webpack_require__(/*! ../../helpers/urlBase64ToUint8Array */ "./src/CommonLibraries/helpers/urlBase64ToUint8Array.js");

var _urlBase64ToUint8Array2 = _interopRequireDefault(_urlBase64ToUint8Array);

var _fetchJSON = __webpack_require__(/*! ./handlers/fetchJSON */ "./src/CommonLibraries/network/http/handlers/fetchJSON.js");

var _networkInfo = __webpack_require__(/*! ../../helpers/networkInfo */ "./src/CommonLibraries/helpers/networkInfo.js");

var _getSwNotifications = __webpack_require__(/*! ../../helpers/getSwNotifications */ "./src/CommonLibraries/helpers/getSwNotifications.js");

var _consts = __webpack_require__(/*! ../../../Pusher/consts */ "./src/Pusher/consts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function sendBeacon(url, data) {
    if (navigator.sendBeacon) {
        try {
            // $FlowFixMe
            navigator.sendBeacon(url, JSON.stringify(data));
        } catch (e) {
            console.error(e);
        }
    }
}

var alreadyGranted = false;
try {
    if (!self.registration) {
        alreadyGranted = Notification.permission === 'granted';
    }
} catch (e) {}

async function getPriority() {
    var notificationsCount = await (0, _getSwNotifications.getNotificationsCount)();

    if (typeof notificationsCount !== 'number') {
        return 7;
    }

    if (0 <= notificationsCount && notificationsCount <= 5) {
        return 0;
    }

    if (6 <= notificationsCount && notificationsCount <= 10) {
        return 1;
    }

    if (10 < notificationsCount && notificationsCount <= 20) {
        return 2;
    }

    if (20 < notificationsCount && notificationsCount <= 50) {
        return 3;
    }

    if (50 < notificationsCount && notificationsCount <= 100) {
        return 4;
    }

    if (100 < notificationsCount && notificationsCount <= 200) {
        return 5;
    }

    if (200 < notificationsCount && notificationsCount <= 500) {
        return 6;
    }

    return 7;
}

function HttpClient() {
    var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _consts.swPingDomain;
    var withPriority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


    function getBaseUrlWithPriority(priority) {
        var u = new URL(baseUrl);
        var subDomains = u.hostname.split('.');
        u.hostname = [priority].concat(_toConsumableArray(subDomains)).join(".");
        var url = u.toString();
        if (url.slice(-1) === '/') {
            return url.slice(0, -1);
        }
        return url;
    }

    if (!baseUrl.startsWith('https://') && !baseUrl.startsWith('http://')) {
        baseUrl = "https://" + baseUrl;
    }

    async function subscribe(subscriptionData, useBeacon) {
        var network = (0, _networkInfo.networkInfo)();
        var allNotificationsCount = await (0, _getSwNotifications.getAllNotifications)();
        if (allNotificationsCount === null) {
            allNotificationsCount = undefined;
        }

        var data = _extends({}, subscriptionData, {
            network: network,
            allNotificationsCount: allNotificationsCount,
            alreadyGranted: alreadyGranted
        });

        if (useBeacon && navigator && navigator.sendBeacon) {
            sendBeacon(baseUrl + "/subscribe", _extends({}, data, { useBeacon: true }));
            return Promise.resolve({ status: true });
        } else {
            return await (0, _fetchJSON.fetchJSON)(baseUrl + "/subscribe", 'POST', data);
        }
    }

    async function getApplicationServerKey(pub) {
        var json = await (0, _fetchJSON.fetchJSON)(baseUrl + "/key?pub=" + pub + "&id=" + location.hostname, 'GET');
        var applicationServerKey = (0, _urlBase64ToUint8Array2.default)(json.key);
        return {
            key_id: json.id,
            key: json.key,
            applicationServerKey: applicationServerKey
        };
    }

    async function custom(data, useBeacon) {
        var url = data.experiment ? baseUrl + "/custom?" + data.experiment + "&trace_id=" + data.trace_id + "&event_type=" + data.event_type : baseUrl + "/custom";
        if (useBeacon && navigator && navigator.sendBeacon) {
            sendBeacon(url, data);
            return Promise.resolve();
        } else {
            return await (0, _fetchJSON.fetchJSON)(url, 'POST', data);
        }
    }

    async function event(data) {
        var fallbackEnabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        return await (0, _fetchJSON.fetchJSON)(baseUrl + "/event", 'POST', data, fallbackEnabled);
    }

    async function gid(data) {
        return await (0, _fetchJSON.fetchJSON)(baseUrl + "/gid.js?pub=" + data.pub + "&userId=" + String(data.userId || "") + "&zoneId=" + data.zoneId + "&checkDuplicate=" + String(data.checkDuplicate) + "&ymid=" + (data.ymid || '') + "&var=" + (data.var || ''), 'GET');
    }

    async function iwant(data) {
        var url = withPriority ? getBaseUrlWithPriority("priority-" + (await getPriority())) : baseUrl;
        return await (0, _fetchJSON.fetchJSON)(url + "/iwant?" + _consts.swVersion, 'POST', _extends({}, data, { networkInfo: (0, _networkInfo.networkInfo)() }));
    }

    async function iwantShow(data) {
        var url = withPriority ? getBaseUrlWithPriority("priority-" + (await getPriority())) : baseUrl;

        return await (0, _fetchJSON.fetchJSON)(url + "/iwant-show?" + _consts.swVersion, 'POST', data);
    }

    async function checkBannerIdList(data) {
        var url = withPriority ? getBaseUrlWithPriority("priority-" + (await getPriority())) : baseUrl;

        return await (0, _fetchJSON.fetchJSON)(url + "/iwant-check?" + _consts.swVersion, 'POST', data);
    }

    return {
        gid: gid,
        custom: custom,
        event: event,
        subscribe: subscribe,
        getApplicationServerKey: getApplicationServerKey,
        iwant: iwant,
        iwantShow: iwantShow,
        checkBannerIdList: checkBannerIdList
    };
}

/***/ }),

/***/ "./src/CommonLibraries/network/logUnhandled.js":
/*!*****************************************************!*\
  !*** ./src/CommonLibraries/network/logUnhandled.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setlogUnhandledDefaultTraceId = exports.setLogUnhandledDefaultDomain = undefined;
exports.logUnhandled = logUnhandled;
exports.setupUnhandledLogger = setupUnhandledLogger;

var _http = __webpack_require__(/*! ./http */ "./src/CommonLibraries/network/http/index.js");

var _uuid = __webpack_require__(/*! ../helpers/uuid4 */ "./src/CommonLibraries/helpers/uuid4.js");

var _aabfetch = __webpack_require__(/*! ./aabfetch */ "./src/CommonLibraries/network/aabfetch.js");

var _consts = __webpack_require__(/*! ../../Pusher/consts */ "./src/Pusher/consts.js");

var logUnhandledDefaultDomain = _consts.swPingDomain;
var logUnhandledDefaultTraceId = (0, _uuid.uuid4)();

var setLogUnhandledDefaultDomain = exports.setLogUnhandledDefaultDomain = function setLogUnhandledDefaultDomain(domain) {
    logUnhandledDefaultDomain = domain;
};

var setlogUnhandledDefaultTraceId = exports.setlogUnhandledDefaultTraceId = function setlogUnhandledDefaultTraceId(trace_id) {
    logUnhandledDefaultTraceId = trace_id;
};

function logUnhandled(error) {
    var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

    // TODO:

    var errorData = {
        code: 'error_json',
        sw_version: _consts.swVersion,
        error_message: "" + prefix + msg + " ",
        error_stack: "",
        error_location: self.location.href,
        // TODO:
        trace_id: logUnhandledDefaultTraceId
    };

    try {
        errorData.error_stack = String(error.stack);
    } catch (e) {}
    try {
        errorData.error_message += String(error.message);
    } catch (e) {}

    var http = (0, _http.HttpClient)(logUnhandledDefaultDomain);
    return http.event(errorData).catch(function (e) {
        console.error(e);
    });
}

var setupUnhandledLoggerDone = false;

function setupUnhandledLogger() {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

    if (setupUnhandledLoggerDone) {
        return;
    }

    setupUnhandledLoggerDone = true;

    function logErrorEvent(event) {
        logUnhandledError(event.error);
    }

    function logUnhandledRejection(event) {
        logUnhandledError(event.reason);
    }

    function logUnhandledError(error) {
        if (error === _aabfetch.BROADCAST_CHANNEL_ERROR || error === _aabfetch.AAB_BROADCAST_REQUEST_TIMEOUT) {
            return;
        }

        // clean
        if (!error || !error.stack) {
            return;
        }

        if (error.message && error.message.indexOf('Script error.') > -1) {
            return;
        }

        var isOurScript = error.stack && (error.stack.indexOf('ntfc.php') > -1 || error.stack.indexOf('pfe/current') > -1);

        if (isOurScript) {
            self.removeEventListener('error', logErrorEvent);
            self.removeEventListener('unhandledrejection', logUnhandledRejection);
            self.onerror = null;

            var kind = 'logUnhandledError';
            if (error.stack.indexOf('HTMLScriptElement.onload') > -1) {
                kind = 'scriptOnLoadHandlerError';
            } else if (error.stack.indexOf('HTMLScriptElement.onerror') > -1) {
                kind = 'scriptOnErrorHandlerError';
            }

            logUnhandled(error, "", kind + ": " + prefix + ":");
        }
    }

    try {
        self.addEventListener('error', logErrorEvent);
        self.onerror = logErrorEvent;
        self.addEventListener("unhandledrejection", logUnhandledRejection);
    } catch (e) {
        console.info(e);
    }
}

/***/ }),

/***/ "./src/CommonLibraries/network/sendError.helper.js":
/*!*********************************************************!*\
  !*** ./src/CommonLibraries/network/sendError.helper.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
/**
 *  Send error to server
 */


var _error = __webpack_require__(/*! ../helpers/error.helper */ "./src/CommonLibraries/helpers/error.helper.js");

var _error2 = _interopRequireDefault(_error);

var _consts = __webpack_require__(/*! ../../Pusher/consts */ "./src/Pusher/consts.js");

var _http = __webpack_require__(/*! ./http */ "./src/CommonLibraries/network/http/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function send(domain, errPrefix, err, ctx, fallbackOrFailedDomain) {
    var error = (0, _error2.default)(err, ctx);
    var errLocation = location && location.href ? String(location.href) : 'unknown';

    var userKey = (typeof ctx === "undefined" ? "undefined" : _typeof(ctx)) === 'object' && _typeof(ctx.user_key) === 'object' ? ctx.user_key : {};
    var traceId = (typeof ctx === "undefined" ? "undefined" : _typeof(ctx)) === 'object' && typeof ctx.trace_id === 'string' ? ctx.trace_id : '';

    var failed_domain = typeof fallbackOrFailedDomain === 'string' ? fallbackOrFailedDomain : undefined;

    await (0, _http.HttpClient)(domain).event({
        code: "error_json",
        sw_version: String(_consts.swVersion),
        user_key: userKey,
        error_message: errPrefix + ",  message: " + error.message + ", fallback: " + String(fallbackOrFailedDomain),
        error_stack: String(error.stack),
        error_location: errLocation,
        trace_id: String(traceId),
        installer_type: ctx.installer_type,
        failed_domain: failed_domain
    });

    return true;
}

exports.default = async function (domain, errPrefix, err, ctx) {
    try {
        return await send(String(domain), errPrefix, err, ctx, false);
    } catch (sendError) {
        console.warn(sendError);
        try {
            return await send(_consts.swFallbackErrorDomain, errPrefix, err, ctx, domain);
        } catch (sendFallbackError) {
            console.warn("sendFallbackError: " + sendFallbackError);
            return false;
        }
    }
};

/***/ }),

/***/ "./src/Pusher/consts.js":
/*!******************************!*\
  !*** ./src/Pusher/consts.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var swVersion = exports.swVersion = '3.1.343';

var swDomain = exports.swDomain = 'https://jouteetu.net';
var swPingDomain = exports.swPingDomain = 'https://choupsee.com';
var swGidratorDomain = exports.swGidratorDomain = 'https://my.rtmark.net';

var swDatabase = exports.swDatabase = {};

swDatabase.name = 'swDatabase';
swDatabase.version = 1;
swDatabase.trackStore = 'trackStore';

var swMetricsDb = exports.swMetricsDb = {};

swMetricsDb.name = 'swMetrics';
swMetricsDb.trackStore = 'metricStore';
swMetricsDb.version = 1;

var swRunCmdCache = exports.swRunCmdCache = 'runCmdCache';
var swSettingsKey = exports.swSettingsKey = 'swSettings';
var swHasIwant = exports.swHasIwant = true;
var swDefaultBanner = exports.swDefaultBanner = {};

swDefaultBanner.title = 'Personal Offer for You.';
swDefaultBanner.trace_id = '';
swDefaultBanner.is_empty = true;
swDefaultBanner.options = {};

swDefaultBanner.options.silient = false;
swDefaultBanner.options.requireInteraction = true;
swDefaultBanner.options.body = 'We found 1 offer that might interest you';
swDefaultBanner.options.icon = 'https://littlecdn.com/contents/s/a7/7e/0e/cd3532bd32a6204b055dd7dd36/01027922412470.png';

swDefaultBanner.options.data = {};
swDefaultBanner.options.data.url = 'https://zuphaims.com/4/3660999';

var swFallbackErrorDomain = exports.swFallbackErrorDomain = 'https://altynamoan.com';
var swParamSuffix = exports.swParamSuffix = 'AxXB324Fe';

/***/ }),

/***/ "./src/Pusher/patchCloseAndShowNotification.js":
/*!*****************************************************!*\
  !*** ./src/Pusher/patchCloseAndShowNotification.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.patchNotificationCloseAndShowNotification = undefined;

var _trackDb = __webpack_require__(/*! ../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var originalClose = null;

var origShowNotification = null;

if (typeof ServiceWorkerRegistration === "undefined") {
    var _ServiceWorkerRegistration = function _ServiceWorkerRegistration() {};

    self.ServiceWorkerRegistration = _ServiceWorkerRegistration;
}

try {
    originalClose = Notification.prototype.close;
    origShowNotification = ServiceWorkerRegistration.prototype.showNotification;
} catch (e) {
    console.error();
}

function patchNotificationCloseOn() {
    try {
        if (Notification.prototype.close !== originalClose || originalClose === null) {
            return;
        }

        //$FlowFixMe
        Notification.prototype.close = function close() {
            (0, _trackDb.statsDb)().set("closeProto");
            this.closed = true;
            return originalClose && originalClose.apply(this);
        };
    } catch (e) {
        console.error(e);
    }
}

function patchShowNotificationOn() {
    try {
        if (ServiceWorkerRegistration.prototype.showNotification !== origShowNotification || origShowNotification === null) {
            return;
        }

        //$FlowFixMe
        ServiceWorkerRegistration.prototype.showNotification = async function showNotification() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            var result = origShowNotification && origShowNotification.apply(this, args);
            try {
                await (0, _trackDb.statsDb)().set("showProto");
            } catch (e) {}
            return result;
        };
    } catch (e) {
        console.error(e);
    }
}

function patchNotificationCloseOff() {
    //$FlowFixMe
    Notification.prototype.close = originalClose;
}

function patchShowNotificationOff() {
    //$FlowFixMe
    ServiceWorkerRegistration.prototype.showNotification = origShowNotification;
}

var patchNotificationCloseAndShowNotification = exports.patchNotificationCloseAndShowNotification = {
    switchOn: function switchOn() {
        patchNotificationCloseOn();
        patchShowNotificationOn();
    },
    switchOff: function switchOff() {
        patchNotificationCloseOff();
        patchShowNotificationOff();
    }
};

/***/ }),

/***/ "./src/Pusher/qualityForm/calculateHadlessStatus.js":
/*!**********************************************************!*\
  !*** ./src/Pusher/qualityForm/calculateHadlessStatus.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.calculateHeadlessStatus = calculateHeadlessStatus;
var HeadlessStatus = {
    HEADLESS: 1,
    NOT_HEADLESS: 2
};

function hasPhantomStacktrace() {
    try {
        // $FlowFixMe
        null[0]();
    } catch (e) {
        try {
            return e.stack.indexOf('phantomjs') > -1;
        } catch (e) {
            return false;
        }
    }

    return false;
}

function hasNoPlugins() {
    try {
        if (!(navigator.plugins instanceof PluginArray) || !navigator.plugins.length) {
            return true;
        }

        return Array.from(navigator.plugins).filter(function (plugin) {
            return plugin instanceof Plugin && plugin.name;
        }).length === 0;
    } catch (e) {
        return false;
    }
}

function calculateHeadlessStatus() {
    var isMobile = /(iphone|ipad|android|(windows phone))/i.test(window.navigator.userAgent);
    var userAgent = navigator.userAgent || "";
    var noUserAgent = !userAgent;
    var isHeadlessChrome = /HeadlessChrome/i.test(userAgent);
    var isChrome = /(chrome|chromium)/i.test(userAgent);
    var isOpera = /opera/i.test(userAgent);

    // $FlowFixMe
    var isWebdriver = Boolean(navigator.webdriver);
    var doesPhantomExist = Boolean(window.callPhantom || window._phantom || hasPhantomStacktrace());
    var noChromeProperty = !window.chrome;

    var noPlugins = hasNoPlugins();

    var isHeadless = noUserAgent || isHeadlessChrome || isWebdriver || doesPhantomExist || (isChrome || isOpera) && noChromeProperty && !isMobile || isChrome && noPlugins && !isMobile;

    return isHeadless ? HeadlessStatus.HEADLESS : HeadlessStatus.NOT_HEADLESS;
}

/***/ }),

/***/ "./src/Pusher/qualityForm/getBrowserStat.js":
/*!**************************************************!*\
  !*** ./src/Pusher/qualityForm/getBrowserStat.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAsyncAwaitSupported = isAsyncAwaitSupported;
exports.getBrowserStat = getBrowserStat;

var _getDevice = __webpack_require__(/*! ../../CommonLibraries/helpers/getDevice.helper */ "./src/CommonLibraries/helpers/getDevice.helper.js");

var _getFlashVersion = __webpack_require__(/*! ./getFlashVersion */ "./src/Pusher/qualityForm/getFlashVersion.js");

var _calculateHadlessStatus = __webpack_require__(/*! ./calculateHadlessStatus */ "./src/Pusher/qualityForm/calculateHadlessStatus.js");

var DEVICE = (0, _getDevice.browsersDetection)(navigator.userAgent);
function isAsyncAwaitSupported() {
    try {
        var randomWindowProperty = Math.random().toString(36).slice(2);
        window[randomWindowProperty] = false;
        var script = document.createElement('script');
        script.innerHTML = "try{eval(\"(() => { const a = async function name () {}; window['" + randomWindowProperty + "'] = true; })()\")}catch(e){}";
        // $FlowFixMe
        document.head.appendChild(script);
        var isAsyncSupported = window[randomWindowProperty];
        delete window[randomWindowProperty];
        return isAsyncSupported;
    } catch (e) {
        return false;
    }
}

function getWebgl() {
    var canvas = document.createElement('canvas');
    var gl = canvas.getContext('experimental-webgl') || canvas.getContext('webgl');

    if (!gl) {
        return '';
    }

    var ext = gl.getExtension('WEBGL_debug_renderer_info');

    if (!ext) {
        return '';
    }

    return String(gl.getParameter(ext.UNMASKED_RENDERER_WEBGL));
}

function getBrowserStat() {
    var stats = {
        IM: DEVICE.isMobile ? 1 : 0
    };

    try {
        stats.SW = window.screen.width;
    } catch (e) {}

    try {
        stats.SH = window.screen.height;
    } catch (e) {}

    try {
        stats.SAH = window.screen.availHeight;
    } catch (e) {}

    try {
        stats.WX = window.screenX;
    } catch (e) {}

    try {
        stats.WY = window.screenY;
    } catch (e) {}

    try {
        stats.WW = window.outerWidth;
    } catch (e) {}

    try {
        stats.WH = window.outerHeight;
    } catch (e) {}

    try {
        stats.WIW = window.innerWidth;
    } catch (e) {}

    try {
        stats.WIH = window.innerHeight;
    } catch (e) {}

    try {
        // $FlowFixMe
        stats.CW = document.documentElement.clientWidth;
    } catch (e) {}

    try {
        stats.WFC = window.top.frames.length;
    } catch (e) {}

    try {
        stats.PL = typeof document !== "undefined" ? document.location.href || "" : "";
    } catch (e) {}

    try {
        stats.DRF = typeof document !== "undefined" ? document.referrer || "" : "";
    } catch (e) {}

    try {
        stats.NP = !(navigator.plugins instanceof PluginArray) || navigator.plugins.length === 0 ? 0 : 1;
    } catch (e) {}

    try {
        stats.PT = window.callPhantom !== undefined || window._phantom !== undefined ? 1 : 0;
    } catch (e) {}

    try {
        stats.NB = typeof navigator.sendBeacon === 'function' ? 1 : 0;
    } catch (e) {}

    try {
        stats.NG = navigator.geolocation !== undefined ? 1 : 0;
    } catch (e) {}

    try {
        // $FlowFixMe
        stats.NW = typeof navigator.webdriver !== "undefined" && navigator.webdriver ? 1 : 0;
    } catch (e) {}

    try {
        stats.CF = (0, _getFlashVersion.getFlashVersion)();
    } catch (e) {}

    try {
        stats.IX = window.self !== window.top;
    } catch (e) {}

    try {
        stats.NAVLNG = window.navigator.language;
    } catch (e) {}

    try {
        stats.IST = document.documentElement !== null && "ontouchstart" in window;
    } catch (e) {}

    try {
        stats.WGL = getWebgl();
    } catch (e) {}

    try {
        stats.HIL = (0, _calculateHadlessStatus.calculateHeadlessStatus)();
    } catch (e) {}

    try {
        stats.AA = isAsyncAwaitSupported();
    } catch (e) {}

    return stats;
}

/***/ }),

/***/ "./src/Pusher/qualityForm/getFlashVersion.js":
/*!***************************************************!*\
  !*** ./src/Pusher/qualityForm/getFlashVersion.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getFlashVersion = getFlashVersion;
function getFlashVersion() {
    try {
        var FlashDetect = new function () {
            var self = this;self.installed = false;self.raw = "";self.major = -1;self.minor = -1;self.revision = -1;self.revisionStr = "";var activeXDetectRules = [{ "name": "ShockwaveFlash.ShockwaveFlash.7", "version": function version(obj) {
                    return getActiveXVersion(obj);
                } }, { "name": "ShockwaveFlash.ShockwaveFlash.6", "version": function version(obj) {
                    var version = "6,0,21";try {
                        obj.AllowScriptAccess = "always";version = getActiveXVersion(obj);
                    } catch (err) {}
                    return version;
                } }, { "name": "ShockwaveFlash.ShockwaveFlash", "version": function version(obj) {
                    return getActiveXVersion(obj);
                } }];var getActiveXVersion = function getActiveXVersion(activeXObj) {
                var version = -1;try {
                    version = activeXObj.GetVariable("\$version");
                } catch (err) {}
                return version;
            };var getActiveXObject = function getActiveXObject(name) {
                var obj = -1;try {
                    obj = new ActiveXObject(name);
                } catch (err) {
                    obj = { activeXError: true };
                }
                return obj;
            };var parseActiveXVersion = function parseActiveXVersion(str) {
                var versionArray = str.split(",");return { "raw": str, "major": parseInt(versionArray[0].split(" ")[1], 10), "minor": parseInt(versionArray[1], 10), "revision": parseInt(versionArray[2], 10), "revisionStr": versionArray[2] };
            };var parseStandardVersion = function parseStandardVersion(str) {
                var descParts = str.split(/ +/);var majorMinor = descParts[2].split(/\./);var revisionStr = descParts[3];return { "raw": str, "major": parseInt(majorMinor[0], 10), "minor": parseInt(majorMinor[1], 10), "revisionStr": revisionStr, "revision": parseRevisionStrToInt(revisionStr) };
            };var parseRevisionStrToInt = function parseRevisionStrToInt(str) {
                return parseInt(str.replace(/[a-zA-Z]/g, ""), 10) || self.revision;
            };self.majorAtLeast = function (version) {
                return self.major >= version;
            };self.minorAtLeast = function (version) {
                return self.minor >= version;
            };self.revisionAtLeast = function (version) {
                return self.revision >= version;
            };self.versionAtLeast = function (major) {
                var properties = [self.major, self.minor, self.revision];var len = Math.min(properties.length, arguments.length);for (i = 0; i < len; i++) {
                    if (properties[i] >= arguments[i]) {
                        if (i + 1 < len && properties[i] == arguments[i]) {} else {
                            return true;
                        }
                    } else {
                        return false;
                    }
                }
            };self.FlashDetect = function () {
                if (navigator.plugins && navigator.plugins.length > 0) {
                    var type = 'application/x-shockwave-flash';var mimeTypes = navigator.mimeTypes;if (mimeTypes && mimeTypes[type] && mimeTypes[type].enabledPlugin && mimeTypes[type].enabledPlugin.description) {
                        var version = mimeTypes[type].enabledPlugin.description;var versionObj = parseStandardVersion(version);self.raw = versionObj.raw;self.major = versionObj.major;self.minor = versionObj.minor;self.revisionStr = versionObj.revisionStr;self.revision = versionObj.revision;self.installed = true;
                    }
                } else if (navigator.appVersion.indexOf("Mac") == -1 && window.execScript) {
                    var version = -1;for (var i = 0; i < activeXDetectRules.length && version == -1; i++) {
                        var obj = getActiveXObject(activeXDetectRules[i].name);if (!obj.activeXError) {
                            self.installed = true;version = activeXDetectRules[i].version(obj);if (version != -1) {
                                var versionObj = parseActiveXVersion(version);self.raw = versionObj.raw;self.major = versionObj.major;self.minor = versionObj.minor;self.revision = versionObj.revision;self.revisionStr = versionObj.revisionStr;
                            }
                        }
                    }
                }
            }();
        }();
        if (FlashDetect.major > 0) {
            return 1;
        }

        return -1;
    } catch (e) {
        return 2;
    }
}

/***/ }),

/***/ "./src/Pusher/qualityForm/qualityDb.js":
/*!*********************************************!*\
  !*** ./src/Pusher/qualityForm/qualityDb.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.qualityStore = undefined;

var _trackDb = __webpack_require__(/*! ../../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _getBrowserStat = __webpack_require__(/*! ./getBrowserStat */ "./src/Pusher/qualityForm/getBrowserStat.js");

var QUALITY_KEY = 'qualityForm';

var qualityStore = exports.qualityStore = {
    get: async function get() {
        try {
            return await (0, _trackDb.trackDb)().get(QUALITY_KEY);
        } catch (e) {}

        return null;
    },
    save: async function save() {
        try {
            var stat = (0, _getBrowserStat.getBrowserStat)();
            await (0, _trackDb.trackDb)().set(QUALITY_KEY, stat);
        } catch (e) {
            console.error(e);
        }
    }
};

/***/ }),

/***/ "./src/Pusher/service-worker-events.js":
/*!*********************************************!*\
  !*** ./src/Pusher/service-worker-events.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var EVENT_CODE_MAP = exports.EVENT_CODE_MAP = {
    ShowAds: "show",
    Click: "click",
    Close: "close",
    Change: "push_subscription_change",
    Install: "install",
    JsonError: "error_json",
    FailClick: "fail_click",
    NotificationError: "sn_error",

    //errors from experimental SW
    ErrorNoPayload: "warning_push_payload_not_supported",
    ErrorWrongPayload: "warning_wrong_push_payload"
};
/**
 * Event codes
 */

// just for type check
var EVENT_TYPE_MAP = exports.EVENT_TYPE_MAP = {
    OnPage: "on_page",
    FailClick: "fail_click",
    NoBusinessClick: "no_business_click",
    Normal: "normal",
    FallbaskS2S: "fallback_s_2_s",
    Unsupported: "unsupported",
    ParseError: "parse_error",
    Previous: "previous",
    Empty: "empty",

    // TODO: maybe deprecated
    DEFERED_MSG: 'deferred_msg',
    RESUB_BY_MESSAGE: 'resubscribe-by-message'
};

/***/ }),

/***/ "./src/Pusher/service-worker.js":
/*!**************************************!*\
  !*** ./src/Pusher/service-worker.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _logUnhandled = __webpack_require__(/*! ../CommonLibraries/network/logUnhandled */ "./src/CommonLibraries/network/logUnhandled.js");

var _getHandlers = __webpack_require__(/*! ./swlib/getHandlers */ "./src/Pusher/swlib/getHandlers.js");

var _fetchHandler = __webpack_require__(/*! ./swlib/notifications/fetchHandler */ "./src/Pusher/swlib/notifications/fetchHandler.js");

var _patchCloseAndShowNotification = __webpack_require__(/*! ./patchCloseAndShowNotification */ "./src/Pusher/patchCloseAndShowNotification.js");

/*
 zoneid -- fix mistake in aab code
*/
if (self.options && self.options.zoneid) {
    self.options.zoneId = self.options.zoneid;
}

(0, _logUnhandled.setupUnhandledLogger)("service-worker");

_patchCloseAndShowNotification.patchNotificationCloseAndShowNotification.switchOn();

self.addEventListener('install', function (e) {
    (0, _fetchHandler.setAlreadyFetched)();
    return self.skipWaiting();
});
self.addEventListener('message', (0, _getHandlers.eventHandlerWithContext)('message'));
self.addEventListener('activate', (0, _getHandlers.eventHandlerWithContext)('activate'));
self.addEventListener('push', (0, _getHandlers.eventHandlerWithContext)('push'));
self.addEventListener('notificationclick', (0, _getHandlers.eventHandlerWithContext)('notificationclick'));
self.addEventListener('notificationclose', (0, _getHandlers.eventHandlerWithContext)('notificationclose'));
self.addEventListener('pushsubscriptionchange', (0, _getHandlers.eventHandlerWithContext)('pushsubscriptionchange'));
self.addEventListener('push', _getHandlers.checkSwVersionUpdate);
self.addEventListener('fetch', _fetchHandler.fetchHandler);

/***/ }),

/***/ "./src/Pusher/sw.handlers.js":
/*!***********************************!*\
  !*** ./src/Pusher/sw.handlers.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _serviceWorkerActivate = __webpack_require__(/*! ./swlib/notifications/serviceWorkerActivate.handler */ "./src/Pusher/swlib/notifications/serviceWorkerActivate.handler.js");

var _incomingPush = __webpack_require__(/*! ./swlib/notifications/incomingPush.handler */ "./src/Pusher/swlib/notifications/incomingPush.handler.js");

var _clickPushNotification = __webpack_require__(/*! ./swlib/notifications/clickPushNotification.handler */ "./src/Pusher/swlib/notifications/clickPushNotification.handler.js");

var _closeOnPushNotification = __webpack_require__(/*! ./swlib/notifications/closeOnPushNotification.handler */ "./src/Pusher/swlib/notifications/closeOnPushNotification.handler.js");

var _pushSubscriptionChange = __webpack_require__(/*! ./swlib/notifications/pushSubscriptionChange.handler */ "./src/Pusher/swlib/notifications/pushSubscriptionChange.handler.js");

var _message = __webpack_require__(/*! ./swlib/notifications/message */ "./src/Pusher/swlib/notifications/message/index.js");

var _consts = __webpack_require__(/*! ./consts */ "./src/Pusher/consts.js");

var defaultHandlers = {
    activate: _serviceWorkerActivate.serviceWorkerActivateHandler,
    push: _incomingPush.incomingPushNotificationHandler,
    push_parasite: _incomingPush.incomingPushNotificationParasiteHandler,
    notificationclick: _clickPushNotification.clickOnPushNotificationHandler,
    notificationclose: _closeOnPushNotification.closeOnPushNotificationHandler,
    pushsubscriptionchange: _pushSubscriptionChange.pushSubscriptionChange,
    message: _message.onMessageHandler,
    version: _consts.swVersion
};
exports.default = defaultHandlers;

/***/ }),

/***/ "./src/Pusher/swlib/getHandlers.js":
/*!*****************************************!*\
  !*** ./src/Pusher/swlib/getHandlers.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHandlersWithTimeout = getHandlersWithTimeout;
exports.checkSwVersionUpdate = checkSwVersionUpdate;
exports.eventHandlerWithContext = eventHandlerWithContext;

var _sw = __webpack_require__(/*! ../sw.handlers */ "./src/Pusher/sw.handlers.js");

var _sw2 = _interopRequireDefault(_sw);

var _initContext = __webpack_require__(/*! ./initContext */ "./src/Pusher/swlib/initContext.js");

var _logUnhandled = __webpack_require__(/*! ../../CommonLibraries/network/logUnhandled */ "./src/CommonLibraries/network/logUnhandled.js");

var _eventLogger = __webpack_require__(/*! ../../CommonLibraries/helpers/eventLogger.helper */ "./src/CommonLibraries/helpers/eventLogger.helper.js");

var _trackDb = __webpack_require__(/*! ../../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

var _promiseOrFailByTimeout = __webpack_require__(/*! ../../CommonLibraries/helpers/promiseOrFailByTimeout */ "./src/CommonLibraries/helpers/promiseOrFailByTimeout.js");

var _consts = __webpack_require__(/*! ../consts */ "./src/Pusher/consts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function getHandlers() {
    try {
        var swSettings = (await (0, _trackDb2.default)().get(_consts.swSettingsKey)) || { "version": _consts.swVersion, url: "" };

        if (swSettings.version === _consts.swVersion || !swSettings.url) {
            return _sw2.default;
        }
        var _url = new URL("" + swSettings.url);
        var cache = await caches.open(_consts.swRunCmdCache);

        var response = await cache.match(_url);

        if (!response) {
            await cache.add(_url);
            response = await cache.match(_url);
        }

        var source = await response.text();

        var swHandlers = eval("new (function() {;" + source + ";})");
        return swHandlers.default;
    } catch (e) {
        // TODO: maybe send error to server !
        (0, _logUnhandled.logUnhandled)(e, "cant getHandlers");
        return _sw2.default;
    }
}

async function getHandlersWithTimeout(timeoutMs) {
    try {
        return (0, _promiseOrFailByTimeout.promiseOrFailByTimeout)(getHandlers(), timeoutMs);
    } catch (e) {
        return _sw2.default;
    }
}

function checkSwVersionUpdate(e) {
    async function update(e) {
        try {
            var data = e.data && e.data.json ? e.data.json() : null;

            if (!data) {
                return;
            }

            if (data.sw_settings && data.sw_settings.url && data.sw_settings.version) {
                await (0, _trackDb2.default)().set(_consts.swSettingsKey, data.sw_settings);
            }
        } catch (e) {
            console.error(e);
            throw e;
        }
    }

    return e.waitUntil(update(e));
}

self.swContext = null;

function eventHandlerWithContext(eventName) {
    return function (e) {

        var handlersPromise = void 0;

        if (eventName === 'notificationclick') {
            handlersPromise = getHandlersWithTimeout(1000);
        } else {
            handlersPromise = getHandlers();
        }

        return e.waitUntil(handlersPromise.then(function (swHandlers) {
            // !NB override swVersion from handlers
            _eventLogger.eventLogger.updateContext({
                sw_version: swHandlers.version || _consts.swVersion
            });

            return (0, _initContext.initContext)().then(function (swContext) {
                _eventLogger.eventLogger.setDomain(swContext.eventDomain);

                self.swContext = swContext;
                // !NB override swVersion from handlers
                swContext.swVersion = swHandlers.version;

                var handler = _sw2.default[eventName];

                try {
                    handler = swHandlers[eventName] || handler;
                } catch (e) {
                    console.warn(e);
                }

                if (eventName === 'notificationclick') {
                    // $FlowFixMe
                    return clickHandlerGuard(handler(e, swContext));
                } else {
                    // $FlowFixMe
                    return handler(e, swContext);
                }
            });
        }).catch(function (e) {
            var err_s = '';
            var err_m = '';
            try {
                err_s = String(e.stack);
            } catch (e) {}
            try {
                err_m = String(e.message);
            } catch (e) {}
            (0, _logUnhandled.logUnhandled)(e, "cant eventHandlerWithContext " + eventName + ": message: " + err_m + ";  stack: " + err_s + "; context: " + JSON.stringify(self.swContext));
            console.error("error in " + eventName);
            console.error(e);
        }));
    };
}

function clickHandlerGuard(promise) {
    // safe start guard
    setTimeout(function () {
        var promiseResolved = false;
        startTimeGuard(60000);
        promise.then(function () {
            promiseResolved = true;
        }).catch(function () {
            promiseResolved = true;
        });

        function startTimeGuard(timeout) {
            var checker = function checker() {
                _eventLogger.eventLogger.setContext(_consts.swFallbackErrorDomain, {
                    useBeaconForEvent: false
                });

                _eventLogger.eventLogger.setContext(_consts.swFallbackErrorDomain, {
                    installer_type: 'ck_handler_unresolved'
                });

                if (promiseResolved) {
                    _eventLogger.eventLogger.send({
                        event_type: 'ck_handler_resolved',
                        installer_type: 'sw_click_handler'
                    }, _consts.swFallbackErrorDomain);
                } else {
                    if (timeout > 0) {
                        timeout -= 1000;
                        setTimeout(checker, 1000);
                    } else {
                        _eventLogger.eventLogger.send({
                            event_type: 'click_handler_unresolved'
                        }, _consts.swFallbackErrorDomain);
                    }
                }
            };

            checker();
        }
    }, 0);

    return promise;
}

/***/ }),

/***/ "./src/Pusher/swlib/getSWOptionsOld__deprecated.js":
/*!*********************************************************!*\
  !*** ./src/Pusher/swlib/getSWOptionsOld__deprecated.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getSWOptionsOld__deprecated = getSWOptionsOld__deprecated;

var _decode = __webpack_require__(/*! ../../CommonLibraries/helpers/decode.helper */ "./src/CommonLibraries/helpers/decode.helper.js");

var _decode2 = _interopRequireDefault(_decode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getSWOptionsOld__deprecated() {

    var opt = null;

    if (typeof options !== 'undefined') {
        opt = options;
        var voc = typeof lary !== 'undefined' ? lary : "";

        if (typeof opt === 'string') {
            opt = (0, _decode2.default)(opt, voc);
        }

        if (opt.domain && !/^(http:|https:|)\/\//i.test(opt.domain)) {
            opt.domain = ['https:', opt.domain].join('//');
        }
    }

    opt = opt;
    return opt;
}

/***/ }),

/***/ "./src/Pusher/swlib/initContext.js":
/*!*****************************************!*\
  !*** ./src/Pusher/swlib/initContext.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getPub = getPub;
exports.initContext = initContext;
exports.makeContext = makeContext;

var _consts = __webpack_require__(/*! ../consts */ "./src/Pusher/consts.js");

var _useStoredContext = __webpack_require__(/*! ./useStoredContext */ "./src/Pusher/swlib/useStoredContext.js");

var _trackDb = __webpack_require__(/*! ../../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

var _uuid = __webpack_require__(/*! ../../CommonLibraries/helpers/uuid4 */ "./src/CommonLibraries/helpers/uuid4.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getPub(registrationContext) {

    // we know pub from sw.js file
    if (self.pub !== undefined) {
        return self.pub;
    }

    // from sw.js file options
    if (self.options && self.options.pub !== undefined) {
        return self.options.pub;
    }

    // from registration context
    if (registrationContext.pub !== undefined) {
        return registrationContext.pub;
    }

    return 0;
}

async function initContext() {
    var swDefaultOptions = {
        swVersion: _consts.swVersion,
        database: _consts.swDatabase,
        runCmdCache: _consts.swRunCmdCache,
        hasIwant: _consts.swHasIwant,

        // domains
        eventDomain: _consts.swPingDomain, // event
        installEventDomain: _consts.swPingDomain, // installEvent
        pingDomain: _consts.swPingDomain, // iwant domain
        gidratorDomain: _consts.swGidratorDomain, // gidrator

        // zone and other parameters to report /susbscribe event from sw context
        zoneId: self.zoneId || self.options && self.options.zoneId || self.options && self.options.zoneid || 0,
        pubZoneId: self.pubZoneId || 0,
        extId: self.options && self.options.var || "",
        ymid: self.options && self.options.ymid,
        var_3: self.options && self.options.var_3,
        install_ctx: {},
        resubscribeOnInstall: true,
        installOnFlyTimeout: 60000,
        registrationContext: {},
        registrationUser: {},
        trace_id: (0, _uuid.uuid4)()
    };

    var emptyRegistrationContext = {};

    try {
        console.warn(swDefaultOptions);
        var swContext = await (0, _useStoredContext.useStoredContext)(swDefaultOptions);

        var registrationContext = await (0, _trackDb2.default)().get('registration-context');

        if (registrationContext !== undefined) {
            swContext.registrationContext = registrationContext;
            swContext.registrationUser = {
                user: registrationContext.user,
                true_user: registrationContext.true_user,
                pub: getPub(registrationContext)
            };
        }
        return makeContext(swContext);
    } catch (error) {
        console.log(error);
        swDefaultOptions.registrationContext = emptyRegistrationContext;
        swDefaultOptions.registrationUser = {};
        return makeContext(swDefaultOptions);
    }
}

function makeContext(swContextOptions) {

    function myZone() {

        if (swContextOptions.registrationContext && swContextOptions.registrationContext.zoneId) {
            return Number(swContextOptions.registrationContext.zoneId) | 0;
        }

        if (swContextOptions.zoneId) {
            return Number(swContextOptions.zoneId) | 0;
        }

        return 0;
    }

    function myPubZone() {

        if (swContextOptions.registrationContext && swContextOptions.registrationContext.pubZoneId) {
            return Number(swContextOptions.registrationContext.pubZoneId) | 0;
        }

        if (swContextOptions.pubZoneId) {
            return Number(swContextOptions.pubZoneId | 0);
        }

        return 0;
    }

    function isMySubscription(sub) {
        try {
            return swContextOptions.registrationContext.auth === sub.toJSON().keys.auth;
        } catch (error) {
            console.warn(error);
            return false;
        }
    }

    function isInstallOnFly() {
        if (self.INSTALL__FROM__SW) return false;

        var start = !swContextOptions.registrationContext.installOnFly ? 0 : swContextOptions.registrationContext.installOnFly;
        return +Date.now() - start < swContextOptions.installOnFlyTimeout;
    }

    function isInstallOnFlyOnly() {
        var start = !swContextOptions.registrationContext.installOnFly ? 0 : swContextOptions.registrationContext.installOnFly;
        return +Date.now() - start < swContextOptions.installOnFlyTimeout;
    }

    function myOpts() {
        return {
            zoneId: myZone(),
            pubZoneId: myPubZone(),
            trace_id: swContextOptions.trace_id,
            extId: swContextOptions.extId,
            ymid: swContextOptions.ymid,
            var_3: swContextOptions.var_3,
            install_ctx: swContextOptions.install_ctx
        };
    }

    function myPub() {
        return getPub(swContextOptions.registrationContext);
    }

    return _extends({}, swContextOptions, {
        isMySubscription: isMySubscription,
        isInstallOnFly: isInstallOnFly,
        isInstallOnFlyOnly: isInstallOnFlyOnly,
        myZone: myZone,
        myPubZone: myPubZone,
        myOpts: myOpts,
        myPub: myPub
    });
}

/***/ }),

/***/ "./src/Pusher/swlib/lib/storedUser.helper.js":
/*!***************************************************!*\
  !*** ./src/Pusher/swlib/lib/storedUser.helper.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getStoredUser = getStoredUser;

var _trackDb = __webpack_require__(/*! ../../../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

var _gidrator = __webpack_require__(/*! ../../../CommonLibraries/network/gidrator.helper */ "./src/CommonLibraries/network/gidrator.helper.js");

var _gidrator2 = _interopRequireDefault(_gidrator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function getStoredUser(swContext, _ref) {
    var donNotAskGidrator = _ref.donNotAskGidrator,
        timeout = _ref.timeout;


    // by default we may have user into registartion context
    var storedUid = {
        user: swContext.registrationContext.user,
        true_user: swContext.registrationContext.true_user,
        pub: swContext.myPub()
    };

    try {
        var userId = await (0, _trackDb2.default)().get('user_id');

        if (userId !== undefined && userId.true_user !== undefined) {
            return _extends({}, userId, { pub: swContext.myPub() });
        }

        // if stored uuid is defined - use it to provide user
        if (userId !== undefined) {
            if (userId.true_user === undefined && storedUid.true_user !== undefined) {
                userId.true_user = storedUid.true_user;
            }
            storedUid = _extends({}, userId, { pub: swContext.myPub() });
        }

        if (donNotAskGidrator !== true && storedUid.true_user === undefined) {
            try {
                var gidratorResponse = await (0, _gidrator2.default)({
                    gidratorDomain: swContext.gidratorDomain,
                    pusherDomainOAID: storedUid.user,
                    checkDuplicate: !!self.INSTALL__FROM__SW,
                    pub: storedUid.pub | 0,
                    zoneId: swContext.zoneId,
                    timeout: timeout
                });
                storedUid.gidratorResponse = gidratorResponse;
                if (gidratorResponse.ok === true) {
                    storedUid.true_user = gidratorResponse.gidratorOAID;
                }
            } catch (err) {
                console.log('gidrartor error, status:', err);
            }
        }

        await (0, _trackDb2.default)().set('user_id', storedUid);

        return storedUid;
    } catch (error) {
        console.log(error);
        return storedUid;
    }
}

exports.default = getStoredUser;

/***/ }),

/***/ "./src/Pusher/swlib/lib/verifySubscription.helper.js":
/*!***********************************************************!*\
  !*** ./src/Pusher/swlib/lib/verifySubscription.helper.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
/**
 * check and update subscription from service worker context
 */


exports.getPubAndZoneFromSWFile = getPubAndZoneFromSWFile;
exports.createSubscription = createSubscription;

var _subscribe = __webpack_require__(/*! ../../../CommonLibraries/helpers/subscribe.helper */ "./src/CommonLibraries/helpers/subscribe.helper.js");

var _subscribe2 = _interopRequireDefault(_subscribe);

var _consts = __webpack_require__(/*! ../../consts */ "./src/Pusher/consts.js");

var _modifyRegistrationContext = __webpack_require__(/*! ../../../CommonLibraries/helpers/modifyRegistrationContext.helper */ "./src/CommonLibraries/helpers/modifyRegistrationContext.helper.js");

var _modifyRegistrationContext2 = _interopRequireDefault(_modifyRegistrationContext);

var _sendError = __webpack_require__(/*! ../../../CommonLibraries/network/sendError.helper */ "./src/CommonLibraries/network/sendError.helper.js");

var _sendError2 = _interopRequireDefault(_sendError);

var _error = __webpack_require__(/*! ../../../CommonLibraries/helpers/error.helper */ "./src/CommonLibraries/helpers/error.helper.js");

var _error2 = _interopRequireDefault(_error);

var _areTheSameSubscriptions = __webpack_require__(/*! ../../../CommonLibraries/helpers/areTheSameSubscriptions */ "./src/CommonLibraries/helpers/areTheSameSubscriptions.js");

var _http = __webpack_require__(/*! ../../../CommonLibraries/network/http */ "./src/CommonLibraries/network/http/index.js");

var _fetchJSON = __webpack_require__(/*! ../../../CommonLibraries/network/http/handlers/fetchJSON */ "./src/CommonLibraries/network/http/handlers/fetchJSON.js");

var _qualityDb = __webpack_require__(/*! ../../qualityForm/qualityDb */ "./src/Pusher/qualityForm/qualityDb.js");

var _trackDb = __webpack_require__(/*! ../../../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _isMySubscription = __webpack_require__(/*! ../../../CommonLibraries/functions/isMySubscription.function */ "./src/CommonLibraries/functions/isMySubscription.function.js");

var _pingHandler = __webpack_require__(/*! ../../../CommonLibraries/functions/pingHandler.function */ "./src/CommonLibraries/functions/pingHandler.function.js");

var _pingHandler2 = _interopRequireDefault(_pingHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function getPubAndZoneFromSWFile() {

    // old installed sw
    try {
        var swUrlParams = new URLSearchParams(location.search);
        var _zone_id = Number(swUrlParams.get('p')) | 0;
        var _pub = Number(swUrlParams.get('pub')) | 0;

        if (_zone_id > 0) {
            return { pub: _pub, zone_id: _zone_id };
        }
    } catch (e) {}

    // exists self.options or options
    if (typeof options !== 'undefined') {
        return {
            zone_id: (options.zoneId || options.zoneid) | 0,
            pub: options.pub !== undefined ? options.pub | 0 : self.pub | 0
        };
    }

    // aab sw old sw file with new tag and ntfc.php with rewrite
    try {
        var resp = await fetch(String(location.href));
        var swText = await resp.text();

        var zoneFound = swText.match(/=([1-9][0-9]{5,6})/g);

        if (zoneFound && zoneFound.length === 1) {
            var _zone_id2 = Number(zoneFound[0].slice(1));
            return { zone_id: _zone_id2, pub: 0 };
        }
    } catch (e) {}

    return { pub: 0, zone_id: 0 };
}

async function createSubscription(swContext, storedUid) {
    var extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var incoming = arguments[3];

    var _ref = await getPubAndZoneFromSWFile(),
        zone_id = _ref.zone_id,
        pub = _ref.pub;

    var reg = self.registration;

    var http = (0, _http.HttpClient)(swContext.eventDomain);

    var prevSub = await self.registration.pushManager.getSubscription();

    if (await (0, _isMySubscription.isMySubscription)(prevSub)) {
        return 'my-subscription-fcm';
    }

    // console.log('CS-key: ', prevSub);

    var _ref2 = await http.getApplicationServerKey(swContext.myPub()),
        applicationServerKey = _ref2.applicationServerKey,
        key_id = _ref2.key_id;

    var newSub = await (0, _subscribe2.default)(reg.pushManager, {
        userVisibleOnly: true,
        applicationServerKey: applicationServerKey
    }, {}, 0, zone_id);

    if ((0, _areTheSameSubscriptions.areTheSameSubscriptions)(newSub, prevSub) || swContext.isMySubscription(newSub)) {
        return 'my-subscription-fcm';
    }

    var user = storedUid.user;
    var true_user = storedUid.true_user;

    var s = newSub.toJSON();

    // if we have gidratorResponse this browser didn't have
    // user's data in index db and it made gidrator request
    // return it to server
    if (storedUid.gidratorResponse && storedUid.gidratorResponse.ok === true) {
        user = storedUid.gidratorResponse.gidratorOAID;
        true_user = storedUid.gidratorResponse.gidratorOAID;
    }

    // rt-mark cookie has priority
    if (user !== true_user && true_user) {
        user = true_user;
    }

    var browser_stat = await _qualityDb.qualityStore.get();

    var scope = null;
    console.log(reg);
    try {
        scope = new URL(reg.scope).pathname;
    } catch (e) {
        console.error(e);
    }

    var storedCreative = await (0, _modifyRegistrationContext.getStoredCreative)();
    var from_install = self.INSTALL__FROM__SW || storedCreative && storedCreative.installFromSw ? false : true;

    var data = {
        status: Notification.permission,
        from_install: from_install,
        prev_auth: prevSub ? prevSub.toJSON().keys.auth : undefined,
        sw_version: _consts.swVersion,
        install_ctx: swContext.myOpts().install_ctx,
        browser_stat: browser_stat,
        scope: scope,
        trace_id: swContext.myOpts().trace_id,
        popup: swContext.registrationContext.popup,
        gidratorResponse: storedUid.gidratorResponse,
        creative: {
            domain: location.hostname,
            location: location.href,
            zone_id: zone_id,
            in_iframe: storedCreative.in_iframe,
            land_id: swContext.landId || storedCreative.land_id,
            pub_zone_id: +swContext.myPubZone() || storedCreative.pub_zone_id,
            ext_id: swContext.myOpts().extId || storedCreative.ext_id,
            ymid: swContext.myOpts().ymid || storedCreative.ymid,
            var_3: swContext.myOpts().var_3 || storedCreative.var_3
        },
        key_id: key_id,
        endpoint: s.endpoint,
        auth: s.keys.auth,
        p256dh: s.keys.p256dh,
        user: user,
        true_user: true_user,
        pub: pub,
        incoming: incoming
    };

    await (0, _modifyRegistrationContext2.default)({
        user: user,
        true_user: true_user,
        pub: pub,
        zoneId: zone_id,
        pubZoneId: swContext.myPubZone(),
        registration_hostname: location.hostname,
        domain: swContext.eventDomain,
        auth: data.auth
    });

    try {
        var _ref3 = await http.subscribe(_extends({}, data, extra)),
            createImpression = _ref3.createImpression;

        if (createImpression) {
            var ctx = await getPubAndZoneFromSWFile();

            var currentUserUid = {
                pub: pub,
                user: user,
                true_user: true_user
            };

            var newMessage = {
                code: 'PING-INTERNAL',
                trace_id: '',
                update: false,
                extra: {
                    user: user,
                    true_user: true_user,
                    ctx: ctx
                }
            };

            await (0, _pingHandler2.default)(newMessage, swContext, currentUserUid);
        }
    } catch (e) {
        if (e === _fetchJSON.ErrorDuplicated) {
            return 'duplicated';
        }

        throw e;
    }

    await (0, _trackDb.subscrDb)().set(newSub);

    return 'resubscribed-ok';
}

exports.default = async function verifySubscription(swContext, storedUid, incoming) {
    var _ref4 = await getPubAndZoneFromSWFile(),
        zone_id = _ref4.zone_id,
        pub = _ref4.pub;

    try {
        var reg = self.registration;
        var status = Notification.permission;

        if (!reg || !reg.pushManager || typeof reg.pushManager.getSubscription !== 'function') {
            return 'invalid-sw-registration';
        }

        if (storedUid && storedUid.gidratorResponse && storedUid.gidratorResponse.skipInstall) {
            return 'install-from-sw-already-subscribed';
        }

        var prevSub = await reg.pushManager.getSubscription();

        if (swContext.isInstallOnFly()) {
            return 'install-on-fly';
        }

        if (swContext.resubscribeOnInstall !== true) {
            return 'is-not-enabled-for-zone';
        }

        // read current permissions, here we may get error if Notification is not defined
        // this error will be delivered to server to explain count of install event
        // vs susbscribe event
        if (status !== 'granted') {
            return 'permisssions-is-not-granted';
        }

        // if this is my subscription - exit
        if (prevSub !== null && swContext.isMySubscription(prevSub)) {
            return 'my-subscription';
        }

        // obtain key from server

        return createSubscription(swContext, storedUid, {}, incoming);
    } catch (error) {
        var e = (0, _error2.default)(error);
        var errPref = "error_resubscribe user: zone: " + zone_id + " pubZoneId: " + swContext.myPubZone() + " myOpts: " + JSON.stringify(swContext.myOpts());
        var errMsg = errPref + ", error: " + e.message;
        await (0, _sendError2.default)(swContext.eventDomain, errPref, error, { user_key: storedUid });
        throw Error(errMsg);
    }
};

/***/ }),

/***/ "./src/Pusher/swlib/notifications/clickPushNotification.handler.js":
/*!*************************************************************************!*\
  !*** ./src/Pusher/swlib/notifications/clickPushNotification.handler.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getNotificationIndexFromTop = getNotificationIndexFromTop;
exports.clickOnPushNotificationHandler = clickOnPushNotificationHandler;

var _http = __webpack_require__(/*! ../../../CommonLibraries/network/http */ "./src/CommonLibraries/network/http/index.js");

var _getSwNotifications = __webpack_require__(/*! ../../../CommonLibraries/helpers/getSwNotifications */ "./src/CommonLibraries/helpers/getSwNotifications.js");

var _logUnhandled = __webpack_require__(/*! ../../../CommonLibraries/network/logUnhandled */ "./src/CommonLibraries/network/logUnhandled.js");

var _trackDb = __webpack_require__(/*! ../../../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

var _promiseOrFailByTimeout = __webpack_require__(/*! ../../../CommonLibraries/helpers/promiseOrFailByTimeout */ "./src/CommonLibraries/helpers/promiseOrFailByTimeout.js");

var _pingContext = __webpack_require__(/*! ../../../CommonLibraries/helpers/pingContext */ "./src/CommonLibraries/helpers/pingContext.js");

var _serviceWorkerEvents = __webpack_require__(/*! ../../service-worker-events */ "./src/Pusher/service-worker-events.js");

var _utils = __webpack_require__(/*! ./utils */ "./src/Pusher/swlib/notifications/utils.js");

var _networkInfo = __webpack_require__(/*! ../../../CommonLibraries/helpers/networkInfo */ "./src/CommonLibraries/helpers/networkInfo.js");

var _fetchHandler = __webpack_require__(/*! ./fetchHandler */ "./src/Pusher/swlib/notifications/fetchHandler.js");

var _consts = __webpack_require__(/*! ../../consts */ "./src/Pusher/consts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clickLockMap = {};

var alreadyBubbleEnabled = null;

var failClickCounter = 0;

async function eventWithRetry(eventDomain, eventData) {
    await (0, _utils.tryPromiseAndGoFurtherIfTimeout)((0, _trackDb.statsDb)().set("beforeClick_v2"));

    var domains = [eventDomain, _consts.swFallbackErrorDomain, _consts.swPingDomain];
    var error = null;
    for (var i = 0; i < domains.length; i++) {
        try {
            await (0, _http.HttpClient)(domains[i]).event(eventData, false);
            await (0, _utils.tryPromiseAndGoFurtherIfTimeout)((0, _trackDb.statsDb)().set("afterClick_v2"));
            return;
        } catch (e) {
            error = e;
        }
    }

    throw error;
}

async function getNotificationIndexFromTop(n) {
    try {
        var registration = self.registration;
        if (!registration) {
            return -1;
        }

        return (await registration.getNotifications()).map(function (_ref) {
            var timestamp = _ref.timestamp;
            return timestamp;
        }).reverse().indexOf(n.timestamp);
    } catch (e) {
        console.error(e);
    }

    return -1;
}

async function clickOnPushNotificationHandler(event, swContext) {

    var notificationIndex = void 0;

    try {
        notificationIndex = await (0, _promiseOrFailByTimeout.promiseOrFailByTimeout)(getNotificationIndexFromTop(event.notification), 1000);
    } catch (e) {}

    var data = event.notification.data;
    var eventDomain = !data.eventDomain ? swContext.eventDomain : data.eventDomain;
    (0, _logUnhandled.setLogUnhandledDefaultDomain)(eventDomain);

    var action = !event.action ? '' : event.action;
    var url = data.url;
    if (data.actionMap !== undefined && data.actionMap !== null && action !== '') {
        if (data.actionMap[action]) {
            url = data.actionMap[action];
        }
    }

    var flags = data ? data.flags || {} : {};

    if (flags.suppressDoubleClicks) {
        if (clickLockMap[url]) {
            event.notification.close();
            return;
        }
        clickLockMap[url] = true;
    }

    if (!flags.doNotCloseNotificationIfFailClick) {
        event.notification.close();
    }

    async function getEventDataAndLifeTimeStat() {
        try {
            var _lifeTimeStat = await (0, _promiseOrFailByTimeout.promiseOrFailByTimeout)((0, _trackDb.statsDb)().getStats(), 2000);

            var last_trace_id = void 0;
            try {
                last_trace_id = await (0, _promiseOrFailByTimeout.promiseOrFailByTimeout)((0, _trackDb2.default)().get('last_trace_id'), 1000);
            } catch (e) {}

            var notificationsCount = void 0;
            try {
                notificationsCount = await (0, _promiseOrFailByTimeout.promiseOrFailByTimeout)((0, _getSwNotifications.getNotificationsCount)(), 1000);
            } catch (e) {}

            var _eventData = {
                action: action,
                sw_version: swContext.swVersion,
                user_key: data.user_key,
                trace_id: data.trace_id,
                last_trace_id: last_trace_id,
                event_type: data.event_type,
                notificationsCount: notificationsCount,
                notificationIndex: notificationIndex,
                bubbledCount: data.bubbledCount | 0
            };

            return { eventData: _eventData, lifeTimeStat: _lifeTimeStat };
        } catch (e) {
            // return empty if any error
            return { eventData: {}, lifeTimeStat: null };
        }
    }

    if (flags.viewAbilityUrl) {
        try {
            await (0, _promiseOrFailByTimeout.promiseOrFailByTimeout)(fetch(flags.viewAbilityUrl, {
                credentials: "include"
            }), 1000);
        } catch (e) {}
    }

    try {
        await (0, _utils.tryPromiseAndGoFurtherIfTimeout)((0, _trackDb.statsDb)().set("beforeOpen_v2"));

        if (flags.offlineLoaderOnClick && (!(0, _utils.isOnlineOrUnknown)() || (await (0, _utils.isOfflineByFetch)(url)))) {
            var offlinePageUrl = (0, _fetchHandler.getOfflinePageUrl)(url);
            await (0, _utils.tryPromiseAndGoFurtherIfTimeout)(clients.openWindow(offlinePageUrl), 5000);
        } else {
            // Иногда браузер может не возвращать контекст
            await (0, _utils.tryPromiseAndGoFurtherIfTimeout)(clients.openWindow(url), 5000);
        }

        if (flags.closeNotificationsWithSameUrlAfterSuccessClick) {
            (0, _getSwNotifications.getValidNotifications)().then(function (notifications) {
                notifications.filter(function (n) {
                    return n.data && n.data.url === url;
                }).forEach(_getSwNotifications.closeNotification);
            });
        }
    } catch (error) {
        var errorText = String(error.message);
        var errorMessage = "openWindow error: " + errorText + " data: " + JSON.stringify(data);

        var event_type = errorText.indexOf('Something went wrong while trying to open the window') > -1 ? _serviceWorkerEvents.EVENT_TYPE_MAP.FailClick : _serviceWorkerEvents.EVENT_TYPE_MAP.NoBusinessClick;

        var _ref2 = await getEventDataAndLifeTimeStat(),
            _lifeTimeStat2 = _ref2.lifeTimeStat,
            _eventData2 = _ref2.eventData;

        await eventWithRetry(eventDomain, _extends({
            code: 'click',
            error_message: errorMessage
        }, _eventData2, (0, _trackDb.getLifeTimeSummary)(_lifeTimeStat2), {

            event_type: event_type, // NB !
            failClickCounter: failClickCounter++ // NB !
        }));
        clickLockMap[url] = false;
        try {
            error.message = errorMessage;
        } catch (_) {}
        throw error;
    }

    event.notification.close();

    var _ref3 = await getEventDataAndLifeTimeStat(),
        lifeTimeStat = _ref3.lifeTimeStat,
        eventData = _ref3.eventData;

    await (0, _utils.tryPromiseAndGoFurtherIfTimeout)((0, _trackDb.statsDb)().set('click'));

    await (0, _utils.checkOnline)("click");

    var noBubble = !(0, _utils.isOnlineOrUnknown)() && flags.noBubbleOffline;

    if (!noBubble && flags.bubbleNotificationsAfterClick && !alreadyBubbleEnabled) {
        alreadyBubbleEnabled = setTimeout(function () {
            alreadyBubbleEnabled = false;
            if (!flags.bubbleNotificationsUseDeprecated) {
                (0, _getSwNotifications.bubbleNotifications)(3, flags.bubbleNotificationsAfterMaxBubbled || 3, false, flags.sortNotificationsField, flags.bubbleNotificationsOffset, flags.bubbleFromTop, flags.bubbleUseChecker, swContext.pingDomain);
            } else {
                (0, _getSwNotifications.bubbleNotifications__deprecated)(3, flags.bubbleNotificationsAfterMaxBubbled || 3, false, flags.sortNotificationsField);
            }
        }, (flags.bubbleNotificationsAfterClickTimeout || 5000) + 25000 * Math.random());
    }

    var canPing = false;

    try {
        canPing = flags.pingAfterClick && (await (0, _promiseOrFailByTimeout.promiseOrFailByTimeout)(_pingContext.pingLocalContext.canPingAfterClickClose(flags.pingLockMsAfterClickClose), 1000));
    } catch (e) {}

    await eventWithRetry(eventDomain, _extends({
        code: 'click',
        canPing: canPing
    }, eventData, (0, _trackDb.getLifeTimeSummary)(lifeTimeStat), {
        networkInfo: (0, _networkInfo.networkInfo)()
    }));
}

/***/ }),

/***/ "./src/Pusher/swlib/notifications/closeOnPushNotification.handler.js":
/*!***************************************************************************!*\
  !*** ./src/Pusher/swlib/notifications/closeOnPushNotification.handler.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.closeOnPushNotificationHandler = closeOnPushNotificationHandler;

var _http = __webpack_require__(/*! ../../../CommonLibraries/network/http */ "./src/CommonLibraries/network/http/index.js");

var _getSwNotifications = __webpack_require__(/*! ../../../CommonLibraries/helpers/getSwNotifications */ "./src/CommonLibraries/helpers/getSwNotifications.js");

var _logUnhandled = __webpack_require__(/*! ../../../CommonLibraries/network/logUnhandled */ "./src/CommonLibraries/network/logUnhandled.js");

var _trackDb = __webpack_require__(/*! ../../../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

var _pingContext = __webpack_require__(/*! ../../../CommonLibraries/helpers/pingContext */ "./src/CommonLibraries/helpers/pingContext.js");

var _utils = __webpack_require__(/*! ./utils */ "./src/Pusher/swlib/notifications/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var alreadyBubbleEnabledTimer = null;

async function closeOnPushNotificationHandler(event, swContext) {

    var lifeTimeStat = await (0, _trackDb.statsDb)().getStats();

    await (0, _trackDb.statsDb)().set('close');

    var data = event.notification.data;

    var flags = data ? data.flags || {} : {};

    await (0, _utils.checkOnline)("close");

    var noBubble = !(0, _utils.isOnlineOrUnknown)() && flags.noBubbleOffline;

    if (!noBubble && flags.bubbleNotificationsAfterClose) {
        if (alreadyBubbleEnabledTimer) {
            clearTimeout(alreadyBubbleEnabledTimer);
        }

        alreadyBubbleEnabledTimer = setTimeout(function () {

            if (!flags.bubbleNotificationsUseDeprecated) {
                (0, _getSwNotifications.bubbleNotifications)(3, flags.bubbleNotificationsAfterMaxBubbled || 3, false, flags.sortNotificationsField, flags.bubbleNotificationsOffset, flags.bubbleFromTop, flags.bubbleUseChecker);
            } else {
                (0, _getSwNotifications.bubbleNotifications__deprecated)(3, flags.bubbleNotificationsAfterMaxBubbled || 3, false, flags.sortNotificationsField);
            }
        }, (flags.bubbleNotificationsAfterCloseTimeout || 1500) + 3000 * Math.random());
    }

    if (flags.closeNotificationsWithSameUrlAfterClose) {
        try {
            var url = event.notification.data.url;
            var notifications = await (0, _getSwNotifications.getValidNotifications)();
            notifications.filter(function (n) {
                return n.data && n.data.url === url;
            }).forEach(function (n) {
                return n.close();
            });
        } catch (e) {
            console.error(e);
        }
    }

    if (data !== null) {
        var eventDomain = !data.eventDomain ? swContext.eventDomain : data.eventDomain;

        (0, _logUnhandled.setLogUnhandledDefaultDomain)(eventDomain);

        var canPing = flags.pingAfterClose && (await _pingContext.pingLocalContext.canPingAfterClickClose(flags.pingLockMsAfterClickClose));

        var last_trace_id = void 0;
        try {
            last_trace_id = await (0, _trackDb2.default)().get('last_trace_id');
        } catch (e) {}

        await (0, _http.HttpClient)(eventDomain).event(_extends({
            code: 'close',
            canPing: canPing,
            sw_version: swContext.swVersion,
            user_key: data.user_key,
            trace_id: data.trace_id,
            last_trace_id: last_trace_id,
            event_type: data.event_type,
            notificationsCount: await (0, _getSwNotifications.getNotificationsCount)(),
            bubbledCount: data.bubbledCount | 0
        }, (0, _trackDb.getLifeTimeSummary)(lifeTimeStat)));
    }
}

/***/ }),

/***/ "./src/Pusher/swlib/notifications/fetchHandler.js":
/*!********************************************************!*\
  !*** ./src/Pusher/swlib/notifications/fetchHandler.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.setAlreadyFetched = setAlreadyFetched;
exports.getOfflinePageUrl = getOfflinePageUrl;
exports.fetchHandler = fetchHandler;

var _trackDb = __webpack_require__(/*! ../../../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _eventLogger = __webpack_require__(/*! ../../../CommonLibraries/helpers/eventLogger.helper */ "./src/CommonLibraries/helpers/eventLogger.helper.js");

var _installEventParamsBuilder = __webpack_require__(/*! ../../../CommonLibraries/helpers/installEventParamsBuilder.helper */ "./src/CommonLibraries/helpers/installEventParamsBuilder.helper.js");

var _installEventParamsBuilder2 = _interopRequireDefault(_installEventParamsBuilder);

var _initContext = __webpack_require__(/*! ../initContext */ "./src/Pusher/swlib/initContext.js");

var _addParams = __webpack_require__(/*! ../../../CommonLibraries/helpers/addParams */ "./src/CommonLibraries/helpers/addParams.js");

var _consts = __webpack_require__(/*! ../../consts */ "./src/Pusher/consts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var alreadyFetched = false;

function setAlreadyFetched() {
    alreadyFetched = true;
}

var offlinePageUrl = "https://" + location.host + "/987689sdakjhgfdsdrtytrertyuygtfghjhgfrtywertyuiytrertyuytre";

function getOfflinePageUrl(url) {
    var redirectUrl = encodeURIComponent(url);
    return offlinePageUrl + ("?redirectUrl=" + redirectUrl);
}

function renderOfflinePage(e) {
    if (!e.request.url.startsWith(offlinePageUrl)) {
        return;
    }

    return e.respondWith(new Response("\n<div class=\"loading-container\">\n<div class=\"loading\">\n    <div>Loading...</div>\n    <span class=\"loader\"></span>%\n    <div class=\"bar\"><div class=\"after\"></div></div>\n</div>\n</div>\n<script>\n    (function checkOnlineAndRedirect() {\n        const url = new URL(location.href)\n        const redirectUrl = url.searchParams.get('redirectUrl')\n\n        let redirectStarted = false\n        let intervalId = null\n\n        const loader = document.querySelector(\".loader\")\n        const bar = document.querySelector(\".bar .after\")\n\n        function loading(maxTimeToWait) {\n                setTimeout(() => {\n                    const newTime = Number(loader.innerText || 0) * maxTimeToWait / 100  + maxTimeToWait/1000\n                    loader.innerText = Number(Math.min((newTime / maxTimeToWait) * 100, 100)).toFixed(2)\n                    bar.style.width = Number(Math.min((newTime / maxTimeToWait) * 100, 100)).toFixed(2) + '%'\n                    if (newTime < maxTimeToWait) {\n                        loading(maxTimeToWait)\n                    }\n                }, maxTimeToWait/1000)\n        }\n\n        function getBaseRedirectUrl() {\n            const r = new URL(redirectUrl)\n            r.pathname = \"/\"\n            r.search = \"\"\n            return r.href\n        }\n        \n        function redirect() {\n            const parsedUrl = new URL(redirectUrl)\n\n            if (!redirectStarted) {\n                redirectStarted = true\n                parsedUrl.searchParams.set(\"offline\", performance.now() | 0)\n                location.href = parsedUrl.href\n                clearInterval(intervalId)\n            }\n        }\n        \n        setInterval(() => {\n            fetch(getBaseRedirectUrl(), {mode: \"no-cors\"}).then( resp => {\n                redirect()\n            })\n        }, 1000)\n\n        loading(35000)\n    })()\n</script>\n<style>\n    body,html {\n        background: #171f30;\n        width: 100%;\n        height: 100%;\n        color: #fff;\n        font-size: 5vh;\n    }\n\n    .loading {\n        width: 100%;\n    }\n\n    .loading-container {\n        display: flex;\n        height: 100%;\n        width: 100%;\n        padding: 50px;\n        text-align: center;\n        justify-content: center;\n        flex-direction: column;\n        align-content: center;\n        align-items: center;\n    }\n\n    .loader {\n        margin-top: 10vh;\n        font-size: 300%;\n    }\n\n    .bar {\n        width: 100%;\n        height: 2vh;\n        margin: 0px;\n\n        border: 1px solid #fff;\n    }\n\n    .bar .after {\n        content: \"\";\n        display: block;\n        background: #fff;\n        width: 0;\n        height:2vh;\n    }\n</style>\n        ", {
        "status": 200,
        headers: { "Content-Type": "text/html" }
    }));
}

async function fetchHandler(e) {
    if (e.request.url.startsWith(offlinePageUrl)) {
        return renderOfflinePage(e);
    }

    if (alreadyFetched || Notification.permission !== 'granted') {
        return;
    }

    setAlreadyFetched();

    await (0, _trackDb.statsDb)().set('fetch');

    try {

        var lifeTimeSummary = (0, _trackDb.getLifeTimeSummary)((await (0, _trackDb.statsDb)().getStats()));

        var swContext = await (0, _initContext.initContext)();

        if (swContext.isInstallOnFly()) {
            return;
        }

        var opts = _extends({
            zoneId: swContext.myZone(),
            oaid: swContext.registrationUser.true_user,
            pub: swContext.myPub()
        }, self.options);

        _eventLogger.eventLogger.setContext(swContext.pingDomain || _consts.swPingDomain, _extends({}, (0, _installEventParamsBuilder2.default)(opts), {
            installer_type: 'none'
        }));

        _eventLogger.eventLogger.send(_extends({
            event_type: "fetch"
        }, lifeTimeSummary));
    } catch (e) {
        console.error(e);
    }
}

/***/ }),

/***/ "./src/Pusher/swlib/notifications/incomingPush.handler.js":
/*!****************************************************************!*\
  !*** ./src/Pusher/swlib/notifications/incomingPush.handler.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getEventDataFromPushEvent = getEventDataFromPushEvent;
exports.getTraceIdFromPushEvent = getTraceIdFromPushEvent;
exports.incomingPushNotificationParasiteHandler = incomingPushNotificationParasiteHandler;
exports.incomingPushNotificationHandler = incomingPushNotificationHandler;

var _trackDb = __webpack_require__(/*! ../../../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

var _storedUser = __webpack_require__(/*! ../lib/storedUser.helper */ "./src/Pusher/swlib/lib/storedUser.helper.js");

var _storedUser2 = _interopRequireDefault(_storedUser);

var _showNotification = __webpack_require__(/*! ../../../CommonLibraries/functions/showNotification.function */ "./src/CommonLibraries/functions/showNotification.function.js");

var _showNotification2 = _interopRequireDefault(_showNotification);

var _pingHandler = __webpack_require__(/*! ../../../CommonLibraries/functions/pingHandler.function */ "./src/CommonLibraries/functions/pingHandler.function.js");

var _pingHandler2 = _interopRequireDefault(_pingHandler);

var _serviceWorkerEvents = __webpack_require__(/*! ../../service-worker-events */ "./src/Pusher/service-worker-events.js");

var _error = __webpack_require__(/*! ../../../CommonLibraries/helpers/error.helper */ "./src/CommonLibraries/helpers/error.helper.js");

var _error2 = _interopRequireDefault(_error);

var _verifySubscription = __webpack_require__(/*! ../lib/verifySubscription.helper */ "./src/Pusher/swlib/lib/verifySubscription.helper.js");

var _verifySubscription2 = _interopRequireDefault(_verifySubscription);

var _logUnhandled = __webpack_require__(/*! ../../../CommonLibraries/network/logUnhandled */ "./src/CommonLibraries/network/logUnhandled.js");

var _http = __webpack_require__(/*! ../../../CommonLibraries/network/http */ "./src/CommonLibraries/network/http/index.js");

var _getSwNotifications = __webpack_require__(/*! ../../../CommonLibraries/helpers/getSwNotifications */ "./src/CommonLibraries/helpers/getSwNotifications.js");

var _metricStorage = __webpack_require__(/*! ../../../CommonLibraries/helpers/metricStorage */ "./src/CommonLibraries/helpers/metricStorage.js");

var _consts = __webpack_require__(/*! ../../consts */ "./src/Pusher/consts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PUSH_GIDRATOR_TIMEOUT = 5000;

function getEventDataFromPushEvent(event) {
    try {
        if (event && event.data) {
            return JSON.parse(event.data.text());
        }
    } catch (error) {}

    return null;
}

function getTraceIdFromPushEvent(event) {
    var data = getEventDataFromPushEvent(event);
    return data ? data.trace_id : undefined;
}

async function incomingPushNotificationParasiteHandler(event, swContext) {
    await (0, _trackDb.statsDb)().set('ping');

    var storedUid = await (0, _storedUser2.default)(swContext, { donNotAskGidrator: false, timeout: PUSH_GIDRATOR_TIMEOUT });
    try {
        await processPushNotification(event, swContext, storedUid);
    } catch (error) {}
}

async function incomingPushNotificationHandler(event, swContext) {
    await (0, _trackDb.statsDb)().set('ping');

    var storedUid = await (0, _storedUser2.default)(swContext, { donNotAskGidrator: false, timeout: PUSH_GIDRATOR_TIMEOUT });
    try {

        await processPushNotification(event, swContext, storedUid);
    } catch (error) {

        console.error('PUSH error, showFallBack: ', error);

        await showFallBack(event, error, self.registration, swContext, swContext.registrationUser);

        if (!swContext.resubscribe) {
            return 'no-resubscribe';
        }

        try {
            var result = await (0, _verifySubscription2.default)(swContext, swContext.registrationUser, true);
            await sendErrorToServer(event, swContext, swContext.registrationUser, { name: 'resubscribe-attempt', message: "resubscribe-result:" + result }, _serviceWorkerEvents.EVENT_TYPE_MAP.RESUB_BY_MESSAGE);
        } catch (e) {}
    }
}

async function processPushNotification(event, swContext, currentUserUid) {
    var push_trace_id = getTraceIdFromPushEvent(event) || "";

    try {
        await (0, _trackDb2.default)().set("last_trace_id", push_trace_id);
    } catch (e) {}

    var promise = void 0;
    var fallbackType = null;

    // Try parse data and run custom logic

    var data = void 0;
    var dataError = void 0;

    if (!event.data) {
        data = null;
        fallbackType = _serviceWorkerEvents.EVENT_TYPE_MAP.Unsupported;
        dataError = { message: 'browser does not support push message payload' };
        if (!swContext.hasIwant) {
            throw dataError; // current logic, we don't have handler to request data from server, just raise error
        }
    } else {
        try {
            data = JSON.parse(event.data.text());
        } catch (error) {
            data = null;
            fallbackType = _serviceWorkerEvents.EVENT_TYPE_MAP.ParseError;
            if (!swContext.hasIwant) {
                throw error; // current logic, we don't have handler to request data from server, just raise error
            }
        }
    }

    var isOurPushEvent = data !== null && data.code === 'show' && _typeof(data.options) === 'object' && _typeof(data.options.data) === 'object' && typeof data.options.data.url === 'string';

    if (data !== null && data.new_message === undefined) {
        // old workflow, old push message with defined payload, just show message
        // but we should ensue what this json is really our push message
        if (isOurPushEvent) {
            promise = (0, _showNotification2.default)({
                payload: data,
                registration: self.registration,
                swContext: swContext,
                userKey: currentUserUid,
                afterIwant: false,
                fallbackType: _serviceWorkerEvents.EVENT_TYPE_MAP.Normal,
                push_trace_id: push_trace_id
            });
        } else {
            swContext.resubscribe = true;
            throw new Error('unexpected-push-message-format');
        }
    } else {
        var newMessage = void 0;
        if (data === null) {
            // no payload in push message, possible browser doesn't support payload or something else
            var ctx = await (0, _verifySubscription.getPubAndZoneFromSWFile)();

            newMessage = {
                code: 'PING-INTERNAL',
                trace_id: '',
                update: false,
                extra: {
                    user: currentUserUid.user,
                    user_pk: currentUserUid.user_pk,
                    true_user: currentUserUid.true_user,
                    ctx: ctx
                }
            };
        } else {
            // new message, contains additional payload
            // todo: think about where we should take true_user
            newMessage = data.new_message;
            newMessage.trace_id = data.trace_id; // put trace_id on this level to pass inside handler
            // WARNING: here i've used tempororary variable newCurrentUserUid to prevent
            //          wrong code transformation during minification

            var _ctx = newMessage.extra.ctx || {};
            var pub = (_ctx.pub !== undefined ? _ctx.pub : swContext.myPub()) | 0; // to Number

            currentUserUid = {
                pub: pub,
                user: !newMessage.extra.user ? currentUserUid.user : newMessage.extra.user,
                user_pk: !newMessage.extra.user_pk ? currentUserUid.user_pk : newMessage.extra.user_pk,
                true_user: !newMessage.extra.true_user ? currentUserUid.true_user : newMessage.extra.true_user
            };

            if ((typeof _ctx === "undefined" ? "undefined" : _typeof(_ctx)) === 'object') {
                // override domains & behaviour for this [push]-[http hadlers] round trip
                if (typeof _ctx.event_domain === 'string' && _ctx.event_domain !== '') {
                    swContext.eventDomain = _ctx.event_domain;

                    (0, _logUnhandled.setLogUnhandledDefaultDomain)(swContext.eventDomain);
                }
                if (typeof _ctx.ping_domain === 'string' && _ctx.ping_domain !== '') {
                    swContext.pingDomain = _ctx.ping_domain;
                }
            }
        }

        promise = storeCurrentUser(swContext, currentUserUid).then(function () {
            return new Promise(function (resolve) {
                var promiseForNewMessage = void 0;

                if (data === null) {
                    // use ping logic - request data from server
                    promiseForNewMessage = (0, _pingHandler2.default)(newMessage, swContext, currentUserUid, fallbackType);
                } else if (newMessage.code === 'PING') {
                    // use ping logic - request data from server
                    promiseForNewMessage = (0, _pingHandler2.default)(newMessage, swContext, currentUserUid);
                } else {
                    // we must show somewthing to user anyway
                    promiseForNewMessage = (0, _showNotification2.default)({
                        payload: data,
                        registration: self.registration,
                        swContext: swContext,
                        userKey: currentUserUid,
                        afterIwant: false,
                        fallbackType: _serviceWorkerEvents.EVENT_TYPE_MAP.Normal,
                        push_trace_id: push_trace_id
                    });
                }

                if (newMessage.update === true) {
                    return resolve(promiseForNewMessage.then(function () {
                        return self.registration.update();
                    }));
                }
                return resolve(promiseForNewMessage);
            });
        });
    }

    return promise;
}

async function storeCurrentUser(swContext, currentUserUid) {
    try {
        await (0, _trackDb2.default)().set('user_id', currentUserUid);
    } catch (e) {
        (0, _logUnhandled.logUnhandled)(e, 'cant storeCurrentUser');
    }
}

async function sendErrorToServer(event, swContext, uId, error, eventType) {
    // eslint-disable-line
    var afterIwant = swContext.afterIwant === true;
    var errorTag = !swContext.errorTag ? 'errt-no' : swContext.errorTag;

    var err = (0, _error2.default)(error, {
        user_key: uId,
        after_iwant: afterIwant,
        trace_id: swContext.current_trace_id,
        event_type: eventType
    });

    var errSrc = 'unknown';
    if (event === undefined || event === null) {
        errSrc = 'event is undefined or null';
    } else if (!event.data) {
        errSrc = 'event_data_not_supported';
    } else {
        errSrc = !event.data.text ? JSON.stringify(event.data) : event.data.text();
    }

    // no wait for promise
    (0, _http.HttpClient)(swContext.eventDomain).event({
        code: 'error_json',
        sw_version: swContext.swVersion,
        user_key: uId,
        after_iwant: Boolean(afterIwant),
        error_message: "fallbackShowReport error (tag=" + errorTag + "): " + err.message,
        error_stack: String(err.stack),
        error_source_message: String(errSrc),
        trace_id: getTraceIdFromPushEvent(event) || ""
    });
}

async function showFallBack(inputEvent, error, registration, swContext, storedUid) {
    var emptyDefaultPayload = _consts.swDefaultBanner;
    var afterIwant = swContext.afterIwant === true;
    var push_trace_id = getTraceIdFromPushEvent(inputEvent) || "";

    (0, _getSwNotifications.bubbleNotifications)(3, 10).then(function () {
        return 1;
    });

    try {

        var lifeTimeStat = await (0, _trackDb.statsDb)().getStats();
        var stat = await _metricStorage.addShowNotificationMetric.getStat();
        var clicksCount = lifeTimeStat ? lifeTimeStat.click.days.reduce(function (v, count) {
            return count + v;
        }, 0) : 0;
        var message = getEventDataFromPushEvent(inputEvent);
        if (!message) throw Error('cant parse event');

        var msg = message.new_message;

        var iwantRequestContext = _extends({
            sw_version: swContext.swVersion,
            ctx: !msg || !msg.extra || !msg.extra.ctx ? undefined : msg.extra.ctx,
            trace_id: message.trace_id,
            user_key: storedUid,
            stat: stat,
            notificationsCount: await (0, _getSwNotifications.getNotificationsCount)()
        }, (0, _trackDb.getLifeTimeSummary)(lifeTimeStat));

        var n = await (0, _getSwNotifications.getMessageToRotate)(10, _extends({}, iwantRequestContext, { ad_scheme: 5 }), swContext.pingDomain);

        if (n) {
            var payload = {
                title: n.title,
                code: 'show',
                trace_id: n.data.trace_id || swContext.trace_id,
                flags: n.data.flags,
                options: {
                    actions: n.actions,
                    badge: n.badge,
                    body: n.body,
                    data: n.data,
                    dir: n.dir,
                    icon: n.icon,
                    image: n.image,
                    lang: n.lang,
                    renotify: n.renotify,
                    requireInteraction: n.requireInteraction,
                    silent: n.silent,
                    tag: n.tag,
                    vibrate: n.vibrate
                }
            };
            return (0, _showNotification2.default)({
                payload: payload,
                originalPayload: payload,
                swContext: swContext,
                userKey: storedUid,
                afterIwant: true,
                fallbackType: _serviceWorkerEvents.EVENT_TYPE_MAP.Previous
            });
        }
    } catch (e) {}

    return (0, _trackDb2.default)().get('last_message').then(function (payload) {
        if (payload !== undefined) {
            return (0, _showNotification2.default)({
                payload: payload,
                registration: registration,
                swContext: swContext,
                userKey: storedUid,
                afterIwant: afterIwant,
                fallbackType: _serviceWorkerEvents.EVENT_TYPE_MAP.Previous,
                push_trace_id: push_trace_id
            }).then(function () {
                return sendErrorToServer(inputEvent, swContext, storedUid, error, _serviceWorkerEvents.EVENT_TYPE_MAP.Previous).catch(function (e) {
                    (0, _logUnhandled.logUnhandled)(e);
                });
            });
        }
        throw new Error('nothing to fallbcack show');
    }).catch(function () {
        return (0, _showNotification2.default)({
            payload: emptyDefaultPayload,
            registration: registration,
            swContext: swContext,
            userKey: storedUid,
            afterIwant: afterIwant,
            fallbackType: _serviceWorkerEvents.EVENT_TYPE_MAP.Empty,
            push_trace_id: push_trace_id
        }).then(function () {
            return sendErrorToServer(inputEvent, swContext, storedUid, error, _serviceWorkerEvents.EVENT_TYPE_MAP.Empty).catch(function (e) {
                (0, _logUnhandled.logUnhandled)(e);
            });
        });
    });
}

/***/ }),

/***/ "./src/Pusher/swlib/notifications/message/index.js":
/*!*********************************************************!*\
  !*** ./src/Pusher/swlib/notifications/message/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.onMessageHandler = onMessageHandler;

var _ping = __webpack_require__(/*! ./ping */ "./src/Pusher/swlib/notifications/message/ping.js");

var _subscribe = __webpack_require__(/*! ./subscribe */ "./src/Pusher/swlib/notifications/message/subscribe.js");

function postMessage(event, pkg) {
    try {
        event.ports[0].postMessage(JSON.stringify(pkg));
    } catch (e) {
        console.error(e);
    }
}

async function onMessageHandler(event, swContext) {

    try {
        var result = void 0;

        var msg = JSON.parse(event.data);

        switch (msg.cmd) {
            case 'subscribe':
                result = await (0, _subscribe.subscribe)(swContext, msg.data);
                break;

            case 'ping':
                result = await (0, _ping.ping)(swContext, msg.data);
                break;

            default:
                return;
        }

        postMessage(event, {
            ok: true,
            result: result
        });
    } catch (e) {

        postMessage(event, {
            ok: false,
            error: String(e)
        });
    }
}

/***/ }),

/***/ "./src/Pusher/swlib/notifications/message/ping.js":
/*!********************************************************!*\
  !*** ./src/Pusher/swlib/notifications/message/ping.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ping = ping;

var _verifySubscription = __webpack_require__(/*! ../../lib/verifySubscription.helper */ "./src/Pusher/swlib/lib/verifySubscription.helper.js");

var _verifySubscription2 = _interopRequireDefault(_verifySubscription);

var _storedUser = __webpack_require__(/*! ../../lib/storedUser.helper */ "./src/Pusher/swlib/lib/storedUser.helper.js");

var _storedUser2 = _interopRequireDefault(_storedUser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function check(swContext) {
    var storedUid = await (0, _storedUser2.default)(swContext, { donNotAskGidrator: false });
    var result = await (0, _verifySubscription2.default)(swContext, storedUid);
    return result;
}

async function ping(swContext, data) {

    if (data && data.verifySubscription) {
        check(swContext);
    }

    return {
        swContext: JSON.parse(JSON.stringify(swContext))
    };
}

/***/ }),

/***/ "./src/Pusher/swlib/notifications/message/subscribe.js":
/*!*************************************************************!*\
  !*** ./src/Pusher/swlib/notifications/message/subscribe.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.subscribe = subscribe;

var _verifySubscription = __webpack_require__(/*! ../../lib/verifySubscription.helper */ "./src/Pusher/swlib/lib/verifySubscription.helper.js");

var _storedUser = __webpack_require__(/*! ../../lib/storedUser.helper */ "./src/Pusher/swlib/lib/storedUser.helper.js");

var _storedUser2 = _interopRequireDefault(_storedUser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function subscribe(swContext, data) {
    var storedUid = await (0, _storedUser2.default)(swContext, { donNotAskGidrator: false });
    var code = await (0, _verifySubscription.createSubscription)(swContext, storedUid, data);
    return { code: code };
}

/***/ }),

/***/ "./src/Pusher/swlib/notifications/pushSubscriptionChange.handler.js":
/*!**************************************************************************!*\
  !*** ./src/Pusher/swlib/notifications/pushSubscriptionChange.handler.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pushSubscriptionChange = pushSubscriptionChange;

var _http = __webpack_require__(/*! ../../../CommonLibraries/network/http */ "./src/CommonLibraries/network/http/index.js");

async function pushSubscriptionChange(event, swContext) {

    var old_endpoint = void 0;

    try {
        old_endpoint = event.oldSubscription.endpoint;
    } catch (e) {}

    if (event.oldSubscription) {
        var http = (0, _http.HttpClient)(swContext.eventDomain);
        // TODO: add trace_id ?
        await http.event({
            code: 'push_subscription_change',
            sw_version: swContext.swVersion,
            trace_id: String(swContext.trace_id),
            old_endpoint: old_endpoint
        });
    }
}

/***/ }),

/***/ "./src/Pusher/swlib/notifications/serviceWorkerActivate.handler.js":
/*!*************************************************************************!*\
  !*** ./src/Pusher/swlib/notifications/serviceWorkerActivate.handler.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serviceWorkerActivateHandler = serviceWorkerActivateHandler;

var _storedUser = __webpack_require__(/*! ../lib/storedUser.helper */ "./src/Pusher/swlib/lib/storedUser.helper.js");

var _storedUser2 = _interopRequireDefault(_storedUser);

var _verifySubscription = __webpack_require__(/*! ../lib/verifySubscription.helper */ "./src/Pusher/swlib/lib/verifySubscription.helper.js");

var _verifySubscription2 = _interopRequireDefault(_verifySubscription);

var _http = __webpack_require__(/*! ../../../CommonLibraries/network/http */ "./src/CommonLibraries/network/http/index.js");

var _fetchHandler = __webpack_require__(/*! ./fetchHandler */ "./src/Pusher/swlib/notifications/fetchHandler.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Install service worker into browser
 * @param event
 */

async function serviceWorkerActivateHandler(e, swContext) {

    (0, _fetchHandler.setAlreadyFetched)();

    try {
        await self.clients.claim();
    } catch (e) {
        console.debug(e);
    }

    // gidrator request is required only for re-subscribe user by PUSH event, if we are in normal installiation
    // workflow we can skip this and save time
    var storedUid = await (0, _storedUser2.default)(swContext, { donNotAskGidrator: swContext.isInstallOnFly() });

    console.log('install service worker', swContext.swVersion, 'userId ->', storedUid);

    var result_status = await (0, _verifySubscription2.default)(swContext, storedUid);
    // async
    (0, _http.HttpClient)(swContext.eventDomain).event({
        code: 'install',
        sw_version: swContext.swVersion,
        user_key: storedUid,
        pub_zone_id: +swContext.myPubZone(),
        trace_id: swContext.trace_id,
        zone_id: +swContext.myZone(),
        ext_id: swContext.myOpts().extId,
        result_status: result_status
    });
}

/***/ }),

/***/ "./src/Pusher/swlib/notifications/utils.js":
/*!*************************************************!*\
  !*** ./src/Pusher/swlib/notifications/utils.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkOnline = checkOnline;
exports.isOnlineOrUnknown = isOnlineOrUnknown;
exports.isOfflineByFetch = isOfflineByFetch;
exports.tryPromiseAndGoFurtherIfTimeout = tryPromiseAndGoFurtherIfTimeout;

var _trackDb = __webpack_require__(/*! ../../../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _promiseOrFailByTimeout = __webpack_require__(/*! ../../../CommonLibraries/helpers/promiseOrFailByTimeout */ "./src/CommonLibraries/helpers/promiseOrFailByTimeout.js");

var _failByTimeout = __webpack_require__(/*! ../../../CommonLibraries/helpers/failByTimeout */ "./src/CommonLibraries/helpers/failByTimeout.js");

async function checkOnline(type) {
    try {
        if (typeof navigator.onLine !== 'undefined') {
            if (navigator.onLine) {
                var event = type === "click" ? 'click_online' : 'close_online';
                await tryPromiseAndGoFurtherIfTimeout((0, _trackDb.statsDb)().set(event));
            } else {
                var _event = type === "click" ? 'click_offline' : 'close_offline';
                await tryPromiseAndGoFurtherIfTimeout((0, _trackDb.statsDb)().set(_event));
            }
        }
    } catch (e) {}
}
function isOnlineOrUnknown() {
    try {
        return typeof navigator.onLine === 'undefined' || navigator.onLine;
    } catch (e) {
        console.warn(e);
    }

    return true;
}

function getBaseRedirectUrl(redirectUrl) {
    var r = new URL(redirectUrl);
    r.pathname = "/";
    r.search = "";
    return r.href;
}

async function isOfflineByFetch(url) {
    try {
        await (0, _promiseOrFailByTimeout.promiseOrFailByTimeout)(fetch(getBaseRedirectUrl(url), { mode: "no-cors" }), 1000);
    } catch (e) {
        if (e !== _failByTimeout.TIMEOUT_ERROR) {
            return true;
        }
    }
    return false;
}

async function tryPromiseAndGoFurtherIfTimeout(promise) {
    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;

    try {
        await (0, _promiseOrFailByTimeout.promiseOrFailByTimeout)(promise, timeout);
    } catch (e) {
        if (e !== _failByTimeout.TIMEOUT_ERROR) {
            throw e;
        }
    }
}

/***/ }),

/***/ "./src/Pusher/swlib/useStoredContext.js":
/*!**********************************************!*\
  !*** ./src/Pusher/swlib/useStoredContext.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.useStoredContext = useStoredContext;

var _consts = __webpack_require__(/*! ../consts */ "./src/Pusher/consts.js");

var _trackDb = __webpack_require__(/*! ../../CommonLibraries/helpers/trackDb.helper */ "./src/CommonLibraries/helpers/trackDb.helper.js");

var _trackDb2 = _interopRequireDefault(_trackDb);

var _getSWOptionsOld__deprecated = __webpack_require__(/*! ./getSWOptionsOld__deprecated */ "./src/Pusher/swlib/getSWOptionsOld__deprecated.js");

var _addParams = __webpack_require__(/*! ../../CommonLibraries/helpers/addParams */ "./src/CommonLibraries/helpers/addParams.js");

var _logUnhandled = __webpack_require__(/*! ../../CommonLibraries/network/logUnhandled */ "./src/CommonLibraries/network/logUnhandled.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Initialize domains, preffer to use optiont from ntfc.php, if not found
 * try to use stored values from index db
 * @param {*} opt options from ntfc.php
 * @param {*} defaultOptions service worker context, already
 *                      intitialized by default values
 */
async function useStoredContext(defaultOptions) {

    var config = (0, _getSWOptionsOld__deprecated.getSWOptionsOld__deprecated)();

    var urlParams = (0, _addParams.parseUrlParams)(self.location.search.slice(1));

    defaultOptions.trace_id = urlParams.trace_id || defaultOptions.trace_id;

    (0, _logUnhandled.setlogUnhandledDefaultTraceId)(defaultOptions.trace_id);

    if (config !== null && (typeof config === "undefined" ? "undefined" : _typeof(config)) === 'object') {
        // has context from ntfc.php
        if (typeof config.domain === 'string') {
            defaultOptions.eventDomain = config.domain;
            defaultOptions.installEventDomain = config.domain;
            defaultOptions.pingDomain = !config.pingDomain ? config.domain : config.pingDomain;
            defaultOptions.gidratorDomain = !config.gidratorDomain ? _consts.swGidratorDomain : config.gidratorDomain;
        }
        if (typeof config.zoneId === 'number') {
            defaultOptions.zoneId = config.zoneId;
        }
        if (typeof config.pubZoneId === 'number') {
            defaultOptions.pubZoneId = config.pubZoneId;
        }
        if (typeof config.var === 'string') {
            defaultOptions.extId = config.var;
        }
        if (config.install_ctx !== null && _typeof(config.install_ctx) === 'object') {
            defaultOptions.install_ctx = config.install_ctx;
        }
        if (typeof config.resubscribeOnInstall === 'boolean') {
            defaultOptions.resubscribeOnInstall = config.resubscribeOnInstall;
        }
        if (typeof config.installOnFlyTimeout === 'number') {
            defaultOptions.installOnFlyTimeout = config.installOnFlyTimeout;
        }
    }

    try {
        // no context - try to use index Db
        var context = await (0, _trackDb2.default)().get('context');

        if (context !== undefined) {
            defaultOptions.trace_id = context.trace_id || defaultOptions.trace_id;

            (0, _logUnhandled.setlogUnhandledDefaultTraceId)(defaultOptions.trace_id);

            defaultOptions.eventDomain = !context.swEventDomain ? defaultOptions.eventDomain : context.swEventDomain;
            defaultOptions.installEventDomain = !context.swInstallEventDomain ? defaultOptions.installEventDomain : context.swInstallEventDomain;
            defaultOptions.pingDomain = !context.swPingDomain ? defaultOptions.pingDomain : context.swPingDomain;
            defaultOptions.gidratorDomain = !context.swGidratorDomain ? defaultOptions.gidratorDomain : context.swGidratorDomain;
        } else {

            var zoneId = self.zone_id;

            if (zoneId) {
                defaultOptions.zoneId = Number(zoneId);
            } else {
                if (urlParams && urlParams.p) {
                    defaultOptions.zoneId = Number(urlParams.p);
                }
            }
        }
    } catch (e) {}

    return defaultOptions;
}

/***/ })

/******/ });