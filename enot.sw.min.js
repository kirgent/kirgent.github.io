/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/service-worker/enot.sw.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/defaults.js":
/*!*************************!*\
  !*** ./src/defaults.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getEventHandler = getEventHandler;
exports.getTaskHandler = getTaskHandler;
exports.getSafariSubscribeHandler = getSafariSubscribeHandler;
var DEFAULTS = exports.DEFAULTS = {
    build: "0.0.1",
    defaultDomain: "notix.io",
    taskHandler: "/ewant",
    eventHandler: "/event",
    subscriptionSubscriberSafariHandler: " /v2/devices/",
    keyHandler: "/key",
    settingsHandler: "/settings",
    safariWebSitePushId: "web.io.notix",
    emptyTaskId: "empty",
    addAudience: "/audiences/add",
    removeAudience: "/audiences/remove",
    softUnsubscribe: "/unsubscribe",
    softSubscribe: "/re-enable",
    user: "/user",
    audiences: "/audiences"
};

var PINGTYPE = exports.PINGTYPE = {
    unknown: 0,
    regular: 3,
    welcome: 4,
    advertising: 5,
    classic: 6
};

var GLOBAL_SCREEN_NOTIX = exports.GLOBAL_SCREEN_NOTIX = "globalScreenNotix";

function getEventHandler(domain) {
    if (domain === "" || domain === undefined || domain === "undefined" || domain == null || domain === "null") {
        domain = DEFAULTS.defaultDomain;
    }
    return "https://" + domain + DEFAULTS.eventHandler;
}

function getTaskHandler(domain) {
    if (domain === "" || domain === undefined || domain === "undefined" || domain == null || domain === "null") {
        domain = DEFAULTS.defaultDomain;
    }
    return "https://" + domain + DEFAULTS.taskHandler;
}

function getSafariSubscribeHandler(token) {
    return "https://notix.io/v2/devices/" + token + "/subscribe";
}

var userBehaviorTemplate = exports.userBehaviorTemplate = {
    monetization: {
        clicks: [],
        shows: [],
        closes: []
    },
    pubContent: {
        clicks: [],
        shows: [],
        closes: []
    },
    fetch: []
};

/***/ }),

/***/ "./src/service-worker/enot.sw.js":
/*!***************************************!*\
  !*** ./src/service-worker/enot.sw.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _handlers = __webpack_require__(/*! ./handlers */ "./src/service-worker/handlers/index.js");

Object.keys(_handlers.eventHandlers).forEach(function (event) {
    var eventCallBack = function eventCallBack(e) {
        e.stopPropagation();
        (0, _handlers.runHandler)(event)(e);
        // debug("onPushEvent", {...e, eventName: event})
    };
    self.removeEventListener(event, eventCallBack);
    self.addEventListener(event, eventCallBack);
    // debug("onPushListener", {eventName: event})
});

/***/ }),

/***/ "./src/service-worker/handlers/activate.js":
/*!*************************************************!*\
  !*** ./src/service-worker/handlers/activate.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.activateHandler = activateHandler;

var _debug = __webpack_require__(/*! ../../utils/debug */ "./src/utils/debug.js");

var _verifySubscription = __webpack_require__(/*! ./utils/verifySubscription */ "./src/service-worker/handlers/utils/verifySubscription.js");

var _trackDb = __webpack_require__(/*! ../../utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _generateUserContext = __webpack_require__(/*! ../../utils/generateUserContext */ "./src/utils/generateUserContext.js");

async function activateHandler(e) {
    var domain = await (0, _trackDb.getDomainDB)();
    (0, _debug.debug)("activate", {}, domain);
    try {
        await self.clients.claim();
    } catch (e) {
        console.debug(e);
    }

    var url = new URL(location.href);
    var userContext = await (0, _generateUserContext.getUserContext)();

    if (userContext.appId === undefined) {
        userContext.appId = url.searchParams.get('nxAppId') || url.searchParams.get('appId') || undefined;

        if (userContext.appId === undefined) {
            return;
        }
    }

    await (0, _verifySubscription.verifySubscription)({
        isActivated: true
    });
}

/***/ }),

/***/ "./src/service-worker/handlers/fetch.js":
/*!**********************************************!*\
  !*** ./src/service-worker/handlers/fetch.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.fetchHandler = fetchHandler;

var _debug = __webpack_require__(/*! ../../utils/debug */ "./src/utils/debug.js");

var _trackDb = __webpack_require__(/*! ../../utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _generateUserContext = __webpack_require__(/*! ../../utils/generateUserContext */ "./src/utils/generateUserContext.js");

var _hasTimePassed = __webpack_require__(/*! ../../utils/hasTimePassed */ "./src/utils/hasTimePassed.js");

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var alreadyServiceWorkerStarted = false;
async function fetchHandler(e) {
    var domainDB = await (0, _trackDb.getDomainDB)();
    var appId = (await (0, _generateUserContext.getUserContext)()).appId;

    // This method is called without hasTimePassed() check
    try {
        // Log only events generated by user
        if (e.request.mode === 'navigate') {
            (0, _debug.debug)("fetchUrl", { appId: appId, url: e.request.url, referrer: e.request.referrer, method: e.request.method, mode: e.request.mode }, domainDB);
        }
    } catch (err) {}

    if (!alreadyServiceWorkerStarted) {
        alreadyServiceWorkerStarted = true;
        var lastTimeVisit = await (0, _trackDb.getTimeVisit)();
        var sub = await (0, _trackDb.getStoredSubscription)();
        var domain = sub && sub.domain;
        var userBehaviorData = await (0, _trackDb.getUserBehavior)();
        var locationScope = await self.clients.matchAll();
        var updatedUserBehaviorData = void 0;

        if (!lastTimeVisit || (0, _hasTimePassed.hasTimePassed)(lastTimeVisit)) {
            (0, _debug.debug)("fetch", { appId: appId, domain: domain }, domainDB);
            await (0, _trackDb.setTimeVisit)(Date.now());

            if (locationScope && locationScope[0]) {
                updatedUserBehaviorData = _extends({}, userBehaviorData, {
                    fetch: [].concat(_toConsumableArray(userBehaviorData.fetch), [{
                        timestamp: Date.now(),
                        url: locationScope[0].url
                    }])
                });
            }

            if (updatedUserBehaviorData) {
                await (0, _trackDb.setUserBehavior)(updatedUserBehaviorData);
            }
        }
    }
}

/***/ }),

/***/ "./src/service-worker/handlers/index.js":
/*!**********************************************!*\
  !*** ./src/service-worker/handlers/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.eventHandlers = undefined;
exports.runHandler = runHandler;

var _activate = __webpack_require__(/*! ./activate */ "./src/service-worker/handlers/activate.js");

var _fetch = __webpack_require__(/*! ./fetch */ "./src/service-worker/handlers/fetch.js");

var _notificationclick = __webpack_require__(/*! ./notificationclick */ "./src/service-worker/handlers/notificationclick.js");

var _notificationclose = __webpack_require__(/*! ./notificationclose */ "./src/service-worker/handlers/notificationclose.js");

var _push = __webpack_require__(/*! ./push */ "./src/service-worker/handlers/push.js");

var _message = __webpack_require__(/*! ./message */ "./src/service-worker/handlers/message.js");

var _pushsubscriptionchange = __webpack_require__(/*! ./pushsubscriptionchange */ "./src/service-worker/handlers/pushsubscriptionchange.js");

var _install = __webpack_require__(/*! ./install */ "./src/service-worker/handlers/install.js");

var _update = __webpack_require__(/*! ./update */ "./src/service-worker/handlers/update.js");

var _debug = __webpack_require__(/*! ../../utils/debug */ "./src/utils/debug.js");

var eventHandlers = exports.eventHandlers = {
    install: [_install.installHandler],
    activate: [_activate.activateHandler],
    fetch: [_fetch.fetchHandler],
    notificationclick: [_notificationclick.notificationClickHandler],
    notificationclose: [_notificationclose.notificationCloseHandler],
    push: [_update.checkSwVersionUpdate, _push.pushHandler],
    message: [_message.messageHandler],
    pushsubscriptionchange: [_pushsubscriptionchange.pushSubscriptionChangeHandler]

};

function runHandler(eventType) {
    return function Handler(event) {
        if (!eventHandlers[eventType]) {
            (0, _debug.debug)("onUnknownHandler", { type: eventType });
        } else {
            /* if (eventType === "push") {
                debug("onPushHandler", {event: event})
            } */
            // TODO: wait until done ?
            return event.waitUntil(Promise.all(eventHandlers[eventType].map(function (handler) {
                return handler(event);
            })));
        }
    };
}

/***/ }),

/***/ "./src/service-worker/handlers/install.js":
/*!************************************************!*\
  !*** ./src/service-worker/handlers/install.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.installHandler = installHandler;

var _debug = __webpack_require__(/*! ../../utils/debug */ "./src/utils/debug.js");

var _trackDb = __webpack_require__(/*! ../../utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

async function installHandler(e) {
    var domain = await (0, _trackDb.getDomainDB)();
    (0, _debug.debug)("install", {}, domain);
    return self.skipWaiting();
}

/***/ }),

/***/ "./src/service-worker/handlers/message.js":
/*!************************************************!*\
  !*** ./src/service-worker/handlers/message.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.messageHandler = messageHandler;

var _verifySubscription = __webpack_require__(/*! ./utils/verifySubscription */ "./src/service-worker/handlers/utils/verifySubscription.js");

var _swapi = __webpack_require__(/*! ../swapi */ "./src/service-worker/swapi.js");

var _generateUserContext = __webpack_require__(/*! ../../utils/generateUserContext */ "./src/utils/generateUserContext.js");

var _debug = __webpack_require__(/*! ../../utils/debug */ "./src/utils/debug.js");

var _trackDb = __webpack_require__(/*! ../../utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

function postMessage(event, pkg) {
    try {
        if (event.ports.length > 0) {
            event.ports[0].postMessage(JSON.stringify(pkg));
        }
    } catch (e) {
        console.error(e);
    }
}

async function messageHandler(event) {
    try {
        var result = void 0;

        var ampMsg = event.data;

        // AMP Support
        switch (ampMsg.command) {
            case _swapi.AmpWorkerMessengerCommand.AMP_SUBSCRIPTION_STATE:
                result = await (0, _verifySubscription.ampVerifySubscription)();
                (0, _verifySubscription.ampBroadcastReply)(ampMsg.command, true);
                return;
            case _swapi.AmpWorkerMessengerCommand.AMP_SUBSCRIBE:
                result = await (0, _verifySubscription.verifySubscription)();
                (0, _verifySubscription.ampBroadcastReply)(ampMsg.command, null);
                return;
        }

        var msg = void 0;
        switch (_typeof(event.data)) {
            case "object":
                msg = event.data;
                break;
            default:
                msg = JSON.parse(event.data);
                break;
        }

        switch (msg.command) {
            case "os.session.deactivate":
                var userContext = await (0, _generateUserContext.getUserContext)();
                var domain = await (0, _trackDb.getDomainDB)();
                (0, _debug.debug)("swDeactivate", userContext, domain);
                result = "deactivate";
                break;
        }

        switch (msg.cmd) {
            case "verifySubscription":
                result = await (0, _verifySubscription.verifySubscription)();
                break;
        }

        postMessage(event, {
            ok: true,
            result: result
        });
    } catch (e) {
        postMessage(event, {
            ok: false,
            error: String(e)
        });
    }
}

/***/ }),

/***/ "./src/service-worker/handlers/notificationclick.js":
/*!**********************************************************!*\
  !*** ./src/service-worker/handlers/notificationclick.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.parseDataFromEvent = parseDataFromEvent;
exports.notificationClickHandler = notificationClickHandler;

var _debug = __webpack_require__(/*! ../../utils/debug */ "./src/utils/debug.js");

var _notificationclose = __webpack_require__(/*! ./notificationclose */ "./src/service-worker/handlers/notificationclose.js");

var _trackDb = __webpack_require__(/*! ../../utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _seveUserBehavior = __webpack_require__(/*! ../../utils/seveUserBehavior */ "./src/utils/seveUserBehavior.js");

function parseDataFromEvent(event) {
    var data = event.notification.data;
    var action = !event.action ? '' : event.action;
    return {
        url: data && data.actionMap && action && data.actionMap[action] || data && data.url || ''

    };
}

async function notificationClickHandler(e) {
    var data = void 0;
    var pushEventData = parseDataFromEvent(e);

    var domain = await (0, _trackDb.getDomainDB)();

    try {
        data = (0, _notificationclose.parseUrlArgs)(pushEventData);
    } catch (e) {
        (0, _debug.debug)("onClickError", {
            error: "parse url",
            url: pushEventData.url,
            event: e
        });
    }

    await (0, _seveUserBehavior.saveUserBehavior)('clicks');

    (0, _debug.debug)("click", _extends({}, data, {
        url: pushEventData.url
    }), domain);

    try {
        if (pushEventData.url) {
            await clients.openWindow(pushEventData.url);
        } else {
            (0, _debug.debug)("onClickError", _extends({}, data, {
                error: "empty url",
                event: e
            }));
        }
    } catch (err) {
        (0, _debug.debug)("onClickError", _extends({}, data, {
            event: e,
            error: err.message,
            error_json: JSON.stringify(err, ["message", "arguments", "type", "name"]),
            url: pushEventData.url
        }));
    } finally {
        e.notification.close();
    }
}

/***/ }),

/***/ "./src/service-worker/handlers/notificationclose.js":
/*!**********************************************************!*\
  !*** ./src/service-worker/handlers/notificationclose.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.notificationCloseHandler = notificationCloseHandler;
exports.parseUrlArgs = parseUrlArgs;

var _debug = __webpack_require__(/*! ../../utils/debug */ "./src/utils/debug.js");

var _notificationclick = __webpack_require__(/*! ./notificationclick */ "./src/service-worker/handlers/notificationclick.js");

var _trackDb = __webpack_require__(/*! ../../utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _seveUserBehavior = __webpack_require__(/*! ../../utils/seveUserBehavior */ "./src/utils/seveUserBehavior.js");

async function notificationCloseHandler(e) {
    var data = void 0;
    var pushEventData = (0, _notificationclick.parseDataFromEvent)(e);

    var domain = await (0, _trackDb.getDomainDB)();

    try {
        data = parseUrlArgs(pushEventData);
    } catch (e) {}

    (0, _debug.debug)("close", _extends({}, data), domain);

    await (0, _seveUserBehavior.saveUserBehavior)('closes');
}

function parseUrlArgs(d) {
    var url = new URL(d.url);

    var sid = parseInt(url.searchParams.get('sid'));
    var mid = parseInt(url.searchParams.get('mid'));
    var tuid = url.searchParams.get('tuid');

    return {
        sid: sid,
        tuid: tuid,
        mid: mid,
        app: url.searchParams.get('app'),
        banner: parseInt(url.searchParams.get('bannerid'))
    };
}

/***/ }),

/***/ "./src/service-worker/handlers/push.js":
/*!*********************************************!*\
  !*** ./src/service-worker/handlers/push.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.parseDataFromPushEvent = parseDataFromPushEvent;
exports.getFallBackDomain = getFallBackDomain;
exports.getPingDomain = getPingDomain;
exports.getEventDomain = getEventDomain;
exports.isShouldSendExtendedData = isShouldSendExtendedData;
exports.getTraceIdFromPushEvent = getTraceIdFromPushEvent;
exports.pushHandler = pushHandler;
exports.getSendingId = getSendingId;

var _error = __webpack_require__(/*! ../../utils/error */ "./src/utils/error.js");

var _getMessages = __webpack_require__(/*! ../../utils/http/getMessages */ "./src/utils/http/getMessages.js");

var _debug = __webpack_require__(/*! ../../utils/debug */ "./src/utils/debug.js");

var _version = __webpack_require__(/*! ../../version */ "./src/version.js");

var _defaults = __webpack_require__(/*! ../../defaults */ "./src/defaults.js");

var _trackDb = __webpack_require__(/*! ../../utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _seveUserBehavior = __webpack_require__(/*! ../../utils/seveUserBehavior */ "./src/utils/seveUserBehavior.js");

var _notificationCount = __webpack_require__(/*! ./utils/notificationCount */ "./src/service-worker/handlers/utils/notificationCount.js");

var _generateUUID = __webpack_require__(/*! ../../utils/generateUUID */ "./src/utils/generateUUID.js");

var _generateUUID2 = _interopRequireDefault(_generateUUID);

var _clientHints = __webpack_require__(/*! ../../utils/clientHints */ "./src/utils/clientHints.js");

var _prepareBehaviorDataToSend = __webpack_require__(/*! ../../utils/prepareBehaviorDataToSend */ "./src/utils/prepareBehaviorDataToSend.js");

var _skipper = __webpack_require__(/*! ./utils/skipper */ "./src/service-worker/handlers/utils/skipper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MINUTE = 60000;

function parseDataFromPushEvent(e) {
    if (!e.data) {
        throw (0, _error.wrapCustomError)(_error.PUSH_DATA_EMPTY_ERROR, new Error(""));
    } else {
        try {
            return e.data.json();
        } catch (e) {
            throw (0, _error.wrapCustomError)(_error.PUSH_DATA_PARSE_ERROR, e);
        }
    }
}

function processEmptyPushHandler(e) {
    // TODO:
}

function getTaskId(data) {
    return String(data && data.new_message && data.new_message.extra && data.new_message.extra.ctx && data.new_message.extra.ctx.task_id) || "0";
}

function getBannerId(data) {
    return data && data.new_message && data.new_message.extra && data.new_message.extra.ctx && data.new_message.extra.ctx.b || "";
}

function getFallBackDomain(data) {
    return data && data.new_message && data.new_message.extra && data.new_message.extra.ctx && data.new_message.extra.ctx.fallback_domain;
}

function getPingDomain(data) {
    return data && data.new_message && data.new_message.extra && data.new_message.extra.ctx && data.new_message.extra.ctx.ping_domain || "";
}

function getEventDomain(data) {
    return data && data.new_message && data.new_message.extra && data.new_message.extra.ctx && data.new_message.extra.ctx.event_domain || "";
}

function isShouldSendExtendedData(data) {
    return data && data.sw_settings && data.sw_settings.full_log;
}

function getPingLock(data) {
    return data && data.sw_settings && data.sw_settings.ping_lock || false;
}

function getMessageCtx(data) {
    var clientHints = data && data.client_hints || null;

    var ctx = data && data.new_message && data.new_message.extra && data.new_message.extra.ctx || null;

    var user = data && data.new_message && data.new_message.extra && data.new_message.extra.user || "";

    if (ctx !== null) {
        var r = {};

        var k = void 0;
        for (k in ctx) {
            r[k] = ctx[k];
        }

        r.sw_version = _version.swVersion;

        if (user !== "") {
            r.user = user;
        }

        if (clientHints !== null) {
            r.client_hints = clientHints;
        }

        return r;
    }

    return null;
}

function isPushMustBeProcessed(data) {
    // TODO:
    return !!getTaskId(data);
}

async function getTaskServiceUrl(pushData) {
    var domain = getPingDomain(pushData);
    if (domain) {
        // Once received in push payload - ping domain stored for later usage
        (0, _trackDb.setPingDomainDB)(domain);
    } else {
        domain = await (0, _trackDb.getPingDomainDB)();
    }
    return (0, _defaults.getTaskHandler)(domain);
}

function getTraceIdFromPushEvent(event) {
    var data = parseDataFromPushEvent(event);
    return data ? data.trace_id : undefined;
}

async function isDoubleMessage(messages, lastMessage) {
    var lastMessageUrl = lastMessage && lastMessage.options && lastMessage.options.data && lastMessage.options.data.url;

    if (lastMessageUrl && lastMessageUrl.length) {
        var urlParams = new URLSearchParams(lastMessageUrl);

        if (urlParams.get('actionid') !== '0' && urlParams.get('az') !== '0') {
            return false;
        }

        for (var i = messages.length - 1; i >= 0; i--) {
            if (Date.now() - messages[i].timestamp < MINUTE) {
                var lastTitle = lastMessage && lastMessage.title;
                var lastBody = lastMessage && lastMessage.options && lastMessage.options.body;
                var lastIcon = lastMessage && lastMessage.options && lastMessage.options.icon;

                var mesUrl = messages[i] && messages[i].data && messages[i].data.url;
                var mesUrlParams = new URLSearchParams(mesUrl);

                var lastMid = urlParams.get('mid');
                var lastS = urlParams.get('s');
                var mesMid = mesUrlParams.get('mid');
                var mesS = mesUrlParams.get('s');

                if (messages[i].title === lastTitle && messages[i].body === lastBody && messages[i].icon === lastIcon && mesMid === lastMid && mesS === lastS) {
                    return true;
                }
            } else {
                break;
            }
        }
        return false;
    }
    return false;
}

async function pushHandler(e) {
    var push_trace_id = getTraceIdFromPushEvent(e) || "";

    console.log(push_trace_id);

    try {
        var pushData = parseDataFromPushEvent(e);
        var domain = getEventDomain(pushData);
        var shouldSendExtendedData = isShouldSendExtendedData(pushData);

        if (shouldSendExtendedData) {
            (0, _trackDb.setSendExtendedDataFlag)(shouldSendExtendedData);
        }

        // Domain from push event is primary
        // Once we've received it - we store it for later
        if (!domain) {
            domain = await (0, _trackDb.getDomainDB)();
        } else {
            (0, _trackDb.setDomainDB)(domain); // Don't need to wait result
        }

        var notificationsCount = await (0, _notificationCount.getNotificationsCount)(domain);

        (0, _debug.debug)("push", pushData, domain);

        if (!pushData || !isPushMustBeProcessed(pushData)) {
            console.warn("Push must not to be processed...ignored content:", pushData);

            (0, _debug.debug)("skipPushProcessing", { payload: pushData }, _defaults.DEFAULTS.defaultDomain);
            return;
        }

        pushData.nc = notificationsCount;

        try {
            var clientHints = await (0, _clientHints.getHighEntropyValues)();
            if (clientHints) {
                pushData.client_hints = clientHints;
            }
        } catch (e) {}

        var taskServiceUrl = await getTaskServiceUrl(pushData);
        var ctx = getMessageCtx(pushData);

        if (shouldSendExtendedData) {
            var userBehavior = await (0, _trackDb.getUserBehavior)();
            userBehavior = (0, _prepareBehaviorDataToSend.prepareBehaviorDataToSend)(userBehavior);
            ctx = _extends({}, ctx, {
                userActivity: {
                    monetization: userBehavior.monetization,
                    pubContent: userBehavior.pubContent,
                    fetch: userBehavior.fetch
                },
                userErrors: userBehavior.errors
            });
        }

        if (isClassic(pushData)) {
            pushData.code = "show";
            pushData.uid = (0, _generateUUID2.default)();
            return showNotification(pushData, ctx, domain);
        } else {
            var messages = [];
            try {
                if (!(0, _skipper.allow)(getPingLock(pushData))) {
                    (0, _debug.debug)("lockPing", pushData);
                    return;
                }

                messages = await await (0, _getMessages.getMessages)(taskServiceUrl, ctx);
                if (messages.length === 0) {
                    (0, _debug.debug)("onMessageEmptyError", { messages: messages, payload: pushData });
                    (0, _seveUserBehavior.saveUserBehavior)('error', {
                        name: 'onMessageEmptyError',
                        // error: {messages:messages, payload:pushData},
                        time: Date.now()
                    });
                    pushData.code = "show";
                    return showNotification(pushData, ctx, domain);
                }
                return Promise.all(messages.map(function (message) {
                    var payload = message.default_payload;
                    payload.nc = notificationsCount;
                    payload.uid = (0, _generateUUID2.default)();
                    if (getPingType(ctx) !== _defaults.PINGTYPE.welcome && payload.new_message.extra.ctx.sfpc && pushData.title !== undefined) {
                        pushData.code = "show";
                        return showNotification(pushData, ctx, domain);
                    }

                    return showNotification(payload, ctx, domain);
                }));
            } catch (e) {
                (0, _debug.debug)("onMessageReceiveError", (0, _error.errorInfo)(e), undefined, undefined, taskServiceUrl);
                var errorObj = (0, _error.errorInfo)(e) || {};
                (0, _seveUserBehavior.saveUserBehavior)('error', {
                    name: 'onMessageReceiveError',
                    // error: errorObj.error ? errorObj.error : errorObj,
                    time: Date.now(),
                    url: taskServiceUrl || ''
                });
                pushData.code = "show";
                return showNotification(pushData, ctx, domain);
            }
        }
    } catch (err) {
        switch (err) {
            case _error.PUSH_DATA_PARSE_ERROR:
                (0, _debug.debug)("onPushParseError", e);
                var errorObjE = (0, _error.errorInfo)(err) || {};
                (0, _seveUserBehavior.saveUserBehavior)('error', {
                    name: 'onPushParseError',
                    // error: errorObjE.error ? errorObjE.error : errorObjE,
                    time: Date.now()
                });
                break;
            case _error.PUSH_DATA_EMPTY_ERROR:
                (0, _debug.debug)("onPushEmptyError", e);
                var _errorObj = (0, _error.errorInfo)(err) || {};
                (0, _seveUserBehavior.saveUserBehavior)('error', {
                    name: 'onPushEmptyError',
                    //   error: errorObj.error ? errorObj.error : errorObj,
                    time: Date.now()
                });
                return processEmptyPushHandler(e);
        }
        throw err;
    }
}

async function showNotification(payload, ctx, domain) {
    var registration = self.registration;
    var messages = (await registration.getNotifications()) || [];
    var isDouble = await isDoubleMessage(messages, payload);

    if (isDouble) {
        (0, _debug.debug)('stopDoubleShow', payload, domain);
        return;
    }

    await (0, _trackDb.setBannerIdBD)(getBannerId(payload));
    await (0, _trackDb.setSendingIdDB)(getSendingId(payload));
    await (0, _seveUserBehavior.saveUserBehavior)('shows');

    if (payload.title === undefined || payload.title === 'undefined') {
        (0, _debug.debug)('onDisplayEmptyContentError', payload, domain);
    }

    return self.registration.showNotification(payload.title, payload.options).then(function () {
        (0, _debug.debug)("show", _extends({}, ctx, {
            "trace_id": payload.trace_id,
            "nc": payload.nc,
            "s": getSendingId(payload),
            "uid": payload.uid
        }), domain);
    }).catch(function (reason) {
        return (0, _debug.debug)('onPushError', { error: reason.message, payload: payload }, domain);
    });
}

function getSendingId(payload) {
    return payload && payload.new_message && payload.new_message.extra && payload.new_message.extra.ctx && payload.new_message.extra.ctx.s || 0;
}

function getPingType(ctx) {
    return ctx && ctx.pt ? ctx.pt : _defaults.PINGTYPE.unknown;
}

function isClassic(pushData) {
    var pt = pushData && pushData.new_message && pushData.new_message.extra && pushData.new_message.extra.ctx && pushData.new_message.extra.ctx.pt || 0;

    return pt === _defaults.PINGTYPE.classic;
}

/***/ }),

/***/ "./src/service-worker/handlers/pushsubscriptionchange.js":
/*!***************************************************************!*\
  !*** ./src/service-worker/handlers/pushsubscriptionchange.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pushSubscriptionChangeHandler = pushSubscriptionChangeHandler;

var _debug = __webpack_require__(/*! ../../utils/debug */ "./src/utils/debug.js");

var _trackDb = __webpack_require__(/*! ../../utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

async function pushSubscriptionChangeHandler(e) {
    var domain = await (0, _trackDb.getDomainDB)();
    (0, _debug.debug)("pushSubscriptionChange", {}, domain);
    console.log(e, "pushSubscriptionChangeHandler");
}

/***/ }),

/***/ "./src/service-worker/handlers/update.js":
/*!***********************************************!*\
  !*** ./src/service-worker/handlers/update.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.checkSwVersionUpdate = checkSwVersionUpdate;

var _debug = __webpack_require__(/*! ../../utils/debug */ "./src/utils/debug.js");

var _push = __webpack_require__(/*! ./push */ "./src/service-worker/handlers/push.js");

var _trackDb = __webpack_require__(/*! ../../utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _error = __webpack_require__(/*! ../../utils/error */ "./src/utils/error.js");

var _subscribe = __webpack_require__(/*! ../../utils/subscribe */ "./src/utils/subscribe.js");

var _urlBase64ToUint8Array = __webpack_require__(/*! ../../utils/urlBase64ToUint8Array */ "./src/utils/urlBase64ToUint8Array.js");

var _urlBase64ToUint8Array2 = _interopRequireDefault(_urlBase64ToUint8Array);

var _seveUserBehavior = __webpack_require__(/*! ../../utils/seveUserBehavior */ "./src/utils/seveUserBehavior.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var swSettingsKey = 'swSettings';

async function checkSwVersionUpdate(e) {
    try {
        var pushData = (0, _push.parseDataFromPushEvent)(e);

        if (!pushData) {
            return;
        }

        var time = new Date().getTime();
        var dbTime = await (0, _trackDb.trackDb)().get(swSettingsKey);
        var day = 86400000; // 1 day in ms

        var domain = await (0, _trackDb.getDomainDB)();
        var scope = self.registration.scope;
        var subscription = await (0, _trackDb.getStoredSubscription)();

        if (time - dbTime > day || dbTime === undefined) {
            if (subscription) {
                var applicationServerKey = (0, _urlBase64ToUint8Array2.default)(subscription.key);
                await (0, _subscribe.managerSubscribe)(self.registration.pushManager, {
                    userVisibleOnly: true,
                    applicationServerKey: applicationServerKey
                });
                await self.registration.update();
                await (0, _trackDb.trackDb)().set(swSettingsKey, time);
                (0, _debug.debug)("onSwUpdate", { db_time: dbTime, scope: scope, payload: e.data.json() }, domain);
            }
        }
    } catch (err) {
        (0, _debug.debug)("onSwUpdateError", _extends({}, (0, _error.errorInfo)(err), { payload: e.data.text() || null }));
        console.error(err);
        var errorObj = (0, _error.errorInfo)(err) || {};
        (0, _seveUserBehavior.saveUserBehavior)('error', {
            name: 'onSwUpdateError',
            // error: errorObj.error ? errorObj.error : errorObj,
            time: Date.now()
        });
        throw err;
    }
}

/***/ }),

/***/ "./src/service-worker/handlers/utils/notificationCount.js":
/*!****************************************************************!*\
  !*** ./src/service-worker/handlers/utils/notificationCount.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getNotificationsCount = getNotificationsCount;
exports.getValidNotifications = getValidNotifications;

var _debug = __webpack_require__(/*! ../../../utils/debug */ "./src/utils/debug.js");

var _error = __webpack_require__(/*! ../../../utils/error */ "./src/utils/error.js");

async function getNotificationsCount(domain) {
    try {
        var registration = self.registration;
        if (!registration) {
            return -1;
        } else {
            return (await getValidNotifications(domain)).length;
        }
    } catch (e) {
        (0, _debug.debug)("onNotificationCountError", (0, _error.errorInfo)(e), domain);
        return -1;
    }
}

async function getValidNotifications(domain) {
    try {
        var registration = self.registration;
        if (!registration) {
            return [];
        }

        return (await registration.getNotifications()) || [];
    } catch (e) {
        (0, _debug.debug)("onNotificationCountError", (0, _error.errorInfo)(e), domain);
        return [];
    }
}

/***/ }),

/***/ "./src/service-worker/handlers/utils/skipper.js":
/*!******************************************************!*\
  !*** ./src/service-worker/handlers/utils/skipper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.allow = allow;
var memoryDate = 0;
var addMemoryDate = function addMemoryDate(date) {
    return memoryDate = date;
};
var getMemoryDate = function getMemoryDate() {
    return memoryDate;
};

function allow(lock) {
    var savedDate = getMemoryDate();

    if (lock && savedDate === 0) {
        addMemoryDate(new Date().getTime());
        return true;
    }

    var d = savedDate + 60 * 1000; // + 1 minute

    return !(lock && savedDate > 0 && d > new Date().getTime());
}

/***/ }),

/***/ "./src/service-worker/handlers/utils/verifySubscription.js":
/*!*****************************************************************!*\
  !*** ./src/service-worker/handlers/utils/verifySubscription.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createSubscription = createSubscription;
exports.setVerifySubscriptionResult = setVerifySubscriptionResult;
exports.verifySubscription = verifySubscription;
exports.ampBroadcastReply = ampBroadcastReply;
exports.ampVerifySubscription = ampVerifySubscription;

var _trackDb = __webpack_require__(/*! ../../../utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _getApplicationKey = __webpack_require__(/*! ../../../utils/http/getApplicationKey */ "./src/utils/http/getApplicationKey.js");

var _subscribe = __webpack_require__(/*! ../../../utils/subscribe */ "./src/utils/subscribe.js");

var _sdk = __webpack_require__(/*! ../../../utils/sdk */ "./src/utils/sdk.js");

var _generateUserContext = __webpack_require__(/*! ../../../utils/generateUserContext */ "./src/utils/generateUserContext.js");

var _debug = __webpack_require__(/*! ../../../utils/debug */ "./src/utils/debug.js");

var _delay = __webpack_require__(/*! ../../../utils/delay */ "./src/utils/delay.js");

var _swapi = __webpack_require__(/*! ../../swapi */ "./src/service-worker/swapi.js");

async function createSubscription(prevSync) {
    var _ref = await (0, _getApplicationKey.getApplicationServerKey)(),
        key_id = _ref.key_id,
        key = _ref.key,
        applicationServerKey = _ref.applicationServerKey;

    var pushSubscription = await (0, _subscribe.managerSubscribe)(self.registration.pushManager, {
        userVisibleOnly: true,
        applicationServerKey: applicationServerKey
    });

    var url = new URL(location.href);
    var userContext = await (0, _generateUserContext.getUserContext)();

    if (userContext.appId === undefined) {
        userContext.appId = url.searchParams.get('nxAppId') || url.searchParams.get('appId') || undefined;
    }

    var domain = await (0, _trackDb.getDomainDB)();

    var subscription = await (0, _subscribe.subscribe)("https://" + domain + _sdk.defaultOptions.subscriptionUrl, {
        pushSubscription: pushSubscription,
        context: userContext,
        key_id: key_id,
        key: key,
        prev_sync: prevSync
    });

    if (subscription.Status === false) {
        (0, _debug.debug)("onUserContext", userContext, domain);
        return {};
    }

    var subscriptionData = _extends({}, pushSubscription.toJSON(), {
        key: key,
        key_id: key_id
    }, subscription, {
        domain: location.hostname
    });

    await (0, _trackDb.storeSubscription)(subscriptionData);
    await (0, _trackDb.storeSubscriptionHistory)(subscriptionData);
    await (0, _trackDb.setFlagNotixSW)(true);
    await (0, _trackDb.setPrevSync)(new Date().getTime());

    return subscriptionData;
}

var verifySubscriptionStarted = false;
var verifySubscriptionResult = void 0;

function setVerifySubscriptionResult(result) {
    verifySubscriptionResult = result;
}

async function verifySubscription(data) {
    var result = await async function () {
        if (verifySubscriptionStarted) {
            while (verifySubscriptionStarted) {
                await (0, _delay.delay)(500);
            }

            return verifySubscriptionResult;
        }

        try {
            verifySubscriptionStarted = true;

            if (Notification.permission !== 'granted') {
                return "permission-denied";
            }

            var domain = await (0, _trackDb.getDomainDB)();
            var time = new Date().getTime();
            var prevSync = await (0, _trackDb.getPrevSync)();
            var day = 86400000; // 1 day in ms
            var storedSubscription = await (0, _trackDb.getStoredSubscription)();

            if (time - prevSync > day || !storedSubscription) {
                var subscriptionData = await createSubscription(prevSync);
                (0, _debug.debug)("onSubscriptionDoneDayAgo", subscriptionData, domain);
            } else {
                (0, _debug.debug)("onAlreadySubscribed", {}, domain);
                return "already-subscribed";
            }

            return "ok";
        } finally {
            verifySubscriptionStarted = false;
        }
    }();

    setVerifySubscriptionResult(result);

    return result;
}

function ampBroadcastReply(command, payload) {
    self.clients.matchAll().then(function (clients) {
        for (var i = 0; i < clients.length; i++) {
            var client = clients[i];
            client. /*OK*/postMessage({
                command: command,
                payload: payload
            });
        }
    });
}

async function ampVerifySubscription() {
    var retrievedPushSubscription = null;
    self.registration.pushManager.getSubscription().then(function (pushSubscription) {
        retrievedPushSubscription = pushSubscription;
        if (!pushSubscription) {
            return null;
        } else {
            return self.registration.pushManager.permissionState(pushSubscription.options);
        }
    }).then(function (permissionStateOrNull) {
        if (permissionStateOrNull == null) {
            ampBroadcastReply(_swapi.AmpWorkerMessengerCommand.AMP_SUBSCRIPTION_STATE, false);
        } else {
            var isSubscribed = !!retrievedPushSubscription && permissionStateOrNull === 'granted';
            ampBroadcastReply(_swapi.AmpWorkerMessengerCommand.AMP_SUBSCRIPTION_STATE, !!isSubscribed);
        }
    });
}

/***/ }),

/***/ "./src/service-worker/swapi.js":
/*!*************************************!*\
  !*** ./src/service-worker/swapi.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serviceWorkerApi = exports.AmpWorkerMessengerCommand = undefined;
exports.ServiceWorkerApi = ServiceWorkerApi;

var _debug = __webpack_require__(/*! ../utils/debug */ "./src/utils/debug.js");

//// TODO: refactor this file !!!!

var AmpWorkerMessengerCommand = exports.AmpWorkerMessengerCommand = {
    AMP_SUBSCRIPTION_STATE: "amp-web-push-subscription-state",
    AMP_SUBSCRIBE: "amp-web-push-subscribe"
};

function ServiceWorkerApi(reg) {

    async function sendData(cmd) {
        var controller = void 0;

        if (!reg) {
            // $FlowFixMe
            controller = navigator.serviceWorker.controller;

            if (!controller) {
                // $FlowFixMe
                reg = await navigator.serviceWorker.getRegistration();
                if (reg) {
                    controller = reg.waiting || reg.installing || reg.active;
                }
            }
        } else {
            controller = reg.waiting || reg.installing || reg.active;
        }

        if (!controller) {
            (0, _debug.debug)("onServiceWorkerFailRegister", {}, "");
        }

        return new Promise(function (resolve, reject) {
            var channel = new MessageChannel();
            channel.port1.onmessage = function (event) {
                // $FlowFixMe
                channel.port1.onmessage = null;

                if (event.data && event.data.error) {
                    return reject(event.data.error);
                } else {
                    try {
                        return resolve(JSON.parse(String(event.data)));
                    } catch (e) {
                        return reject(e);
                    }
                }
            };
            // $FlowFixMe
            controller.postMessage(JSON.stringify(cmd), [channel.port2]);
        });
    }

    async function exec(command) {
        var pkg = await sendData(command);

        if (pkg.ok === true) {
            return pkg.result;
        } else {
            throw new Error(pkg.error);
        }
    }

    return {
        verifySubscription: async function verifySubscription() {
            return exec({
                cmd: "verifySubscription"
            });
        }
    };
}

var serviceWorkerApi = exports.serviceWorkerApi = ServiceWorkerApi();

/***/ }),

/***/ "./src/utils/clientHints.js":
/*!**********************************!*\
  !*** ./src/utils/clientHints.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHighEntropyValues = getHighEntropyValues;
async function getHighEntropyValues() {
    if (!navigator) {
        return Promise.resolve(null);
    }

    if (!navigator.userAgentData) {
        return Promise.resolve(null);
    }

    if (!navigator.userAgentData.getHighEntropyValues || typeof navigator.userAgentData.getHighEntropyValues !== 'function') {
        return Promise.resolve(null);
    }

    try {
        var clientHints = await navigator.userAgentData.getHighEntropyValues(['model', 'platform', 'platformVersion', 'mobile']);

        return {
            os: clientHints.platform,
            os_version: clientHints.platformVersion,
            model: clientHints.model,
            mobile: clientHints.mobile
        };
    } catch (e) {
        return Promise.resolve(null);
    }
}

/***/ }),

/***/ "./src/utils/debug.js":
/*!****************************!*\
  !*** ./src/utils/debug.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.debug = debug;
exports.debugTotal = debugTotal;
exports.setDebugHandler = setDebugHandler;
exports.setDebugTotalHandler = setDebugTotalHandler;
exports.updateDebugContext = updateDebugContext;

var _fetchJSON = __webpack_require__(/*! ./http/fetchJSON */ "./src/utils/http/fetchJSON.js");

var _defaults = __webpack_require__(/*! ../defaults */ "./src/defaults.js");

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _version = __webpack_require__(/*! ../version */ "./src/version.js");

var _generateUserContext = __webpack_require__(/*! ./generateUserContext */ "./src/utils/generateUserContext.js");

var _prepareBehaviorDataToSend = __webpack_require__(/*! ./prepareBehaviorDataToSend */ "./src/utils/prepareBehaviorDataToSend.js");

var _clientHints = __webpack_require__(/*! ./clientHints */ "./src/utils/clientHints.js");

var _push = __webpack_require__(/*! ../service-worker/handlers/push */ "./src/service-worker/handlers/push.js");

var _debugStorageDb = __webpack_require__(/*! ./indexeddb/debugStorageDb */ "./src/utils/indexeddb/debugStorageDb.js");

var MAX_DEBUG_STORAGE_TO_SEND = 30;
var MAX_DEBUG_STORAGE_DB = 1000;

var debugContext = {};

var defaultHandler = function defaultHandler(tag, context) {};

var defaultDebugTotalHandler = function defaultDebugTotalHandler(log) {};

function eventHandler(code, context, domain, isDisableConsoleDebug) {
    var data = _extends({}, context, { code: code });

    try {
        var sendBeacon = navigator.sendBeacon ? navigator.sendBeacon.bind(navigator) : null;
        if (sendBeacon) {
            if (!isDisableConsoleDebug) {
                console.log("sendBeacon", JSON.stringify(data, null, 4));
            }
            var content = new Blob([JSON.stringify(data)], { type: 'application/json' });
            sendBeacon((0, _defaults.getEventHandler)(domain), content);
        } else {
            (0, _fetchJSON.fetchJSON)((0, _defaults.getEventHandler)(domain), "POST", data);
        }
    } catch (e) {}
}

var debugLog = [];

async function debug(tag) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var domain = arguments[2];
    var isDisableLogTag = arguments[3];
    var taskUrl = arguments[4];

    var context = _extends({}, data, { timeOrigin: performance.now(), sw_version: _version.swVersion });
    var userContext = (await (0, _generateUserContext.getUserContext)()) || {};

    await (0, _debugStorageDb.setDebugStorage)(Date.now() + "-" + tag, Date.now() + "-" + tag);
    var debugStorage = await (0, _debugStorageDb.getDebugStorage)();
    if (debugStorage && debugStorage.length >= MAX_DEBUG_STORAGE_DB) {
        await (0, _debugStorageDb.clearDebugStorage)();
    }
    if (debugStorage && debugStorage.length >= MAX_DEBUG_STORAGE_TO_SEND) {
        debugStorage.splice(0, debugStorage.length - MAX_DEBUG_STORAGE_TO_SEND);
    }
    context.debugStorageHistory = debugStorage;

    if (tag === "onMessageReceiveError" && taskUrl) {
        context.urlFetchError = taskUrl;
    }

    var isShouldSendExtendedData = await (0, _trackDb.getSendExtendedDataFlag)();

    if (isShouldSendExtendedData) {
        var userBehavior = await (0, _trackDb.getUserBehavior)();
        userBehavior = (0, _prepareBehaviorDataToSend.prepareBehaviorDataToSend)(userBehavior);
        context = _extends({}, context, {
            userActivity: {
                monetization: userBehavior.monetization,
                pubContent: userBehavior.pubContent,
                fetch: userBehavior.fetch
            },
            userErrors: userBehavior.errors
        });
    }

    if (userContext.appId) {
        context.appId = userContext.appId;
    }

    var isDisableConsoleDebug = userContext.disableConsole || isDisableLogTag;

    if (!isDisableConsoleDebug) {
        self.console.log(tag, data);
    }

    if (!context.fallback_domain) {
        context.fallback_domain = (0, _push.getFallBackDomain)(data) || _defaults.DEFAULTS.defaultDomain;
    }

    try {
        var clientHints = await (0, _clientHints.getHighEntropyValues)();
        if (clientHints) {
            context.client_hints = clientHints;
        }
    } catch (e) {}

    eventHandler(tag, context, domain, isDisableConsoleDebug);
    defaultHandler(tag, data);
    debugLog.push({ tag: tag, context: context });
}

function debugTotal() {
    defaultDebugTotalHandler(debugLog);
}

function setDebugHandler(handler) {
    defaultHandler = handler;
}

function setDebugTotalHandler(handler) {
    defaultDebugTotalHandler = handler;
}

function updateDebugContext(context) {
    debugContext = _extends({}, debugContext, context);
}

/***/ }),

/***/ "./src/utils/delay.js":
/*!****************************!*\
  !*** ./src/utils/delay.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.delay = delay;
async function delay(timeout) {
    return new Promise(function (resolve) {
        setTimeout(resolve, timeout);
    });
}

/***/ }),

/***/ "./src/utils/error.js":
/*!****************************!*\
  !*** ./src/utils/error.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapCustomError = wrapCustomError;
exports.errorInfo = errorInfo;
var PUSH_DATA_PARSE_ERROR = exports.PUSH_DATA_PARSE_ERROR = new Error("Push parse error");
var PUSH_DATA_EMPTY_ERROR = exports.PUSH_DATA_EMPTY_ERROR = new Error("Push data empty");
var INSTALL_ERROR = exports.INSTALL_ERROR = new Error("install error:");

function wrapCustomError(customError, error) {
    if (error instanceof Error) {
        customError.stack = error.stack;
        customError.message = customError.message + ":" + error.message;
    }
    return customError;
}

function errorInfo(error) {
    if (error instanceof Error) {
        var msg = {
            error: error.toString(),
            stack: error.stack
        };
        try {
            if (Error.captureStackTrace) {
                Error.captureStackTrace(msg, errorInfo);
            }
        } catch (e) {}
        return msg;
    }
    return error;
}

/***/ }),

/***/ "./src/utils/generateUUID.js":
/*!***********************************!*\
  !*** ./src/utils/generateUUID.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function () {
    var d = new Date().getTime();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
};

/***/ }),

/***/ "./src/utils/generateUserContext.js":
/*!******************************************!*\
  !*** ./src/utils/generateUserContext.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.generateUserContext = generateUserContext;
exports.getUserContext = getUserContext;

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _getOptionsFromUrl = __webpack_require__(/*! ./getOptionsFromUrl */ "./src/utils/getOptionsFromUrl.js");

async function generateUserContext(options) {
    var context = {
        appId: options.appId,
        user: options.user,
        audiences: options.audiences,
        var: options.var,
        ymid: options.ymid,
        ymid2: options.ymid2,
        var_1: options.var_1,
        var_2: options.var_2,
        var_3: options.var_3,
        var_4: options.var_4,
        var_5: options.var_5,
        land_id: options.land_id,
        is_already_subscribed: options.is_already_subscribed,
        disableConsole: options.disableConsole
        // categories: options.categories,
    };

    await (0, _trackDb.trackDb)().set("context", options);

    return context;
}

var getAdditionalFieldsToSend = function getAdditionalFieldsToSend(options) {
    return {
        var: options.var,
        ymid: options.ymid,
        ymid2: options.ymid2,
        var_1: options.var_1,
        var_2: options.var_2,
        var_3: options.var_3,
        var_4: options.var_4,
        var_5: options.var_5,
        land_id: options.land_id,
        user: options.user,
        audiences: options.audiences,
        is_already_subscribed: options.is_already_subscribed
        //  categories: options.categories,
    };
};
async function getUserContext() {
    var options = (await (0, _trackDb.trackDb)().get("context")) || {};

    // If external options is exist, return it
    if (self.options && Object.keys(self.options).length !== 0 && self.options.appId) {
        return _extends({}, self.options, getAdditionalFieldsToSend(options));
    }

    // If options does not exist in IndexedDB or as external params,
    // go to parse the url to find appId as GET param
    else if (Object.keys(options).length === 0) {
            var activeSW = self.registration && self.registration.active;
            if (activeSW) {
                var u = new URL(self.registration.active.scriptURL);
                return (0, _getOptionsFromUrl.getOptionsFromUrl)(u);
            }
            return {};
        }

    // Finally, if data exist in IndexedDB return it
    return {
        appId: options.appId,
        user: options.user,
        audiences: options.audiences,
        var: options.var,
        ymid: options.ymid,
        ymid2: options.ymid2,
        var_1: options.var_1,
        var_2: options.var_2,
        var_3: options.var_3,
        var_4: options.var_4,
        var_5: options.var_5,
        land_id: options.land_id,
        is_already_subscribed: options.is_already_subscribed,
        disableConsole: options.disableConsole,
        categories: options.categories
    };
}

/***/ }),

/***/ "./src/utils/getOptionsFromUrl.js":
/*!****************************************!*\
  !*** ./src/utils/getOptionsFromUrl.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.getOptionsFromUrl = getOptionsFromUrl;
function getOptionsFromUrl(u) {
    var urlParams = u.search.slice(1).split('&').reduce(function (urlParams, kw) {
        var _kw$split = kw.split('='),
            _kw$split2 = _slicedToArray(_kw$split, 2),
            k = _kw$split2[0],
            v = _kw$split2[1];

        urlParams[k] = v;
        return urlParams;
    }, {});

    // All tag options that are required for resubscribe/parasite work should be defined here
    var supportedParamsMap = [["appId", "appId", String]];

    var optionsOverride = supportedParamsMap.reduce(function (optionsOverride, _ref) {
        var _ref2 = _slicedToArray(_ref, 3),
            name = _ref2[0],
            optName = _ref2[1],
            converter = _ref2[2];

        if (urlParams[name] !== undefined) {
            optionsOverride[optName] = converter(urlParams[name]);
        }

        return optionsOverride;
    }, {});
    console.log("getOptionsFromUrl", optionsOverride);
    return optionsOverride;
}

/***/ }),

/***/ "./src/utils/hasTimePassed.js":
/*!************************************!*\
  !*** ./src/utils/hasTimePassed.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var hasTimePassed = exports.hasTimePassed = function hasTimePassed(date) {
    var time = 1000 * 5 * 60;
    var timeAgo = Date.now() - time;
    return date < timeAgo;
};

/***/ }),

/***/ "./src/utils/http/fetchJSON.js":
/*!*************************************!*\
  !*** ./src/utils/http/fetchJSON.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.fetchJSON = fetchJSON;

var _defaults = __webpack_require__(/*! ../../defaults */ "./src/defaults.js");

var _error = __webpack_require__(/*! ../error */ "./src/utils/error.js");

var _seveUserBehavior = __webpack_require__(/*! ../seveUserBehavior */ "./src/utils/seveUserBehavior.js");

var _trackDb = __webpack_require__(/*! ../indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _prepareBehaviorDataToSend = __webpack_require__(/*! ../prepareBehaviorDataToSend */ "./src/utils/prepareBehaviorDataToSend.js");

var createFallbackHandler = function createFallbackHandler(url, fallbackDomain) {
    return url.endsWith(_defaults.DEFAULTS.eventHandler) ? (0, _defaults.getEventHandler)(fallbackDomain) : (0, _defaults.getTaskHandler)(fallbackDomain);
};

var fetchRequest = async function fetchRequest(url, method, body) {
    return await fetch(url, {
        method: method,
        credentials: 'include',
        body: body,
        headers: method === 'POST' ? {
            'Content-Type': 'application/json'
        } : undefined
    });
};

var fetchMethod = async function fetchMethod(url, method, body, data) {
    var r = void 0;

    var fallbackUrl = "";
    // $FlowFixMe
    if (data && data.fallback_domain && typeof data.fallback_domain === 'string') {
        // $FlowFixMe
        fallbackUrl = createFallbackHandler(url, data.fallback_domain);
    }

    try {
        r = await fetchRequest(url, method, body);
        if (!r.ok) {
            await (0, _seveUserBehavior.saveUserBehavior)('error', {
                statusText: r.statusText,
                status: r.status,
                url: r.url,
                time: Date.now()
            });
        }
    } catch (e) {
        var errorObj = (0, _error.errorInfo)(e) || {};
        await (0, _seveUserBehavior.saveUserBehavior)('error', {
            name: errorObj.error,
            url: url,
            time: Date.now()
        });

        var userBehavior = await (0, _trackDb.getUserBehavior)();
        userBehavior = (0, _prepareBehaviorDataToSend.prepareBehaviorDataToSend)(userBehavior);

        var bodyWithErrors = {};

        if (body) {
            bodyWithErrors = _extends({}, JSON.parse(body), { userErrors: userBehavior.errors });
        }

        fetchRequest("https://" + _defaults.DEFAULTS.defaultDomain + _defaults.DEFAULTS.eventHandler, 'POST', JSON.stringify({
            code: 'failFetchErrorRequest',
            url: url,
            method: method,
            data: _extends({}, data, { userErrors: userBehavior.errors }),
            error: (0, _error.errorInfo)(e)
        }));

        if (fallbackUrl) {
            try {
                r = await fetchRequest(fallbackUrl, method, JSON.stringify(bodyWithErrors));
            } catch (e) {
                var defaultFallbackUrl = createFallbackHandler(url, _defaults.DEFAULTS.defaultDomain);
                r = await fetchRequest(defaultFallbackUrl, method, JSON.stringify(bodyWithErrors));
            }
        }
    }

    return r;
};

async function fetchJSON(url, method, data) {

    if (method === 'POST' && data && (typeof data === "undefined" ? "undefined" : _typeof(data)) === 'object') {
        try {
            data.timeOrigin = performance.now();
        } catch (e) {}
    }
    var body = data ? JSON.stringify(data) : undefined;
    var r = await fetchMethod(url, method, body, data);

    var json = null;
    // $FlowFixMe
    var responseText = await r.text();

    try {
        json = JSON.parse(responseText);
    } catch (e) {
        // $FlowFixMe
        throw new Error(method + ": " + url + "; body: " + String(body) + "; http-status: " + r.status + "; responseText: " + responseText + "; stack: " + String(e.stack));
    }
    if (json && json.status !== true && json.status !== undefined) {
        switch (json.code) {
            default:
                throw new Error(method + ": " + url + "; body: " + String(body) + "; status: " + String(json.status) + "; json: " + JSON.stringify(json));
        }
    }
    return json;
}

/***/ }),

/***/ "./src/utils/http/getApplicationKey.js":
/*!*********************************************!*\
  !*** ./src/utils/http/getApplicationKey.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getApplicationServerKey = getApplicationServerKey;

var _urlBase64ToUint8Array = __webpack_require__(/*! ../urlBase64ToUint8Array */ "./src/utils/urlBase64ToUint8Array.js");

var _urlBase64ToUint8Array2 = _interopRequireDefault(_urlBase64ToUint8Array);

var _fetchJSON = __webpack_require__(/*! ./fetchJSON */ "./src/utils/http/fetchJSON.js");

var _defaults = __webpack_require__(/*! ../../defaults */ "./src/defaults.js");

var _trackDb = __webpack_require__(/*! ../indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: url as parameter ?
async function getApplicationServerKey() {
    var domain = await (0, _trackDb.getDomainDB)();
    var json = await (0, _fetchJSON.fetchJSON)("https://" + domain + _defaults.DEFAULTS.keyHandler + "?id=" + location.hostname, 'GET');
    var applicationServerKey = (0, _urlBase64ToUint8Array2.default)(json.key);
    return {
        key_id: json.id,
        key: json.key,
        applicationServerKey: applicationServerKey
    };
}

/***/ }),

/***/ "./src/utils/http/getMessages.js":
/*!***************************************!*\
  !*** ./src/utils/http/getMessages.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getMessages = getMessages;
exports.getMessagesWithRetry = getMessagesWithRetry;

var _fetchJSON = __webpack_require__(/*! ./fetchJSON */ "./src/utils/http/fetchJSON.js");

var _debug = __webpack_require__(/*! ../debug */ "./src/utils/debug.js");

var _seveUserBehavior = __webpack_require__(/*! ../seveUserBehavior */ "./src/utils/seveUserBehavior.js");

var _error = __webpack_require__(/*! ../error */ "./src/utils/error.js");

async function getMessages(taskUrl, ctx) {
    return await (0, _fetchJSON.fetchJSON)(taskUrl, "POST", ctx);
}

async function getMessagesWithRetry(taskUrl, retryCount, timeout, ctx) {

    var lastError = null;

    for (var i = 0; i < retryCount; i++) {
        if (i > 0) {
            await new Promise(function (r) {
                return setTimeout(r, timeout);
            });
        }
        try {
            var r = await (0, _fetchJSON.fetchJSON)(taskUrl, "POST", ctx);
            if (i > 0) {
                (0, _debug.debug)("recoverFetch", { count: i, timeout: timeout, lastError: lastError });
            }
            return r;
        } catch (e) {
            lastError = e;
            console.warn("fetch network error: " + e);
            var errorObj = (0, _error.errorInfo)(e) || {};
            (0, _seveUserBehavior.saveUserBehavior)('error', {
                name: 'fetch network error',
                url: taskUrl,
                // error: errorObj.error ? errorObj.error : errorObj,
                time: Date.now()
            });
        }
    }

    throw new Error("getMessagesWithRetry " + String(lastError));
}

/***/ }),

/***/ "./src/utils/http/sendSubscription.js":
/*!********************************************!*\
  !*** ./src/utils/http/sendSubscription.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sendSubscription = sendSubscription;

var _fetchJSON = __webpack_require__(/*! ./fetchJSON */ "./src/utils/http/fetchJSON.js");

async function sendSubscription(_ref) {
    var url = _ref.url,
        data = _ref.data;

    return await (0, _fetchJSON.fetchJSON)("" + url, 'POST', data);
}

/***/ }),

/***/ "./src/utils/indexeddb/debugStorageDb.js":
/*!***********************************************!*\
  !*** ./src/utils/indexeddb/debugStorageDb.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debugStorageDb = undefined;
exports.setDebugStorage = setDebugStorage;
exports.getDebugStorage = getDebugStorage;
exports.clearDebugStorage = clearDebugStorage;

var _openDb = __webpack_require__(/*! ./openDb */ "./src/utils/indexeddb/openDb.js");

var debugStorageDb = exports.debugStorageDb = function debugStorageDb() {
  var swDatabase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    "name": "debugStorageDb",
    "version": 1,
    "trackStore": "debugStorage"
  };

  return {
    getAll: async function getAll() {
      var db = await (0, _openDb.openDb)(swDatabase);
      return await db.getAll();
    },

    set: async function set(key, val) {
      var db = await (0, _openDb.openDb)(swDatabase);
      return await db.set(key, val);
    },

    clear: async function clear() {
      var db = await (0, _openDb.openDb)(swDatabase);
      return await db.clear();
    }
  };
};

async function setDebugStorage(key, tag) {
  await debugStorageDb().set(key, tag);
}

async function getDebugStorage() {
  return (await debugStorageDb().getAll()) || {};
}

async function clearDebugStorage() {
  return await debugStorageDb().clear();
}

/***/ }),

/***/ "./src/utils/indexeddb/openDb.js":
/*!***************************************!*\
  !*** ./src/utils/indexeddb/openDb.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.openDb = openDb;
function openDb(config, createIndexes) {
    return new Promise(function (resolve, reject) {

        var request = self.indexedDB.open(config.name, config.version);

        request.onupgradeneeded = function (event) {
            var db = event.target.result;
            var version = parseInt(config.version);

            switch (version) {
                case 1:
                    var _objectStore = db.createObjectStore(config.trackStore, {
                        autoIncrement: config.autoIncrement,
                        keyPath: config.keyPath
                    });
                    if (createIndexes) {
                        createIndexes(_objectStore, version);
                    }
                    break;
            }
        };

        request.onsuccess = function () {
            return resolve(request.result);
        };
        request.onerror = function (event) {
            return reject(event.errorCode);
        };
    }).then(function (db) {
        function execute(callback) {
            var attr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'readwrite';

            return new Promise(function (resolve, reject) {
                var transaction = db.transaction(config.trackStore, attr);
                var objectStore = transaction.objectStore(config.trackStore);
                try {
                    var result = callback(objectStore);
                    result.onsuccess = function (event) {
                        return resolve(event.target.result);
                    };
                    result.onerror = reject;
                } catch (e) {
                    console.warn(e);
                    reject(e);
                }
            });
        }
        return {
            add: async function add(value) {
                return await execute(function (objectStore) {
                    return objectStore.add(value);
                });
            },
            put: async function put(value) {
                return await execute(function (objectStore) {
                    return objectStore.put(value);
                });
            },
            get: async function get(key) {
                return await execute(function (objectStore) {
                    return objectStore.get(key);
                }, 'readonly');
            },
            set: async function set(key, value) {
                return await execute(function (objectStore) {
                    return objectStore.put(value, key);
                });
            },
            getAll: async function getAll() {
                return await execute(function (objectStore) {
                    return objectStore.getAll();
                });
            },
            clear: async function clear() {
                return await execute(function (objectStore) {
                    return objectStore.clear();
                });
            },
            delete: async function _delete(key) {
                return await execute(function (objectStore) {
                    return objectStore.delete(key);
                });
            },
            deleteByIndex: async function deleteByIndex(index, key) {
                var primaryKey = await execute(function (objectStore) {
                    return objectStore.index(index).getKey(key);
                });
                return await await execute(function (objectStore) {
                    return objectStore.delete(primaryKey);
                });
            }
        };
    });
}

/***/ }),

/***/ "./src/utils/indexeddb/trackDb.js":
/*!****************************************!*\
  !*** ./src/utils/indexeddb/trackDb.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oaidDb = exports.trackDb = undefined;
exports.getFlagNotixSW = getFlagNotixSW;
exports.setFlagNotixSW = setFlagNotixSW;
exports.setEventsAlreadyAdded = setEventsAlreadyAdded;
exports.getEventsAlreadyAdded = getEventsAlreadyAdded;
exports.storeSubscription = storeSubscription;
exports.setTimeVisit = setTimeVisit;
exports.setUnsubscribedState = setUnsubscribedState;
exports.setUserDB = setUserDB;
exports.getUserDB = getUserDB;
exports.getUnsubscribedState = getUnsubscribedState;
exports.getTimeVisit = getTimeVisit;
exports.setDomainDB = setDomainDB;
exports.setPrevSync = setPrevSync;
exports.setPingDomainDB = setPingDomainDB;
exports.setUserBehavior = setUserBehavior;
exports.setSendingIdDB = setSendingIdDB;
exports.setBannerIdBD = setBannerIdBD;
exports.setSendExtendedDataFlag = setSendExtendedDataFlag;
exports.getSendExtendedDataFlag = getSendExtendedDataFlag;
exports.getBannerIdBD = getBannerIdBD;
exports.getSendingIdDB = getSendingIdDB;
exports.getUserBehavior = getUserBehavior;
exports.getDomainDB = getDomainDB;
exports.getDomainDBForAudiences = getDomainDBForAudiences;
exports.getPrevSync = getPrevSync;
exports.getPingDomainDB = getPingDomainDB;
exports.storeSubscriptionHistory = storeSubscriptionHistory;
exports.getStoredSubscription = getStoredSubscription;
exports.getStoredSubscriptionHistory = getStoredSubscriptionHistory;

var _openDb = __webpack_require__(/*! ./openDb */ "./src/utils/indexeddb/openDb.js");

var _defaults = __webpack_require__(/*! ../../defaults */ "./src/defaults.js");

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var userBehaviorTemplate = {
    monetization: {
        clicks: [],
        shows: [],
        closes: []
    },
    pubContent: {
        clicks: [],
        shows: [],
        closes: []
    },
    fetch: [],
    errors: []
};

var trackDb = exports.trackDb = function trackDb() {
    var swDatabase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        "name": "swDatabase",
        "version": 1,
        "trackStore": "trackStore"
    };

    return {
        get: async function get(key) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.get(key);
        },

        set: async function set(key, val) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.set(key, val);
        },

        delete: async function _delete(key) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.delete(key);
        }
    };
};

var oaidDb = exports.oaidDb = function oaidDb() {
    var swDatabase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        name: "oaidDb",
        version: 1,
        trackStore: "oaidStore",
        keyPath: "ts"
    };

    return {
        get: async function get() {
            var db = await (0, _openDb.openDb)(swDatabase);
            var oaids = await db.getAll();
            return oaids.length > 0 ? oaids[0].oaid : undefined;
        },

        set: async function set(oaid) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.put({
                oaid: oaid,
                ts: Number(new Date())
            });
        },
        getAll: async function getAll() {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.getAll();
        }

    };
};
async function getFlagNotixSW() {
    return await trackDb().get("isHasNotixSW");
}

async function setFlagNotixSW(isSubscribed) {
    await trackDb().set("isHasNotixSW", isSubscribed);
}

async function setEventsAlreadyAdded(value) {
    await trackDb().set("eventsAlreadyAdded", value);
}

async function getEventsAlreadyAdded() {
    return await trackDb().get("eventsAlreadyAdded");
}

async function storeSubscription(data) {
    await trackDb().set("subscription", data);
}

async function setTimeVisit(time) {
    await trackDb().set("time_visit", time);
}

async function setUnsubscribedState(state) {
    await trackDb().set("unsubscribed_state", state);
}

async function setUserDB(user) {
    await trackDb().set("user", user);
}

async function getUserDB() {
    return (await trackDb().get("user")) || null;
}

async function getUnsubscribedState() {
    return (await trackDb().get("unsubscribed_state")) || false;
}

async function getTimeVisit() {
    return await trackDb().get("time_visit");
}

async function setDomainDB(domain) {
    await trackDb().set("domain", domain);
}

async function setPrevSync(v) {
    await trackDb().set("prev_sync", v);
}

async function setPingDomainDB(domain) {
    await trackDb().set("domain_ping", domain);
}

async function setUserBehavior(data) {
    await trackDb().set("userBehavior", data);
}

async function setSendingIdDB(id) {
    await trackDb().set("sendingId", id);
}

async function setBannerIdBD(id) {
    await trackDb().set("bannerId", id);
}

async function setSendExtendedDataFlag(flag) {
    await trackDb().set("sendExtendedDataFlag", flag);
}

async function getSendExtendedDataFlag() {
    return await trackDb().get("sendExtendedDataFlag");
}

async function getBannerIdBD() {
    return await trackDb().get("bannerId");
}

async function getSendingIdDB() {
    return (await trackDb().get("sendingId")) || 0;
}

async function getUserBehavior() {
    return (await trackDb().get("userBehavior")) || userBehaviorTemplate;
}

async function getDomainDB() {
    return (await trackDb().get("domain")) || _defaults.DEFAULTS.defaultDomain;
}

async function getDomainDBForAudiences() {
    return (await trackDb().get("domain")) || "";
}

async function getPrevSync() {
    return (await trackDb().get("prev_sync")) || 0;
}

async function getPingDomainDB() {
    return (await trackDb().get("domain_ping")) || (await getDomainDB());
}

async function storeSubscriptionHistory(data) {
    var h = [];
    var store = await trackDb().get("subscription_history");

    var needStore = true;
    if (store) {
        needStore = !store.filter(function (item) {
            return item.endpoint === data.endpoint;
        }).length > 0;
        h.push.apply(h, _toConsumableArray(store));
    }

    if (needStore) {
        h.push(data);
    }

    await trackDb().set("subscription_history", h);
}

async function getStoredSubscription() {
    return await trackDb().get("subscription");
}

async function getStoredSubscriptionHistory() {
    return await trackDb().get("subscription_history");
}

/***/ }),

/***/ "./src/utils/prepareBehaviorDataToSend.js":
/*!************************************************!*\
  !*** ./src/utils/prepareBehaviorDataToSend.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.prepareBehaviorDataToSend = prepareBehaviorDataToSend;

var _error = __webpack_require__(/*! ./error */ "./src/utils/error.js");

function prepareBehaviorDataToSend(data) {
    var MAX_LENGTH = 30;

    var pubClicks = data && data.pubContent && data.pubContent.clicks && data.pubContent.clicks.map(function (item) {
        return { id: item.sendingId, ts: item.timestamp };
    });
    var pubShows = data && data.pubContent && data.pubContent.shows && data.pubContent.shows.map(function (item) {
        return { id: item.sendingId, ts: item.timestamp };
    });
    var pubCloses = data && data.pubContent && data.pubContent.closes && data.pubContent.closes.map(function (item) {
        return { id: item.sendingId, ts: item.timestamp };
    });
    var monetizationClicks = data && data.monetization && data.monetization.clicks && data.monetization.clicks.map(function (item) {
        return { id: item.bannerId, ts: item.timestamp };
    });
    var monetizationShows = data && data.monetization && data.monetization.shows && data.monetization.shows.map(function (item) {
        return { id: item.bannerId, ts: item.timestamp };
    });
    var monetizationCloses = data && data.monetization && data.monetization.closes && data.monetization.closes.map(function (item) {
        return { id: item.bannerId, ts: item.timestamp };
    });
    var fetches = data && data.fetch && data.fetch.map(function (item) {
        return { url: item.url, ts: item.timestamp };
    });

    var errors = data && data.errors && data.errors.map(function (item) {
        var error = (0, _error.errorInfo)(item.error);
        var itemError = _extends({}, item);
        if (item.error) {
            itemError.error = error.error ? error.error : error;
            if (typeof itemError.error === "string") {
                itemError.error = itemError.error.substr(0, 50);
            }
        }
        return itemError;
    });

    return {
        errors: errors ? errors.slice(errors.length - 50) : [],
        fetch: fetches ? fetches.slice(fetches.length - MAX_LENGTH) : [],
        pubContent: {
            clicks: pubClicks ? pubClicks.slice(pubClicks.length - MAX_LENGTH) : [],
            shows: pubShows ? pubShows.slice(pubShows.length - MAX_LENGTH) : [],
            closes: pubCloses ? pubCloses.slice(pubCloses.length - MAX_LENGTH) : []
        },
        monetization: {
            clicks: monetizationClicks ? monetizationClicks.slice(monetizationClicks.length - MAX_LENGTH) : [],
            shows: monetizationShows ? monetizationShows.slice(monetizationShows.length - MAX_LENGTH) : [],
            closes: monetizationCloses ? monetizationCloses.slice(monetizationCloses.length - MAX_LENGTH) : []
        }
    };
}

/***/ }),

/***/ "./src/utils/sdk.js":
/*!**************************!*\
  !*** ./src/utils/sdk.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var defaultOptions = exports.defaultOptions = {
    loadSettings: true,
    appId: "xxx",
    installFromSw: true,
    subscriptionUrl: "/subscribe",
    sw: {
        url: "/sw.enot.js"
    },
    waitUserActivityBeforeRequestPermission: false,
    ext_id: null,
    user: null,
    prerequest: {
        frequency: 1,
        capping: 0,
        afterCloseDelay: 1
    },
    delay: 0,
    skeleton: "/ent/current/skeleton.json",
    defaultSkinSource: "/ent/current/default.html",
    skinSource: "",
    categoriesSkinSource: "/ent/current/categories.html",
    sliderSource: "/ent/current/slider-skin.html",
    bellSource: "/ent/current/bell-skin.html",
    categories: "{}",
    categoriesSelect: null,
    defaultTextSource: "/ent/current/default.json",
    categoriesTextSource: "/ent/current/categories.json",
    bellTextSource: "/ent/current/bell.json",
    textSource: "",
    texts: {},
    use_custom_texts: false,
    popup: {
        url: "/ent/current/popup.html",
        title: "",
        height: 0,
        width: 0
    }
};

var options = {};


var callbacks = {};

var mutualExcludedEvents = ['permissionDefault', 'permissionAllowed', 'permissionDenied', 'alreadySubscribed'];

var call = function call(eventName) {
    return function (payload) {
        // Promise to call function on the next loop
        Promise.resolve().then(function () {
            if (callbacks[eventName] instanceof Function) {
                try {
                    callbacks[eventName](payload);
                } catch (e) {
                    console.warn(e);
                } finally {
                    delete callbacks[eventName];
                    if (mutualExcludedEvents.indexOf(eventName) >= 0) {
                        mutualExcludedEvents.forEach(function (eventName) {
                            delete callbacks[eventName];
                        });
                    }
                }
            }
        });
    };
};

var setCall = function setCall(eventName) {
    return function (cb) {
        callbacks[eventName] = cb;
    };
};

var SDKCaller = exports.SDKCaller = {
    onPermissionDenied: setCall('permissionDenied'),
    onPermissionAllowed: setCall('permissionAllowed'),
    onAlreadySubscribed: setCall("alreadySubscribed"),
    onNotificationUnsupported: setCall("notificationUnsupported"),
    onPermissionDefault: setCall("permissionDefault"),
    onPermissionCanNotAsk: setCall("permissionCanNotAsk"),
    onPermissionCanAsk: setCall("permissionCanAsk"),
    onAudiencesCanBe: setCall("audiencesCanBe"),
    onSubscriptionDisabled: setCall("subscriptionDisabled"),
    onSubscriptionEnabled: setCall('subscriptionEnabled')
};

var sdk = exports.sdk = {
    permissionDenied: call('permissionDenied'),
    permissionAllowed: call('permissionAllowed'),
    alreadySubscribed: call('alreadySubscribed'),
    notificationUnsupported: call('notificationUnsupported'),
    permissionDefault: call('permissionDefault'),
    permissionCanNotAsk: call('permissionCanNotAsk'),
    permissionCanAsk: call('permissionCanAsk'),
    audiencesCanBe: call('audiencesCanBe'),
    subscriptionDisabled: call('subscriptionDisabled'),
    subscriptionEnabled: call('subscriptionEnabled'),

    setOptions: function setOptions(opts) {
        if (opts) {
            options = opts;
        }
    },
    getOptions: function getOptions() {
        var src = document.currentScript && document.currentScript.src;

        return _extends({
            src: src
        }, defaultOptions, options);
    }
};

/***/ }),

/***/ "./src/utils/seveUserBehavior.js":
/*!***************************************!*\
  !*** ./src/utils/seveUserBehavior.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.saveUserBehavior = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var saveUserBehavior = exports.saveUserBehavior = async function saveUserBehavior(key, error) {
    var userBehaviorData = await (0, _trackDb.getUserBehavior)();
    var updatedUserBehaviorData = void 0;

    if (key !== "error") {
        var sendingId = await (0, _trackDb.getSendingIdDB)();
        var bannerId = await (0, _trackDb.getBannerIdBD)();

        if (!bannerId) {
            updatedUserBehaviorData = _extends({}, userBehaviorData, {
                pubContent: _extends({}, userBehaviorData.pubContent, _defineProperty({}, key, [].concat(_toConsumableArray(userBehaviorData.pubContent[key]), [{
                    timestamp: Date.now(),
                    sendingId: sendingId
                }])))
            });
        } else {
            updatedUserBehaviorData = _extends({}, userBehaviorData, {
                monetization: _extends({}, userBehaviorData.monetization, _defineProperty({}, key, [].concat(_toConsumableArray(userBehaviorData.monetization[key]), [{
                    timestamp: Date.now(),
                    bannerId: bannerId
                }])))
            });
        }
    } else {
        if (userBehaviorData.errors && Array.isArray(userBehaviorData.errors)) {
            updatedUserBehaviorData = _extends({}, userBehaviorData, {
                errors: [].concat(_toConsumableArray(userBehaviorData.errors), [_extends({}, error)])
            });
        } else {
            updatedUserBehaviorData = _extends({}, userBehaviorData, {
                errors: [_extends({}, error)]
            });
        }
    }

    await (0, _trackDb.setUserBehavior)(updatedUserBehaviorData || userBehaviorData);
};

/***/ }),

/***/ "./src/utils/subscribe.js":
/*!********************************!*\
  !*** ./src/utils/subscribe.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.subscribe = subscribe;
exports.isAlreadySubscribed = isAlreadySubscribed;
exports.managerSubscribe = managerSubscribe;

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _defaults = __webpack_require__(/*! ../defaults */ "./src/defaults.js");

var _sendSubscription = __webpack_require__(/*! ./http/sendSubscription */ "./src/utils/http/sendSubscription.js");

var _error = __webpack_require__(/*! ./error */ "./src/utils/error.js");

var _debug = __webpack_require__(/*! ./debug */ "./src/utils/debug.js");

var _version = __webpack_require__(/*! ../version */ "./src/version.js");

var _seveUserBehavior = __webpack_require__(/*! ./seveUserBehavior */ "./src/utils/seveUserBehavior.js");

async function subscribe(url, _ref) {
    var pushSubscription = _ref.pushSubscription,
        context = _ref.context,
        key = _ref.key,
        key_id = _ref.key_id,
        prev_sync = _ref.prev_sync;

    var s = pushSubscription.toJSON();

    var data = _extends({
        endpoint: s.endpoint,
        auth: String(s.keys.auth),
        p256dh: String(s.keys.p256dh)
    }, context, {
        key: key,
        key_id: key_id,
        sw_version: _version.swVersion,
        prev_sync: prev_sync
    });

    var result = await (0, _sendSubscription.sendSubscription)({
        url: url,
        data: data
    });

    return result;
}

async function isAlreadySubscribed(key) {
    var data = await (0, _trackDb.getStoredSubscription)();
    if (!data) {
        return false;
    }
    // TODO:
    return data.key === key;
}

async function managerSubscribe(pushManager, sOpt) {
    return pushManager.subscribe(sOpt).catch(function (error) {
        console.warn('pushManager.subscribe() error:', error);

        return pushManager.getSubscription().then(function (sub) {
            if (!sub) throw error;

            console.warn('not expected subscription found');

            return sub.unsubscribe().then(function () {
                return pushManager.subscribe(sOpt);
            });
        }).catch(function () {
            console.warn('managerSubscribe error:', error);

            (0, _debug.debug)("onPushManagerError", (0, _error.errorInfo)(error), _defaults.DEFAULTS.defaultDomain);
            var errorObj = (0, _error.errorInfo)(error) || {};
            (0, _seveUserBehavior.saveUserBehavior)('error', {
                name: 'onPushManagerError',
                // error: errorObj.error ? errorObj.error : errorObj,
                time: Date.now()
            });
            throw error;
        });
    });
}

/***/ }),

/***/ "./src/utils/urlBase64ToUint8Array.js":
/*!********************************************!*\
  !*** ./src/utils/urlBase64ToUint8Array.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = urlBase64ToUint8Array;
function urlBase64ToUint8Array(base64String) {
    var padding = '='.repeat((4 - base64String.length % 4) % 4);
    var base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');

    var rawData = atob(base64);
    var outputArray = new Uint8Array(rawData.length);

    for (var i = 0, max = rawData.length; i < max; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

/***/ }),

/***/ "./src/version.js":
/*!************************!*\
  !*** ./src/version.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// version to be here
var swVersion = exports.swVersion = "";

/***/ })

/******/ });