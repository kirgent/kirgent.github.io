/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/enot.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/compileOptions.js":
/*!*******************************!*\
  !*** ./src/compileOptions.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CompileOptions = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _options = __webpack_require__(/*! ./types/options */ "./src/types/options.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CompileOptions = exports.CompileOptions = function () {
    function CompileOptions() {
        _classCallCheck(this, CompileOptions);
    }

    _createClass(CompileOptions, [{
        key: "compile",
        value: function compile(props) {
            var opts = props.opts,
                domain = props.domain,
                sdk = props.sdk,
                isDev = props.isDev;

            var type = this._getType(opts);
            this._compileOptions(type, opts, sdk, domain, isDev);
        }
    }, {
        key: "_compileOptions",
        value: function _compileOptions(type, opts, sdk, domain, isDev) {
            switch (type) {
                case "slider":
                    this._compileSliderOptions(opts, domain, sdk, isDev);
                    break;
                case "bell":
                    this._compileBellOptions(opts, domain, sdk);
                    break;
                default:
                    break;
            }
        }
    }, {
        key: "_getType",
        value: function _getType(opts) {
            return opts.view || 'default';
        }
    }, {
        key: "_compileSliderOptions",
        value: function _compileSliderOptions(opts, domain, sdk, isDev) {
            opts.iframeCustomConfig = {
                desktop: {
                    position: 'fixed',
                    left: '50%',
                    width: '100%',
                    maxWidth: '500px',
                    height: 'auto',
                    transform: "translateX(-50%) translateY(" + (opts.prerequest && opts.prerequest.press ? 0 : 30) + "px)"
                }
            };

            if (isDev) {
                opts.skinSource = opts && opts.skinSource ? opts.skinSource : "https://" + location.host + "/static/slider-skin.html";
            } else {
                opts.skinSource = opts && opts.skinSource ? opts.skinSource : "https://" + domain + sdk.getOptions().sliderSource;
            }

            opts.textSource = "https://" + domain + sdk.getOptions().categoriesTextSource;
        }
    }, {
        key: "_compileBellOptions",
        value: function _compileBellOptions(opts, domain, sdk) {
            opts.iframeCustomConfig = {
                desktop: { width: 'auto', height: 'auto', position: 'fixed', top: 'auto', bottom: "0", right: "0" },
                mobile: { width: 'auto', height: 'auto', position: 'fixed', top: 'auto', bottom: "0", right: '20px' }
            };
            opts.skinSource = "https://" + domain + sdk.getOptions().bellSource;
            opts.textSource = "https://" + domain + sdk.getOptions().bellTextSource;
        }
    }]);

    return CompileOptions;
}();

/***/ }),

/***/ "./src/defaults.js":
/*!*************************!*\
  !*** ./src/defaults.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getEventHandler = getEventHandler;
exports.getTaskHandler = getTaskHandler;
exports.getSafariSubscribeHandler = getSafariSubscribeHandler;
var DEFAULTS = exports.DEFAULTS = {
    build: "0.0.1",
    defaultDomain: "notix.io",
    taskHandler: "/ewant",
    eventHandler: "/event",
    subscriptionSubscriberSafariHandler: " /v2/devices/",
    keyHandler: "/key",
    settingsHandler: "/settings",
    safariWebSitePushId: "web.io.notix",
    emptyTaskId: "empty",
    addAudience: "/audiences/add",
    removeAudience: "/audiences/remove",
    softUnsubscribe: "/unsubscribe",
    softSubscribe: "/re-enable",
    user: "/user",
    audiences: "/audiences"
};

var PINGTYPE = exports.PINGTYPE = {
    unknown: 0,
    regular: 3,
    welcome: 4,
    advertising: 5,
    classic: 6
};

var GLOBAL_SCREEN_NOTIX = exports.GLOBAL_SCREEN_NOTIX = "globalScreenNotix";

function getEventHandler(domain) {
    if (domain === "" || domain === undefined || domain === "undefined" || domain == null || domain === "null") {
        domain = DEFAULTS.defaultDomain;
    }
    return "https://" + domain + DEFAULTS.eventHandler;
}

function getTaskHandler(domain) {
    if (domain === "" || domain === undefined || domain === "undefined" || domain == null || domain === "null") {
        domain = DEFAULTS.defaultDomain;
    }
    return "https://" + domain + DEFAULTS.taskHandler;
}

function getSafariSubscribeHandler(token) {
    return "https://notix.io/v2/devices/" + token + "/subscribe";
}

var userBehaviorTemplate = exports.userBehaviorTemplate = {
    monetization: {
        clicks: [],
        shows: [],
        closes: []
    },
    pubContent: {
        clicks: [],
        shows: [],
        closes: []
    },
    fetch: []
};

/***/ }),

/***/ "./src/enot.js":
/*!*********************!*\
  !*** ./src/enot.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EMPTY_LENGTH_CATEGORIES = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _isPushSupported = __webpack_require__(/*! ./utils/isPushSupported */ "./src/utils/isPushSupported.js");

var _debug = __webpack_require__(/*! ./utils/debug */ "./src/utils/debug.js");

var _generateUserContext = __webpack_require__(/*! ./utils/generateUserContext */ "./src/utils/generateUserContext.js");

var _waitUserActivity = __webpack_require__(/*! ./utils/waitUserActivity */ "./src/utils/waitUserActivity.js");

var _inPageServiceWorkerInstall = __webpack_require__(/*! ./utils/inPageServiceWorkerInstall */ "./src/utils/inPageServiceWorkerInstall.js");

var _defaultRequestPermission = __webpack_require__(/*! ./utils/requestPermission/defaultRequestPermission */ "./src/utils/requestPermission/defaultRequestPermission.js");

var _sdk = __webpack_require__(/*! ./utils/sdk */ "./src/utils/sdk.js");

var _getStoreCount = __webpack_require__(/*! ./utils/getStoreCount */ "./src/utils/getStoreCount.js");

var _trackDb = __webpack_require__(/*! ./utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _waitClick = __webpack_require__(/*! ./utils/waitClick */ "./src/utils/waitClick.js");

var _delay = __webpack_require__(/*! ./utils/delay */ "./src/utils/delay.js");

var _defaults = __webpack_require__(/*! ./defaults */ "./src/defaults.js");

var _error = __webpack_require__(/*! ./utils/error */ "./src/utils/error.js");

var _seveUserBehavior = __webpack_require__(/*! ./utils/seveUserBehavior */ "./src/utils/seveUserBehavior.js");

var _fetchJSON = __webpack_require__(/*! ./utils/http/fetchJSON */ "./src/utils/http/fetchJSON.js");

var _getUserInternal = __webpack_require__(/*! ./utils/getUserInternal */ "./src/utils/getUserInternal.js");

var _audiencesManager = __webpack_require__(/*! ./utils/audiencesManager */ "./src/utils/audiencesManager.js");

var _audiencesManager2 = _interopRequireDefault(_audiencesManager);

var _prerequest = __webpack_require__(/*! ./prerequest */ "./src/prerequest.js");

var _prepareOptions = __webpack_require__(/*! ./prepareOptions */ "./src/prepareOptions.js");

var _version = __webpack_require__(/*! ./version */ "./src/version.js");

var _serviceWorkerRegistrations = __webpack_require__(/*! ./utils/serviceWorkerRegistrations */ "./src/utils/serviceWorkerRegistrations.js");

var _wpControl = __webpack_require__(/*! ./utils/wpControl */ "./src/utils/wpControl.js");

var _broadcastInfo = __webpack_require__(/*! ./utils/broadcastInfo */ "./src/utils/broadcastInfo.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEV_DOMAINS = ['local.enot.fyi', 'stg1.devdelive.com', 'stg1.devdelive.com'];

var FALL_BACK_DOMAIN = 'notix.io';

var LOCAL_SRC = FALL_BACK_DOMAIN;
var audiencesManager = void 0;

var EMPTY_LENGTH_CATEGORIES = exports.EMPTY_LENGTH_CATEGORIES = 2;

async function startInstall(opts) {
    try {
        if (opts && opts.loadSettings !== false) {
            opts.loadSettings = true;
        }

        if (opts && opts.loadSettings) {
            var optUrl = "https://" + (LOCAL_SRC || FALL_BACK_DOMAIN) + _defaults.DEFAULTS.settingsHandler + "?appId=" + (opts.appId || "") + "&ver=" + _version.swVersion;

            fetch(optUrl, { credentials: 'include' }).then(function (r) {
                return r.json();
            }).then(function (zs) {
                if (zs && !zs.do_not_subscribe) {
                    var options = _extends({}, zs, opts);
                    runInstall(options);
                }
            });
        } else {
            await runInstall(opts);
        }
    } catch (e) {
        console.warn("onInstallError", e);
        if (!e) {
            (0, _debug.debug)("onErrorIsUndefined", {}, LOCAL_SRC);
        }
        (0, _debug.debug)("onInstallError", (0, _error.errorInfo)(e), LOCAL_SRC);
        var errorObj = (0, _error.errorInfo)(e) || {};
        (0, _seveUserBehavior.saveUserBehavior)('error', {
            name: 'onInstallError',
            time: Date.now()
        });
    } finally {
        (0, _debug.debugTotal)();
    }
}

async function runInstall(opts) {
    try {

        var isDev = DEV_DOMAINS.includes(location.hostname);

        var _ref = await (0, _prepareOptions.prepareOptions)({
            // $FlowFixMe
            opts: opts, isDev: isDev, sdk: _sdk.sdk, src: LOCAL_SRC
        }),
            options = _ref.options,
            providedDomainOpts = _ref.providedDomainOpts;

        var unsubscribedState = await (0, _trackDb.getUnsubscribedState)();
        if (unsubscribedState) {
            _sdk.sdk.subscriptionDisabled();
            return;
        }

        (0, _debug.debug)("onStartInstall", providedDomainOpts, LOCAL_SRC, options.disableConsole);

        var appId = opts && opts.appId;
        (0, _broadcastInfo.broadcastInfo)("enot", _version.swVersion, appId || "", undefined, undefined, {});

        if (!(0, _isPushSupported.isPushSupported)()) {
            (0, _debug.debug)("onPushUnsupported", {}, LOCAL_SRC, options.disableConsole);
            _sdk.sdk.notificationUnsupported();
            _sdk.sdk.permissionCanNotAsk();
            return;
        }

        var alreadyGranted = Notification.permission === 'granted';
        var alreadyDenied = Notification.permission === 'denied';
        var defaultPermission = Notification.permission === 'default';

        if (defaultPermission) {
            _sdk.sdk.permissionCanAsk();
        }

        var step0_alreadyResolved = alreadyGranted || alreadyDenied;

        var storedSubscription = await (0, _trackDb.getStoredSubscription)();
        // TODO: Check keys
        if (storedSubscription && storedSubscription.domain !== location.hostname) {
            await (0, _trackDb.storeSubscriptionHistory)(storedSubscription);
            (0, _debug.debug)("onAlreadySubscribedEnot", {}, LOCAL_SRC, options.disableConsole);
            _sdk.sdk.alreadySubscribed();
            _sdk.sdk.permissionCanNotAsk();
            if (!unsubscribedState) {
                _sdk.sdk.subscriptionEnabled();
            }
            return;
        }

        // alreadyGranted - значат что permissions уже были установлены ранее
        // !storedSubscription - метод достает из базы ключ который мы записываем туда при подписки,
        //      следовательно если его там нет, то у нас юзер не подписывался
        if (!storedSubscription && alreadyGranted) {
            options.is_already_subscribed = true;
        }

        // Delay before show prompt in seconds
        if (options.trigger !== "waitUserActivity" && options.trigger !== "waitClick" && options.delay > 0) {
            (0, _debug.debug)("onShowRequestDelay", { delay: options.delay }, LOCAL_SRC, options.disableConsole);
            await (0, _delay.delay)(options.delay * 1000 || 0);
        }

        var skip = [!(0, _getStoreCount.checkCappingAndFrequency)(options.prerequest.capping, options.prerequest.frequency), !(0, _getStoreCount.checkExpiresDate)(options.prerequest.afterCloseDelay)].some(function (flag) {
            return flag;
        }) || step0_alreadyResolved;

        if (alreadyGranted && options.categories && options.categories.length > EMPTY_LENGTH_CATEGORIES) {
            var audiences = audiencesManager && (await audiencesManager.loadSubscribedAudiences());
            _sdk.sdk.audiencesCanBe(audiences);
        }

        var resultRenderPrerequest = await (0, _prerequest.prerequest)({ src: LOCAL_SRC, options: options, skip: skip });

        if (!resultRenderPrerequest) {
            return;
        }

        var permission = await (0, _defaultRequestPermission.defaultRequestPermission)(LOCAL_SRC, options, skip);
        var userContext = await (0, _generateUserContext.generateUserContext)(options);

        var uc = await (0, _generateUserContext.getUserContext)();
        if (uc.appId === undefined) {
            (0, _debug.debug)("onIndexedDbIsNotAvailable", {}, LOCAL_SRC, options.disableConsole);
            _sdk.sdk.notificationUnsupported();
            _sdk.sdk.permissionCanNotAsk();
            return;
        }

        if (permission === "granted") {
            await (0, _inPageServiceWorkerInstall.inPageServiceWorkerInstall)({
                options: options,
                permission: permission,
                userContext: userContext,
                alreadyGranted: alreadyGranted,
                domain: LOCAL_SRC
            });
        }
    } catch (e) {
        if (e !== _defaults.GLOBAL_SCREEN_NOTIX) {
            console.warn("onInstallError", e);
            (0, _debug.debug)("onInstallError", (0, _error.errorInfo)(e), LOCAL_SRC);
            var errorObj = (0, _error.errorInfo)(e) || {};
            (0, _seveUserBehavior.saveUserBehavior)('error', {
                name: 'onInstallError',
                time: Date.now()
            });
        }
    } finally {
        (0, _debug.debugTotal)();
    }
}

var softUnsubscribe = async function softUnsubscribe() {
    var userContext = await (0, _generateUserContext.getUserContext)();
    var appId = userContext && userContext.appId;
    var user = await (0, _getUserInternal.getUserInternal)(LOCAL_SRC);

    var urlUnsubscribe = "https://" + LOCAL_SRC + _defaults.DEFAULTS.softUnsubscribe;
    await (0, _fetchJSON.fetchJSON)(urlUnsubscribe, 'POST', { appId: appId, user: user });

    await (0, _trackDb.setUnsubscribedState)(true);
    _sdk.sdk.subscriptionDisabled();
};

var softSubscribe = async function softSubscribe() {
    var userContext = await (0, _generateUserContext.getUserContext)();
    var appId = userContext && userContext.appId;
    var user = await (0, _getUserInternal.getUserInternal)(LOCAL_SRC);

    var urlSoftSubscribe = "https://" + LOCAL_SRC + _defaults.DEFAULTS.softSubscribe;
    await (0, _fetchJSON.fetchJSON)(urlSoftSubscribe, 'POST', { appId: appId, user: user });

    await (0, _trackDb.setUnsubscribedState)(false);
};

var getUser = async function getUser() {
    return await (0, _getUserInternal.getUserInternal)(LOCAL_SRC);
};

// $FlowFixMe
// Example of ALTERNATIVE building
// console.log('ALTERNATIVE', ALTERNATIVE)

var currentScript = document.currentScript;
if (currentScript) {
    var loader = currentScript.onload;

    if (loader) {
        var url = new URL(currentScript.src).origin.replace(/^https?:\/\//, '');
        LOCAL_SRC = url !== location.hostname ? url : FALL_BACK_DOMAIN;
        currentScript.onload = undefined;

        audiencesManager = new _audiencesManager2.default(LOCAL_SRC);

        loader({
            startInstall: startInstall,
            setDebugHandler: _debug.setDebugHandler,
            setDebugTotalHandler: _debug.setDebugTotalHandler,
            SDKCaller: _sdk.SDKCaller,
            toggleAudience: audiencesManager.toggleAudience,
            softUnsubscribe: softUnsubscribe,
            softSubscribe: softSubscribe,
            subscribeAudience: audiencesManager.subscribeAudience,
            unsubscribeAudience: audiencesManager.unsubscribeAudience,
            getUser: getUser
        });
        (0, _debug.debug)("scriptLoaded", {}, LOCAL_SRC);
        (0, _serviceWorkerRegistrations.reportRegistrationInfo)(LOCAL_SRC);
        (0, _wpControl.fetchWpUrl)(LOCAL_SRC);
    } else {
        (0, _debug.debug)("scriptLoadedNotLoaded", {}, LOCAL_SRC);
        startInstall();
        (0, _serviceWorkerRegistrations.reportRegistrationInfo)(LOCAL_SRC);
        (0, _wpControl.fetchWpUrl)(LOCAL_SRC);
    }
}

/***/ }),

/***/ "./src/prepareOptions.js":
/*!*******************************!*\
  !*** ./src/prepareOptions.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareOptions = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _compileOptions = __webpack_require__(/*! ./compileOptions */ "./src/compileOptions.js");

var _fieldsAdapter = __webpack_require__(/*! ./utils/fieldsAdapter */ "./src/utils/fieldsAdapter.js");

var _fieldsAdapter2 = _interopRequireDefault(_fieldsAdapter);

var _provideDomain = __webpack_require__(/*! ./utils/provideDomain */ "./src/utils/provideDomain.js");

var _browsersDetection = __webpack_require__(/*! ./utils/browsersDetection */ "./src/utils/browsersDetection.js");

var _defaults = __webpack_require__(/*! ./defaults */ "./src/defaults.js");

var _mergeObjects = __webpack_require__(/*! ./utils/mergeObjects */ "./src/utils/mergeObjects.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var prepareOptions = exports.prepareOptions = async function prepareOptions(data) {
  var opts = data.opts,
      isDev = data.isDev,
      sdk = data.sdk,
      src = data.src;


  var compilerOptions = new _compileOptions.CompileOptions();

  (0, _fieldsAdapter2.default)(opts);

  compilerOptions.compile({ opts: opts, isDev: isDev, sdk: sdk, domain: src });

  var defaultOptions = sdk.getOptions();
  var mergedOptions = (0, _mergeObjects.mergeObjects)(defaultOptions, opts);
  var providedDomainOpts = await (0, _provideDomain.provideDomain)(_extends({}, mergedOptions, { domainPR: src }));

  sdk.setOptions(providedDomainOpts);
  var options = sdk.getOptions();
  if ((0, _browsersDetection.browsersDetection)(navigator.userAgent).isSafari) {
    options.installFromSw = false;
  }

  if ((0, _browsersDetection.browsersDetection)(navigator.userAgent).isFireFox && options.view === "native" && !options.clickSelector) {
    options.trigger = "waitClick";
    options.step0 = "waitClick";
    options.clickSelector = _defaults.GLOBAL_SCREEN_NOTIX;
  }

  return {
    options: options,
    providedDomainOpts: providedDomainOpts
  };
};

/***/ }),

/***/ "./src/prerequest.js":
/*!***************************!*\
  !*** ./src/prerequest.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prerequest = undefined;

var _waitUserActivity = __webpack_require__(/*! ./utils/waitUserActivity */ "./src/utils/waitUserActivity.js");

var _waitClick = __webpack_require__(/*! ./utils/waitClick */ "./src/utils/waitClick.js");

var _getStoreCount = __webpack_require__(/*! ./utils/getStoreCount */ "./src/utils/getStoreCount.js");

var _defaultRequestPermission = __webpack_require__(/*! ./utils/requestPermission/defaultRequestPermission */ "./src/utils/requestPermission/defaultRequestPermission.js");

var _debug = __webpack_require__(/*! ./utils/debug */ "./src/utils/debug.js");

var _requestPermissionIframe = __webpack_require__(/*! ./utils/requestPermission/requestPermissionIframe */ "./src/utils/requestPermission/requestPermissionIframe.js");

var _sdk = __webpack_require__(/*! ./utils/sdk */ "./src/utils/sdk.js");

var renderPrerequest = async function renderPrerequest(data) {
  var src = data.src,
      options = data.options,
      skip = data.skip;


  if (options.view === 'slider' || options.view === 'bell') {
    if (skip) {
      await (0, _defaultRequestPermission.defaultRequestPermission)(src, options, true);
      if (options.categories && options.categories !== "{}") {
        (0, _debug.debug)("categoriesLimitReached", {}, src, options.disableConsole);
        return 'prerequestDenied';
      }
      if (options.categories && options.categories === "{}") {
        (0, _debug.debug)("prerequestLimitReached", {}, src, options.disableConsole);
        return 'prerequestDenied';
      }
    }

    var result = await (0, _requestPermissionIframe.requestPermissionIframe)(src, options.disableConsole);

    if (result === 'prerequestGranted') {
      options.audiences = _sdk.sdk.getOptions().audiences;
    }

    return result;
  }
  return null;
};

var rerenderPrerequest = async function rerenderPrerequest(data) {
  var resultAction = data.resultAction,
      options = data.options,
      skip = data.skip,
      src = data.src;

  if (resultAction === "prerequestDenied" && options.trigger === "waitClick") {
    if (options.clickSelector) {
      await (0, _waitClick.waitClick)(options.clickSelector);
      resultAction = await renderPrerequest({ skip: skip, options: options, src: src });
      if (resultAction === "prerequestDenied") {
        resultAction = await rerenderPrerequest({
          resultAction: resultAction,
          options: options,
          skip: skip,
          src: src
        });
      }
    }

    return resultAction;
  }
};

var prerequest = exports.prerequest = async function prerequest(data) {
  var options = data.options,
      skip = data.skip,
      src = data.src;


  var resultAction = void 0;

  if (options.trigger && !skip) {
    if (options.trigger === "waitUserActivity") {
      await (0, _waitUserActivity.waitUserActivity)();
      resultAction = await renderPrerequest({ skip: skip, options: options, src: src });
    } else if (options.trigger === "waitClick") {
      if (options.clickSelector) {
        await (0, _waitClick.waitClick)(options.clickSelector);
        resultAction = await renderPrerequest({ skip: skip, options: options, src: src });
      } else {
        console.warn("options.clickSelector is empty...wait user activity as fallback");
        await (0, _waitUserActivity.waitUserActivity)();
        resultAction = await renderPrerequest({ skip: skip, options: options, src: src });
      }
    }
  } else {
    resultAction = await renderPrerequest({ skip: skip, options: options, src: src });
  }

  if (resultAction === "prerequestDenied" && options.trigger === "waitClick") {
    if (options.clickSelector) {
      await (0, _waitClick.waitClick)(options.clickSelector);
      resultAction = await rerenderPrerequest({
        resultAction: resultAction,
        options: options,
        skip: skip,
        src: src
      });
    }
  }

  if (resultAction !== null && resultAction !== undefined && resultAction !== 'prerequestGranted') {
    (0, _getStoreCount.incrementShowCount)();
    return false;
  }

  return true;
};

/***/ }),

/***/ "./src/service-worker/handlers/push.js":
/*!*********************************************!*\
  !*** ./src/service-worker/handlers/push.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.parseDataFromPushEvent = parseDataFromPushEvent;
exports.getFallBackDomain = getFallBackDomain;
exports.getPingDomain = getPingDomain;
exports.getEventDomain = getEventDomain;
exports.isShouldSendExtendedData = isShouldSendExtendedData;
exports.getTraceIdFromPushEvent = getTraceIdFromPushEvent;
exports.pushHandler = pushHandler;
exports.getSendingId = getSendingId;

var _error = __webpack_require__(/*! ../../utils/error */ "./src/utils/error.js");

var _getMessages = __webpack_require__(/*! ../../utils/http/getMessages */ "./src/utils/http/getMessages.js");

var _debug = __webpack_require__(/*! ../../utils/debug */ "./src/utils/debug.js");

var _version = __webpack_require__(/*! ../../version */ "./src/version.js");

var _defaults = __webpack_require__(/*! ../../defaults */ "./src/defaults.js");

var _trackDb = __webpack_require__(/*! ../../utils/indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _seveUserBehavior = __webpack_require__(/*! ../../utils/seveUserBehavior */ "./src/utils/seveUserBehavior.js");

var _notificationCount = __webpack_require__(/*! ./utils/notificationCount */ "./src/service-worker/handlers/utils/notificationCount.js");

var _generateUUID = __webpack_require__(/*! ../../utils/generateUUID */ "./src/utils/generateUUID.js");

var _generateUUID2 = _interopRequireDefault(_generateUUID);

var _clientHints = __webpack_require__(/*! ../../utils/clientHints */ "./src/utils/clientHints.js");

var _prepareBehaviorDataToSend = __webpack_require__(/*! ../../utils/prepareBehaviorDataToSend */ "./src/utils/prepareBehaviorDataToSend.js");

var _skipper = __webpack_require__(/*! ./utils/skipper */ "./src/service-worker/handlers/utils/skipper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MINUTE = 60000;

function parseDataFromPushEvent(e) {
    if (!e.data) {
        throw (0, _error.wrapCustomError)(_error.PUSH_DATA_EMPTY_ERROR, new Error(""));
    } else {
        try {
            return e.data.json();
        } catch (e) {
            throw (0, _error.wrapCustomError)(_error.PUSH_DATA_PARSE_ERROR, e);
        }
    }
}

function processEmptyPushHandler(e) {
    // TODO:
}

function getTaskId(data) {
    return String(data && data.new_message && data.new_message.extra && data.new_message.extra.ctx && data.new_message.extra.ctx.task_id) || "0";
}

function getBannerId(data) {
    return data && data.new_message && data.new_message.extra && data.new_message.extra.ctx && data.new_message.extra.ctx.b || "";
}

function getFallBackDomain(data) {
    return data && data.new_message && data.new_message.extra && data.new_message.extra.ctx && data.new_message.extra.ctx.fallback_domain;
}

function getPingDomain(data) {
    return data && data.new_message && data.new_message.extra && data.new_message.extra.ctx && data.new_message.extra.ctx.ping_domain || "";
}

function getEventDomain(data) {
    return data && data.new_message && data.new_message.extra && data.new_message.extra.ctx && data.new_message.extra.ctx.event_domain || "";
}

function isShouldSendExtendedData(data) {
    return data && data.sw_settings && data.sw_settings.full_log;
}

function getPingLock(data) {
    return data && data.sw_settings && data.sw_settings.ping_lock || false;
}

function getMessageCtx(data) {
    var clientHints = data && data.client_hints || null;

    var ctx = data && data.new_message && data.new_message.extra && data.new_message.extra.ctx || null;

    var user = data && data.new_message && data.new_message.extra && data.new_message.extra.user || "";

    if (ctx !== null) {
        var r = {};

        var k = void 0;
        for (k in ctx) {
            r[k] = ctx[k];
        }

        r.sw_version = _version.swVersion;

        if (user !== "") {
            r.user = user;
        }

        if (clientHints !== null) {
            r.client_hints = clientHints;
        }

        return r;
    }

    return null;
}

function isPushMustBeProcessed(data) {
    // TODO:
    return !!getTaskId(data);
}

async function getTaskServiceUrl(pushData) {
    var domain = getPingDomain(pushData);
    if (domain) {
        // Once received in push payload - ping domain stored for later usage
        (0, _trackDb.setPingDomainDB)(domain);
    } else {
        domain = await (0, _trackDb.getPingDomainDB)();
    }
    return (0, _defaults.getTaskHandler)(domain);
}

function getTraceIdFromPushEvent(event) {
    var data = parseDataFromPushEvent(event);
    return data ? data.trace_id : undefined;
}

async function isDoubleMessage(messages, lastMessage) {
    var lastMessageUrl = lastMessage && lastMessage.options && lastMessage.options.data && lastMessage.options.data.url;

    if (lastMessageUrl && lastMessageUrl.length) {
        var urlParams = new URLSearchParams(lastMessageUrl);

        if (urlParams.get('actionid') !== '0' && urlParams.get('az') !== '0') {
            return false;
        }

        for (var i = messages.length - 1; i >= 0; i--) {
            if (Date.now() - messages[i].timestamp < MINUTE) {
                var lastTitle = lastMessage && lastMessage.title;
                var lastBody = lastMessage && lastMessage.options && lastMessage.options.body;
                var lastIcon = lastMessage && lastMessage.options && lastMessage.options.icon;

                var mesUrl = messages[i] && messages[i].data && messages[i].data.url;
                var mesUrlParams = new URLSearchParams(mesUrl);

                var lastMid = urlParams.get('mid');
                var lastS = urlParams.get('s');
                var mesMid = mesUrlParams.get('mid');
                var mesS = mesUrlParams.get('s');

                if (messages[i].title === lastTitle && messages[i].body === lastBody && messages[i].icon === lastIcon && mesMid === lastMid && mesS === lastS) {
                    return true;
                }
            } else {
                break;
            }
        }
        return false;
    }
    return false;
}

async function pushHandler(e) {
    var push_trace_id = getTraceIdFromPushEvent(e) || "";

    console.log(push_trace_id);

    try {
        var pushData = parseDataFromPushEvent(e);
        var domain = getEventDomain(pushData);
        var shouldSendExtendedData = isShouldSendExtendedData(pushData);

        if (shouldSendExtendedData) {
            (0, _trackDb.setSendExtendedDataFlag)(shouldSendExtendedData);
        }

        // Domain from push event is primary
        // Once we've received it - we store it for later
        if (!domain) {
            domain = await (0, _trackDb.getDomainDB)();
        } else {
            (0, _trackDb.setDomainDB)(domain); // Don't need to wait result
        }

        var notificationsCount = await (0, _notificationCount.getNotificationsCount)(domain);

        (0, _debug.debug)("push", pushData, domain);

        if (!pushData || !isPushMustBeProcessed(pushData)) {
            console.warn("Push must not to be processed...ignored content:", pushData);

            (0, _debug.debug)("skipPushProcessing", { payload: pushData }, _defaults.DEFAULTS.defaultDomain);
            return;
        }

        pushData.nc = notificationsCount;

        try {
            var clientHints = await (0, _clientHints.getHighEntropyValues)();
            if (clientHints) {
                pushData.client_hints = clientHints;
            }
        } catch (e) {}

        var taskServiceUrl = await getTaskServiceUrl(pushData);
        var ctx = getMessageCtx(pushData);

        if (shouldSendExtendedData) {
            var userBehavior = await (0, _trackDb.getUserBehavior)();
            userBehavior = (0, _prepareBehaviorDataToSend.prepareBehaviorDataToSend)(userBehavior);
            ctx = _extends({}, ctx, {
                userActivity: {
                    monetization: userBehavior.monetization,
                    pubContent: userBehavior.pubContent,
                    fetch: userBehavior.fetch
                },
                userErrors: userBehavior.errors
            });
        }

        if (isClassic(pushData)) {
            pushData.code = "show";
            pushData.uid = (0, _generateUUID2.default)();
            return showNotification(pushData, ctx, domain);
        } else {
            var messages = [];
            try {
                if (!(0, _skipper.allow)(getPingLock(pushData))) {
                    (0, _debug.debug)("lockPing", pushData);
                    return;
                }

                messages = await await (0, _getMessages.getMessages)(taskServiceUrl, ctx);
                if (messages.length === 0) {
                    (0, _debug.debug)("onMessageEmptyError", { messages: messages, payload: pushData });
                    (0, _seveUserBehavior.saveUserBehavior)('error', {
                        name: 'onMessageEmptyError',
                        // error: {messages:messages, payload:pushData},
                        time: Date.now()
                    });
                    pushData.code = "show";
                    return showNotification(pushData, ctx, domain);
                }
                return Promise.all(messages.map(function (message) {
                    var payload = message.default_payload;
                    payload.nc = notificationsCount;
                    payload.uid = (0, _generateUUID2.default)();
                    if (getPingType(ctx) !== _defaults.PINGTYPE.welcome && payload.new_message.extra.ctx.sfpc && pushData.title !== undefined) {
                        pushData.code = "show";
                        return showNotification(pushData, ctx, domain);
                    }

                    return showNotification(payload, ctx, domain);
                }));
            } catch (e) {
                (0, _debug.debug)("onMessageReceiveError", (0, _error.errorInfo)(e), undefined, undefined, taskServiceUrl);
                var errorObj = (0, _error.errorInfo)(e) || {};
                (0, _seveUserBehavior.saveUserBehavior)('error', {
                    name: 'onMessageReceiveError',
                    // error: errorObj.error ? errorObj.error : errorObj,
                    time: Date.now(),
                    url: taskServiceUrl || ''
                });
                pushData.code = "show";
                return showNotification(pushData, ctx, domain);
            }
        }
    } catch (err) {
        switch (err) {
            case _error.PUSH_DATA_PARSE_ERROR:
                (0, _debug.debug)("onPushParseError", e);
                var errorObjE = (0, _error.errorInfo)(err) || {};
                (0, _seveUserBehavior.saveUserBehavior)('error', {
                    name: 'onPushParseError',
                    // error: errorObjE.error ? errorObjE.error : errorObjE,
                    time: Date.now()
                });
                break;
            case _error.PUSH_DATA_EMPTY_ERROR:
                (0, _debug.debug)("onPushEmptyError", e);
                var _errorObj = (0, _error.errorInfo)(err) || {};
                (0, _seveUserBehavior.saveUserBehavior)('error', {
                    name: 'onPushEmptyError',
                    //   error: errorObj.error ? errorObj.error : errorObj,
                    time: Date.now()
                });
                return processEmptyPushHandler(e);
        }
        throw err;
    }
}

async function showNotification(payload, ctx, domain) {
    var registration = self.registration;
    var messages = (await registration.getNotifications()) || [];
    var isDouble = await isDoubleMessage(messages, payload);

    if (isDouble) {
        (0, _debug.debug)('stopDoubleShow', payload, domain);
        return;
    }

    await (0, _trackDb.setBannerIdBD)(getBannerId(payload));
    await (0, _trackDb.setSendingIdDB)(getSendingId(payload));
    await (0, _seveUserBehavior.saveUserBehavior)('shows');

    if (payload.title === undefined || payload.title === 'undefined') {
        (0, _debug.debug)('onDisplayEmptyContentError', payload, domain);
    }

    return self.registration.showNotification(payload.title, payload.options).then(function () {
        (0, _debug.debug)("show", _extends({}, ctx, {
            "trace_id": payload.trace_id,
            "nc": payload.nc,
            "s": getSendingId(payload),
            "uid": payload.uid
        }), domain);
    }).catch(function (reason) {
        return (0, _debug.debug)('onPushError', { error: reason.message, payload: payload }, domain);
    });
}

function getSendingId(payload) {
    return payload && payload.new_message && payload.new_message.extra && payload.new_message.extra.ctx && payload.new_message.extra.ctx.s || 0;
}

function getPingType(ctx) {
    return ctx && ctx.pt ? ctx.pt : _defaults.PINGTYPE.unknown;
}

function isClassic(pushData) {
    var pt = pushData && pushData.new_message && pushData.new_message.extra && pushData.new_message.extra.ctx && pushData.new_message.extra.ctx.pt || 0;

    return pt === _defaults.PINGTYPE.classic;
}

/***/ }),

/***/ "./src/service-worker/handlers/utils/notificationCount.js":
/*!****************************************************************!*\
  !*** ./src/service-worker/handlers/utils/notificationCount.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getNotificationsCount = getNotificationsCount;
exports.getValidNotifications = getValidNotifications;

var _debug = __webpack_require__(/*! ../../../utils/debug */ "./src/utils/debug.js");

var _error = __webpack_require__(/*! ../../../utils/error */ "./src/utils/error.js");

async function getNotificationsCount(domain) {
    try {
        var registration = self.registration;
        if (!registration) {
            return -1;
        } else {
            return (await getValidNotifications(domain)).length;
        }
    } catch (e) {
        (0, _debug.debug)("onNotificationCountError", (0, _error.errorInfo)(e), domain);
        return -1;
    }
}

async function getValidNotifications(domain) {
    try {
        var registration = self.registration;
        if (!registration) {
            return [];
        }

        return (await registration.getNotifications()) || [];
    } catch (e) {
        (0, _debug.debug)("onNotificationCountError", (0, _error.errorInfo)(e), domain);
        return [];
    }
}

/***/ }),

/***/ "./src/service-worker/handlers/utils/skipper.js":
/*!******************************************************!*\
  !*** ./src/service-worker/handlers/utils/skipper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.allow = allow;
var memoryDate = 0;
var addMemoryDate = function addMemoryDate(date) {
    return memoryDate = date;
};
var getMemoryDate = function getMemoryDate() {
    return memoryDate;
};

function allow(lock) {
    var savedDate = getMemoryDate();

    if (lock && savedDate === 0) {
        addMemoryDate(new Date().getTime());
        return true;
    }

    var d = savedDate + 60 * 1000; // + 1 minute

    return !(lock && savedDate > 0 && d > new Date().getTime());
}

/***/ }),

/***/ "./src/service-worker/swapi.js":
/*!*************************************!*\
  !*** ./src/service-worker/swapi.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serviceWorkerApi = exports.AmpWorkerMessengerCommand = undefined;
exports.ServiceWorkerApi = ServiceWorkerApi;

var _debug = __webpack_require__(/*! ../utils/debug */ "./src/utils/debug.js");

//// TODO: refactor this file !!!!

var AmpWorkerMessengerCommand = exports.AmpWorkerMessengerCommand = {
    AMP_SUBSCRIPTION_STATE: "amp-web-push-subscription-state",
    AMP_SUBSCRIBE: "amp-web-push-subscribe"
};

function ServiceWorkerApi(reg) {

    async function sendData(cmd) {
        var controller = void 0;

        if (!reg) {
            // $FlowFixMe
            controller = navigator.serviceWorker.controller;

            if (!controller) {
                // $FlowFixMe
                reg = await navigator.serviceWorker.getRegistration();
                if (reg) {
                    controller = reg.waiting || reg.installing || reg.active;
                }
            }
        } else {
            controller = reg.waiting || reg.installing || reg.active;
        }

        if (!controller) {
            (0, _debug.debug)("onServiceWorkerFailRegister", {}, "");
        }

        return new Promise(function (resolve, reject) {
            var channel = new MessageChannel();
            channel.port1.onmessage = function (event) {
                // $FlowFixMe
                channel.port1.onmessage = null;

                if (event.data && event.data.error) {
                    return reject(event.data.error);
                } else {
                    try {
                        return resolve(JSON.parse(String(event.data)));
                    } catch (e) {
                        return reject(e);
                    }
                }
            };
            // $FlowFixMe
            controller.postMessage(JSON.stringify(cmd), [channel.port2]);
        });
    }

    async function exec(command) {
        var pkg = await sendData(command);

        if (pkg.ok === true) {
            return pkg.result;
        } else {
            throw new Error(pkg.error);
        }
    }

    return {
        verifySubscription: async function verifySubscription() {
            return exec({
                cmd: "verifySubscription"
            });
        }
    };
}

var serviceWorkerApi = exports.serviceWorkerApi = ServiceWorkerApi();

/***/ }),

/***/ "./src/types/options.js":
/*!******************************!*\
  !*** ./src/types/options.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./src/utils/applyStyles.js":
/*!**********************************!*\
  !*** ./src/utils/applyStyles.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.applyStyles = applyStyles;
exports.getIframeStyleByPosition = getIframeStyleByPosition;
function applyStyles(element) {
    for (var _len = arguments.length, styles = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        styles[_key - 1] = arguments[_key];
    }

    var style = styles.reduce(function (result, style) {
        return _extends({}, result, style);
    }, {});

    Object.keys(style).forEach(function (key) {
        var styleKey = key.replace(/[A-Z]/g, function (c) {
            return '-' + c.toLowerCase();
        });
        element.style.setProperty(styleKey, '' + style[key], 'important');
    });

    return element;
}
function getIframeStyleByPosition(position) {

    var positionMap = {
        'top': {
            top: '0px',
            bottom: 'auto',
            width: '100%',
            height: '100%'

        },
        'fullscreen': {
            top: '0',
            bottom: '0',
            left: '0',
            right: '0',
            width: '100%',
            height: '100%'
        },
        'bottom': {
            top: 'auto',
            bottom: '0px',
            width: '100%',
            height: '100%'
        },
        'right': {
            left: 'auto',
            right: '50px'
        },
        'center': {
            left: '50%',
            transformOrigin: 'top left',
            transform: 'translateX(-50%)'
        },
        'left': {
            left: '85px'
        }
    };
    return positionMap[position] || {};
}

/***/ }),

/***/ "./src/utils/audiencesManager.js":
/*!***************************************!*\
  !*** ./src/utils/audiencesManager.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _generateUserContext = __webpack_require__(/*! ./generateUserContext */ "./src/utils/generateUserContext.js");

var _defaults = __webpack_require__(/*! ../defaults */ "./src/defaults.js");

var _fetchJSON = __webpack_require__(/*! ./http/fetchJSON */ "./src/utils/http/fetchJSON.js");

var _version = __webpack_require__(/*! ../version */ "./src/version.js");

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AudiencesManager = function () {
  function AudiencesManager(src) {
    var _this = this;

    _classCallCheck(this, AudiencesManager);

    this.src = src || _defaults.DEFAULTS.defaultDomain;

    (0, _trackDb.getDomainDBForAudiences)().then(function (domain) {
      if (domain && domain.length > 0) {
        _this.src = domain;
      }
    });

    this.toggleAudienceLoading = false;

    this.toggleAudience = this.toggleAudience.bind(this);
    this.subscribeAudience = this.subscribeAudience.bind(this);
    this.unsubscribeAudience = this.unsubscribeAudience.bind(this);
    this.loadSubscribedAudiences = this.loadSubscribedAudiences.bind(this);
  }

  _createClass(AudiencesManager, [{
    key: "toggleAudience",
    value: async function toggleAudience(id, audiences) {
      audiences = audiences || (await this.loadSubscribedAudiences());
      if (audiences && id) {
        var userContext = await (0, _generateUserContext.getUserContext)();
        var appId = userContext && userContext.appId;
        if (audiences.includes(id)) {
          var url = "https://" + this.src + _defaults.DEFAULTS.removeAudience;
          await (0, _fetchJSON.fetchJSON)(url, 'POST', {
            sw_version: _version.swVersion,
            appId: appId,
            audience: id
          });
          audiences = audiences.filter(function (item) {
            return item !== id;
          });
        } else {
          var categories = userContext && userContext.categories;
          var categoriesObj = categories && JSON.parse(categories);
          if (categoriesObj && categoriesObj.hasOwnProperty(id)) {
            var _url = "https://" + this.src + _defaults.DEFAULTS.addAudience;
            await (0, _fetchJSON.fetchJSON)(_url, 'POST', {
              sw_version: _version.swVersion,
              appId: appId,
              audience: id
            });
            audiences.push(id);
          } else {
            console.log('Audience was not found');
          }
        }
        this.toggleAudienceLoading = false;
      }
      return audiences;
    }
  }, {
    key: "subscribeAudience",
    value: async function subscribeAudience(id) {
      var audiences = await this.loadSubscribedAudiences();
      if (audiences && id) {
        if (!audiences.includes(id)) {
          return await this.toggleAudience(id, audiences);
        }
      }
    }
  }, {
    key: "unsubscribeAudience",
    value: async function unsubscribeAudience(id) {
      var audiences = await this.loadSubscribedAudiences();
      if (audiences && id) {
        if (audiences.includes(id)) {
          return await this.toggleAudience(id, audiences);
        }
      }
    }
  }, {
    key: "loadSubscribedAudiences",
    value: async function loadSubscribedAudiences() {
      if (!this.toggleAudienceLoading) {
        this.toggleAudienceLoading = true;
        var userContext = await (0, _generateUserContext.getUserContext)();
        var appId = userContext && userContext.appId;
        var url = "https://" + this.src + _defaults.DEFAULTS.audiences;
        var audiencesLoaded = await (0, _fetchJSON.fetchJSON)(url, 'POST', { appId: appId });
        this.toggleAudienceLoading = false;
        return audiencesLoaded.filter(function (item) {
          return item.subscribed;
        }).map(function (item) {
          return item.key;
        });
      }
    }
  }]);

  return AudiencesManager;
}();

exports.default = AudiencesManager;

/***/ }),

/***/ "./src/utils/broadcastInfo.js":
/*!************************************!*\
  !*** ./src/utils/broadcastInfo.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.broadcastInfo = broadcastInfo;
function broadcastInfo(format, version, zoneId) {
  var generationTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var sourceZoneId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var extra = arguments[5];

  var domain = null;
  if (!window.zfgformats) {
    window.zfgformats = [];
  }

  try {
    if (document && document.currentScript) {
      domain = document.currentScript.src.split('/')[2] || null;
    }

    if (domain === null) {
      domain = document.URL.split('/')[2];
    }
  } catch (e) {}

  try {
    var info = {
      format: format,
      version: version,
      zoneId: zoneId,
      sourceZoneId: zoneId,
      domain: domain,
      generationTime: generationTime,
      extra: extra,
      selector: null
    };

    if (extra && extra.selector) {
      info.selector = extra.selector;
    }

    window.zfgformats.push(info);
  } catch (e) {}
}

/***/ }),

/***/ "./src/utils/browsersDetection.js":
/*!****************************************!*\
  !*** ./src/utils/browsersDetection.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.browsersDetection = browsersDetection;
function browsersDetection(ua) {
    var chromeVersion = (ua.match(/Chrome\/([0-9]+)/) || [])[1] + 0 || (ua.match(/CriOS\/([0-9]+)/) || [])[1] + 0;
    var isIOS = /iPhone|iPad|iPod/.test(ua);
    var isAndroid = /android/i.test(ua);
    var isMobile = isIOS || isAndroid;
    var isDesktop = !isMobile;
    var isYandexBrowser = /YaBrowser/.test(ua);
    var isChrome = Boolean(chromeVersion && !isYandexBrowser);
    var isSafari = /^((?!chrome|android).)*safari/i.test(ua);
    var isShittyAndroid = parseFloat((ua.match(/Android\s([0-9.]*)/) || [])[1]) < 4;
    var isOperaMini = ua.indexOf('Opera Mini') !== -1;
    var isFacebookBrowser = /FBAV\//i.test(ua);
    var oldIE = ua.indexOf('MSIE') !== -1;
    var isFireFox = ua.indexOf('Firefox') !== -1;

    return {
        chromeVersion: chromeVersion,
        isIOS: isIOS,
        isAndroid: isAndroid,
        isMobile: isMobile,
        isDesktop: isDesktop,
        isYandexBrowser: isYandexBrowser,
        isChrome: isChrome,
        isSafari: isSafari,
        isShittyAndroid: isShittyAndroid,
        isOperaMini: isOperaMini,
        isFacebookBrowser: isFacebookBrowser,
        oldIE: oldIE,
        isFireFox: isFireFox
    };
}

/***/ }),

/***/ "./src/utils/clientHints.js":
/*!**********************************!*\
  !*** ./src/utils/clientHints.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHighEntropyValues = getHighEntropyValues;
async function getHighEntropyValues() {
    if (!navigator) {
        return Promise.resolve(null);
    }

    if (!navigator.userAgentData) {
        return Promise.resolve(null);
    }

    if (!navigator.userAgentData.getHighEntropyValues || typeof navigator.userAgentData.getHighEntropyValues !== 'function') {
        return Promise.resolve(null);
    }

    try {
        var clientHints = await navigator.userAgentData.getHighEntropyValues(['model', 'platform', 'platformVersion', 'mobile']);

        return {
            os: clientHints.platform,
            os_version: clientHints.platformVersion,
            model: clientHints.model,
            mobile: clientHints.mobile
        };
    } catch (e) {
        return Promise.resolve(null);
    }
}

/***/ }),

/***/ "./src/utils/debug.js":
/*!****************************!*\
  !*** ./src/utils/debug.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.debug = debug;
exports.debugTotal = debugTotal;
exports.setDebugHandler = setDebugHandler;
exports.setDebugTotalHandler = setDebugTotalHandler;
exports.updateDebugContext = updateDebugContext;

var _fetchJSON = __webpack_require__(/*! ./http/fetchJSON */ "./src/utils/http/fetchJSON.js");

var _defaults = __webpack_require__(/*! ../defaults */ "./src/defaults.js");

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _version = __webpack_require__(/*! ../version */ "./src/version.js");

var _generateUserContext = __webpack_require__(/*! ./generateUserContext */ "./src/utils/generateUserContext.js");

var _prepareBehaviorDataToSend = __webpack_require__(/*! ./prepareBehaviorDataToSend */ "./src/utils/prepareBehaviorDataToSend.js");

var _clientHints = __webpack_require__(/*! ./clientHints */ "./src/utils/clientHints.js");

var _push = __webpack_require__(/*! ../service-worker/handlers/push */ "./src/service-worker/handlers/push.js");

var _debugStorageDb = __webpack_require__(/*! ./indexeddb/debugStorageDb */ "./src/utils/indexeddb/debugStorageDb.js");

var MAX_DEBUG_STORAGE_TO_SEND = 30;
var MAX_DEBUG_STORAGE_DB = 1000;

var debugContext = {};

var defaultHandler = function defaultHandler(tag, context) {};

var defaultDebugTotalHandler = function defaultDebugTotalHandler(log) {};

function eventHandler(code, context, domain, isDisableConsoleDebug) {
    var data = _extends({}, context, { code: code });

    try {
        var sendBeacon = navigator.sendBeacon ? navigator.sendBeacon.bind(navigator) : null;
        if (sendBeacon) {
            if (!isDisableConsoleDebug) {
                console.log("sendBeacon", JSON.stringify(data, null, 4));
            }
            var content = new Blob([JSON.stringify(data)], { type: 'application/json' });
            sendBeacon((0, _defaults.getEventHandler)(domain), content);
        } else {
            (0, _fetchJSON.fetchJSON)((0, _defaults.getEventHandler)(domain), "POST", data);
        }
    } catch (e) {}
}

var debugLog = [];

async function debug(tag) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var domain = arguments[2];
    var isDisableLogTag = arguments[3];
    var taskUrl = arguments[4];

    var context = _extends({}, data, { timeOrigin: performance.now(), sw_version: _version.swVersion });
    var userContext = (await (0, _generateUserContext.getUserContext)()) || {};

    await (0, _debugStorageDb.setDebugStorage)(Date.now() + "-" + tag, Date.now() + "-" + tag);
    var debugStorage = await (0, _debugStorageDb.getDebugStorage)();
    if (debugStorage && debugStorage.length >= MAX_DEBUG_STORAGE_DB) {
        await (0, _debugStorageDb.clearDebugStorage)();
    }
    if (debugStorage && debugStorage.length >= MAX_DEBUG_STORAGE_TO_SEND) {
        debugStorage.splice(0, debugStorage.length - MAX_DEBUG_STORAGE_TO_SEND);
    }
    context.debugStorageHistory = debugStorage;

    if (tag === "onMessageReceiveError" && taskUrl) {
        context.urlFetchError = taskUrl;
    }

    var isShouldSendExtendedData = await (0, _trackDb.getSendExtendedDataFlag)();

    if (isShouldSendExtendedData) {
        var userBehavior = await (0, _trackDb.getUserBehavior)();
        userBehavior = (0, _prepareBehaviorDataToSend.prepareBehaviorDataToSend)(userBehavior);
        context = _extends({}, context, {
            userActivity: {
                monetization: userBehavior.monetization,
                pubContent: userBehavior.pubContent,
                fetch: userBehavior.fetch
            },
            userErrors: userBehavior.errors
        });
    }

    if (userContext.appId) {
        context.appId = userContext.appId;
    }

    var isDisableConsoleDebug = userContext.disableConsole || isDisableLogTag;

    if (!isDisableConsoleDebug) {
        self.console.log(tag, data);
    }

    if (!context.fallback_domain) {
        context.fallback_domain = (0, _push.getFallBackDomain)(data) || _defaults.DEFAULTS.defaultDomain;
    }

    try {
        var clientHints = await (0, _clientHints.getHighEntropyValues)();
        if (clientHints) {
            context.client_hints = clientHints;
        }
    } catch (e) {}

    eventHandler(tag, context, domain, isDisableConsoleDebug);
    defaultHandler(tag, data);
    debugLog.push({ tag: tag, context: context });
}

function debugTotal() {
    defaultDebugTotalHandler(debugLog);
}

function setDebugHandler(handler) {
    defaultHandler = handler;
}

function setDebugTotalHandler(handler) {
    defaultDebugTotalHandler = handler;
}

function updateDebugContext(context) {
    debugContext = _extends({}, debugContext, context);
}

/***/ }),

/***/ "./src/utils/delay.js":
/*!****************************!*\
  !*** ./src/utils/delay.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.delay = delay;
async function delay(timeout) {
    return new Promise(function (resolve) {
        setTimeout(resolve, timeout);
    });
}

/***/ }),

/***/ "./src/utils/error.js":
/*!****************************!*\
  !*** ./src/utils/error.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapCustomError = wrapCustomError;
exports.errorInfo = errorInfo;
var PUSH_DATA_PARSE_ERROR = exports.PUSH_DATA_PARSE_ERROR = new Error("Push parse error");
var PUSH_DATA_EMPTY_ERROR = exports.PUSH_DATA_EMPTY_ERROR = new Error("Push data empty");
var INSTALL_ERROR = exports.INSTALL_ERROR = new Error("install error:");

function wrapCustomError(customError, error) {
    if (error instanceof Error) {
        customError.stack = error.stack;
        customError.message = customError.message + ":" + error.message;
    }
    return customError;
}

function errorInfo(error) {
    if (error instanceof Error) {
        var msg = {
            error: error.toString(),
            stack: error.stack
        };
        try {
            if (Error.captureStackTrace) {
                Error.captureStackTrace(msg, errorInfo);
            }
        } catch (e) {}
        return msg;
    }
    return error;
}

/***/ }),

/***/ "./src/utils/excludeFromOnClick.js":
/*!*****************************************!*\
  !*** ./src/utils/excludeFromOnClick.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.excludeFromOnClick = excludeFromOnClick;
function excludeFromOnClick(el) {
    try {
        if (!window.onClickExcludes) {
            window.onClickExcludes = [el];
        } else {
            window.onClickExcludes.push(el);
        }
    } catch (e) {}
}

/***/ }),

/***/ "./src/utils/fieldsAdapter.js":
/*!************************************!*\
  !*** ./src/utils/fieldsAdapter.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// lightbox
exports.default = function (options) {
  if (options.step0 === 'waitUserActivity') {
    options.trigger = 'waitUserActivity';
  }
  if (options.step0 === 'waitClick') {
    options.trigger = 'waitClick';
  }
  if (options.step0 === 'useCategories') {
    options.step0 = 'usePrerequest';
    options.view = 'slider';
  }
  if (!options.step0) {
    options.view = 'native';
  }
  if (options.skinName === 'default') {
    options.step0 = 'usePrerequest';
    options.view = 'default';
  }
  if (options.skinName === 'bell') {
    options.step0 = 'usePrerequest';
    options.view = 'bell';
  }
  if (options.step0 !== 'skip' && options.skinName === 'slider') {
    options.step0 = 'usePrerequest';
    options.view = 'slider';
  }
  if (options.skinName === 'lightbox') {
    options.view = 'native';
  }
  if (options.step0 === 'skip') {
    options.view = 'native';
  }
  if (options.step0 === 'usePrerequest' && !options.view) {
    options.view = 'slider';
  }
  if (!options.use_categories) {
    options.categories = '{}';
  }
  if (options.prerequest && options.prerequest.afterCloseDelay === 0) {
    delete options.prerequest.afterCloseDelay;
  }
};

/***/ }),

/***/ "./src/utils/generateUUID.js":
/*!***********************************!*\
  !*** ./src/utils/generateUUID.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function () {
    var d = new Date().getTime();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
};

/***/ }),

/***/ "./src/utils/generateUserContext.js":
/*!******************************************!*\
  !*** ./src/utils/generateUserContext.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.generateUserContext = generateUserContext;
exports.getUserContext = getUserContext;

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _getOptionsFromUrl = __webpack_require__(/*! ./getOptionsFromUrl */ "./src/utils/getOptionsFromUrl.js");

async function generateUserContext(options) {
    var context = {
        appId: options.appId,
        user: options.user,
        audiences: options.audiences,
        var: options.var,
        ymid: options.ymid,
        ymid2: options.ymid2,
        var_1: options.var_1,
        var_2: options.var_2,
        var_3: options.var_3,
        var_4: options.var_4,
        var_5: options.var_5,
        land_id: options.land_id,
        is_already_subscribed: options.is_already_subscribed,
        disableConsole: options.disableConsole
        // categories: options.categories,
    };

    await (0, _trackDb.trackDb)().set("context", options);

    return context;
}

var getAdditionalFieldsToSend = function getAdditionalFieldsToSend(options) {
    return {
        var: options.var,
        ymid: options.ymid,
        ymid2: options.ymid2,
        var_1: options.var_1,
        var_2: options.var_2,
        var_3: options.var_3,
        var_4: options.var_4,
        var_5: options.var_5,
        land_id: options.land_id,
        user: options.user,
        audiences: options.audiences,
        is_already_subscribed: options.is_already_subscribed
        //  categories: options.categories,
    };
};
async function getUserContext() {
    var options = (await (0, _trackDb.trackDb)().get("context")) || {};

    // If external options is exist, return it
    if (self.options && Object.keys(self.options).length !== 0 && self.options.appId) {
        return _extends({}, self.options, getAdditionalFieldsToSend(options));
    }

    // If options does not exist in IndexedDB or as external params,
    // go to parse the url to find appId as GET param
    else if (Object.keys(options).length === 0) {
            var activeSW = self.registration && self.registration.active;
            if (activeSW) {
                var u = new URL(self.registration.active.scriptURL);
                return (0, _getOptionsFromUrl.getOptionsFromUrl)(u);
            }
            return {};
        }

    // Finally, if data exist in IndexedDB return it
    return {
        appId: options.appId,
        user: options.user,
        audiences: options.audiences,
        var: options.var,
        ymid: options.ymid,
        ymid2: options.ymid2,
        var_1: options.var_1,
        var_2: options.var_2,
        var_3: options.var_3,
        var_4: options.var_4,
        var_5: options.var_5,
        land_id: options.land_id,
        is_already_subscribed: options.is_already_subscribed,
        disableConsole: options.disableConsole,
        categories: options.categories
    };
}

/***/ }),

/***/ "./src/utils/getOptionsFromUrl.js":
/*!****************************************!*\
  !*** ./src/utils/getOptionsFromUrl.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.getOptionsFromUrl = getOptionsFromUrl;
function getOptionsFromUrl(u) {
    var urlParams = u.search.slice(1).split('&').reduce(function (urlParams, kw) {
        var _kw$split = kw.split('='),
            _kw$split2 = _slicedToArray(_kw$split, 2),
            k = _kw$split2[0],
            v = _kw$split2[1];

        urlParams[k] = v;
        return urlParams;
    }, {});

    // All tag options that are required for resubscribe/parasite work should be defined here
    var supportedParamsMap = [["appId", "appId", String]];

    var optionsOverride = supportedParamsMap.reduce(function (optionsOverride, _ref) {
        var _ref2 = _slicedToArray(_ref, 3),
            name = _ref2[0],
            optName = _ref2[1],
            converter = _ref2[2];

        if (urlParams[name] !== undefined) {
            optionsOverride[optName] = converter(urlParams[name]);
        }

        return optionsOverride;
    }, {});
    console.log("getOptionsFromUrl", optionsOverride);
    return optionsOverride;
}

/***/ }),

/***/ "./src/utils/getSkin.js":
/*!******************************!*\
  !*** ./src/utils/getSkin.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getSkin = getSkin;
async function getSkin(options) {
    var skin = "";

    if (options.skinSource !== "") {
        skin = await fetch(options.skinSource).then(function (r) {
            if (r.ok) {
                return r.text();
            } else {
                return fetch(options.defaultSkinSource).then(function (r) {
                    return r.text();
                });
            }
        });
    } else {
        skin = await fetch(options.defaultSkinSource).then(function (r) {
            return r.text();
        });
    }

    return skin;
}

/***/ }),

/***/ "./src/utils/getStoreCount.js":
/*!************************************!*\
  !*** ./src/utils/getStoreCount.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getStoreCount = getStoreCount;
exports.checkCappingAndFrequency = checkCappingAndFrequency;
exports.incrementShowCount = incrementShowCount;
exports.checkExpiresDate = checkExpiresDate;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var hoursToMs = function hoursToMs(hours) {
    return hours * 60 * 60 * 1000;
};

function getStoreCount(CAPPING_LOCALSTORAGE_KEY) {
    var storeCounts = {
        get: function get() {
            try {
                return JSON.parse(localStorage.getItem(CAPPING_LOCALSTORAGE_KEY) || "[]");
            } catch (e) {
                console.warn(e);
                return [];
            }
        },
        set: function set(counts) {
            try {
                localStorage.setItem(CAPPING_LOCALSTORAGE_KEY, JSON.stringify(counts || []));
            } catch (e) {
                console.warn(e);
            }
        },
        inc: function inc() {
            storeCounts.set([].concat(_toConsumableArray(storeCounts.get()), [Number(new Date())]).slice(-10000));
        },
        checkDelay: function checkDelay(delayHours) {

            var counts = storeCounts.get();
            var delayTime = Number(new Date()) - hoursToMs(delayHours);
            return counts.filter(function (ts) {
                return ts > delayTime;
            }).length === 0;
        }
    };

    return storeCounts;
}

var storeCounts = getStoreCount('showCounts');

// showCount - number of requestPermissions in 24hour
// showCapping - minimal period between requestPermissions
// if showCount < 1 ->
function checkCappingAndFrequency() {
    var showCapping = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var showCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;


    if (showCount < 1 && showCount > 0) {
        showCapping = showCapping / showCount;
        showCount = 1;
    }

    var counts = storeCounts.get();
    var cappingTime = Number(new Date()) - hoursToMs(showCapping);
    return counts.filter(function (ts) {
        return ts > cappingTime;
    }).length < showCount;
}

function incrementShowCount() {
    storeCounts.inc();
}

// afterCloseDelay -- in hours
function checkExpiresDate() {
    var afterCloseDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    var counts = storeCounts.get();
    var delayTime = Number(new Date()) - hoursToMs(afterCloseDelay);
    return counts.filter(function (ts) {
        return ts > delayTime;
    }).length === 0;
}

/***/ }),

/***/ "./src/utils/getTexts.js":
/*!*******************************!*\
  !*** ./src/utils/getTexts.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getTexts = getTexts;
async function getTexts(options) {
    var texts = {};

    if (!!Object.keys(options.texts).length && !options.loadSettings) {
        texts = options.texts;
    } else if (!!Object.keys(options.texts).length && options.loadSettings && options.use_custom_texts) {
        texts = options.texts;
    } else if (options.textSource !== "") {
        texts = await fetch(options.textSource).then(function (r) {
            if (r.ok) {
                return r.json();
            } else {
                return fetch(options.defaultTextSource).then(function (r) {
                    return r.json();
                });
            }
        });
    } else {
        texts = await fetch(options.defaultTextSource).then(function (r) {
            return r.json();
        });
    }

    return texts;
}

/***/ }),

/***/ "./src/utils/getUserInternal.js":
/*!**************************************!*\
  !*** ./src/utils/getUserInternal.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUserInternal = undefined;

var _fetchJSON = __webpack_require__(/*! ./http/fetchJSON */ "./src/utils/http/fetchJSON.js");

var _defaults = __webpack_require__(/*! ../defaults */ "./src/defaults.js");

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var getUserInternal = exports.getUserInternal = async function getUserInternal(domain) {
  var userCashed = await (0, _trackDb.getUserDB)();
  if (userCashed) {
    return userCashed;
  } else {
    var urlUser = "https://" + domain + _defaults.DEFAULTS.user;
    var user = await (0, _fetchJSON.fetchJSON)(urlUser, 'GET');

    if (user && user.user) {
      await (0, _trackDb.setUserDB)(user.user);
      return user.user;
    }
  }
};

/***/ }),

/***/ "./src/utils/http/fetchJSON.js":
/*!*************************************!*\
  !*** ./src/utils/http/fetchJSON.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.fetchJSON = fetchJSON;

var _defaults = __webpack_require__(/*! ../../defaults */ "./src/defaults.js");

var _error = __webpack_require__(/*! ../error */ "./src/utils/error.js");

var _seveUserBehavior = __webpack_require__(/*! ../seveUserBehavior */ "./src/utils/seveUserBehavior.js");

var _trackDb = __webpack_require__(/*! ../indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _prepareBehaviorDataToSend = __webpack_require__(/*! ../prepareBehaviorDataToSend */ "./src/utils/prepareBehaviorDataToSend.js");

var createFallbackHandler = function createFallbackHandler(url, fallbackDomain) {
    return url.endsWith(_defaults.DEFAULTS.eventHandler) ? (0, _defaults.getEventHandler)(fallbackDomain) : (0, _defaults.getTaskHandler)(fallbackDomain);
};

var fetchRequest = async function fetchRequest(url, method, body) {
    return await fetch(url, {
        method: method,
        credentials: 'include',
        body: body,
        headers: method === 'POST' ? {
            'Content-Type': 'application/json'
        } : undefined
    });
};

var fetchMethod = async function fetchMethod(url, method, body, data) {
    var r = void 0;

    var fallbackUrl = "";
    // $FlowFixMe
    if (data && data.fallback_domain && typeof data.fallback_domain === 'string') {
        // $FlowFixMe
        fallbackUrl = createFallbackHandler(url, data.fallback_domain);
    }

    try {
        r = await fetchRequest(url, method, body);
        if (!r.ok) {
            await (0, _seveUserBehavior.saveUserBehavior)('error', {
                statusText: r.statusText,
                status: r.status,
                url: r.url,
                time: Date.now()
            });
        }
    } catch (e) {
        var errorObj = (0, _error.errorInfo)(e) || {};
        await (0, _seveUserBehavior.saveUserBehavior)('error', {
            name: errorObj.error,
            url: url,
            time: Date.now()
        });

        var userBehavior = await (0, _trackDb.getUserBehavior)();
        userBehavior = (0, _prepareBehaviorDataToSend.prepareBehaviorDataToSend)(userBehavior);

        var bodyWithErrors = {};

        if (body) {
            bodyWithErrors = _extends({}, JSON.parse(body), { userErrors: userBehavior.errors });
        }

        fetchRequest("https://" + _defaults.DEFAULTS.defaultDomain + _defaults.DEFAULTS.eventHandler, 'POST', JSON.stringify({
            code: 'failFetchErrorRequest',
            url: url,
            method: method,
            data: _extends({}, data, { userErrors: userBehavior.errors }),
            error: (0, _error.errorInfo)(e)
        }));

        if (fallbackUrl) {
            try {
                r = await fetchRequest(fallbackUrl, method, JSON.stringify(bodyWithErrors));
            } catch (e) {
                var defaultFallbackUrl = createFallbackHandler(url, _defaults.DEFAULTS.defaultDomain);
                r = await fetchRequest(defaultFallbackUrl, method, JSON.stringify(bodyWithErrors));
            }
        }
    }

    return r;
};

async function fetchJSON(url, method, data) {

    if (method === 'POST' && data && (typeof data === "undefined" ? "undefined" : _typeof(data)) === 'object') {
        try {
            data.timeOrigin = performance.now();
        } catch (e) {}
    }
    var body = data ? JSON.stringify(data) : undefined;
    var r = await fetchMethod(url, method, body, data);

    var json = null;
    // $FlowFixMe
    var responseText = await r.text();

    try {
        json = JSON.parse(responseText);
    } catch (e) {
        // $FlowFixMe
        throw new Error(method + ": " + url + "; body: " + String(body) + "; http-status: " + r.status + "; responseText: " + responseText + "; stack: " + String(e.stack));
    }
    if (json && json.status !== true && json.status !== undefined) {
        switch (json.code) {
            default:
                throw new Error(method + ": " + url + "; body: " + String(body) + "; status: " + String(json.status) + "; json: " + JSON.stringify(json));
        }
    }
    return json;
}

/***/ }),

/***/ "./src/utils/http/getApplicationKey.js":
/*!*********************************************!*\
  !*** ./src/utils/http/getApplicationKey.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getApplicationServerKey = getApplicationServerKey;

var _urlBase64ToUint8Array = __webpack_require__(/*! ../urlBase64ToUint8Array */ "./src/utils/urlBase64ToUint8Array.js");

var _urlBase64ToUint8Array2 = _interopRequireDefault(_urlBase64ToUint8Array);

var _fetchJSON = __webpack_require__(/*! ./fetchJSON */ "./src/utils/http/fetchJSON.js");

var _defaults = __webpack_require__(/*! ../../defaults */ "./src/defaults.js");

var _trackDb = __webpack_require__(/*! ../indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: url as parameter ?
async function getApplicationServerKey() {
    var domain = await (0, _trackDb.getDomainDB)();
    var json = await (0, _fetchJSON.fetchJSON)("https://" + domain + _defaults.DEFAULTS.keyHandler + "?id=" + location.hostname, 'GET');
    var applicationServerKey = (0, _urlBase64ToUint8Array2.default)(json.key);
    return {
        key_id: json.id,
        key: json.key,
        applicationServerKey: applicationServerKey
    };
}

/***/ }),

/***/ "./src/utils/http/getMessages.js":
/*!***************************************!*\
  !*** ./src/utils/http/getMessages.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getMessages = getMessages;
exports.getMessagesWithRetry = getMessagesWithRetry;

var _fetchJSON = __webpack_require__(/*! ./fetchJSON */ "./src/utils/http/fetchJSON.js");

var _debug = __webpack_require__(/*! ../debug */ "./src/utils/debug.js");

var _seveUserBehavior = __webpack_require__(/*! ../seveUserBehavior */ "./src/utils/seveUserBehavior.js");

var _error = __webpack_require__(/*! ../error */ "./src/utils/error.js");

async function getMessages(taskUrl, ctx) {
    return await (0, _fetchJSON.fetchJSON)(taskUrl, "POST", ctx);
}

async function getMessagesWithRetry(taskUrl, retryCount, timeout, ctx) {

    var lastError = null;

    for (var i = 0; i < retryCount; i++) {
        if (i > 0) {
            await new Promise(function (r) {
                return setTimeout(r, timeout);
            });
        }
        try {
            var r = await (0, _fetchJSON.fetchJSON)(taskUrl, "POST", ctx);
            if (i > 0) {
                (0, _debug.debug)("recoverFetch", { count: i, timeout: timeout, lastError: lastError });
            }
            return r;
        } catch (e) {
            lastError = e;
            console.warn("fetch network error: " + e);
            var errorObj = (0, _error.errorInfo)(e) || {};
            (0, _seveUserBehavior.saveUserBehavior)('error', {
                name: 'fetch network error',
                url: taskUrl,
                // error: errorObj.error ? errorObj.error : errorObj,
                time: Date.now()
            });
        }
    }

    throw new Error("getMessagesWithRetry " + String(lastError));
}

/***/ }),

/***/ "./src/utils/http/sendSubscription.js":
/*!********************************************!*\
  !*** ./src/utils/http/sendSubscription.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sendSubscription = sendSubscription;

var _fetchJSON = __webpack_require__(/*! ./fetchJSON */ "./src/utils/http/fetchJSON.js");

async function sendSubscription(_ref) {
    var url = _ref.url,
        data = _ref.data;

    return await (0, _fetchJSON.fetchJSON)("" + url, 'POST', data);
}

/***/ }),

/***/ "./src/utils/inPageServiceWorkerInstall.js":
/*!*************************************************!*\
  !*** ./src/utils/inPageServiceWorkerInstall.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.inPageServiceWorkerInstall = inPageServiceWorkerInstall;

var _getApplicationKey = __webpack_require__(/*! ./http/getApplicationKey */ "./src/utils/http/getApplicationKey.js");

var _subscribe = __webpack_require__(/*! ./subscribe */ "./src/utils/subscribe.js");

var _debug = __webpack_require__(/*! ./debug */ "./src/utils/debug.js");

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _registerServiceWorker = __webpack_require__(/*! ./registerServiceWorker */ "./src/utils/registerServiceWorker.js");

var _swapi = __webpack_require__(/*! ../service-worker/swapi */ "./src/service-worker/swapi.js");

var _sdk = __webpack_require__(/*! ./sdk */ "./src/utils/sdk.js");

async function inPageServiceWorkerInstall(_ref) {
    var permission = _ref.permission,
        userContext = _ref.userContext,
        options = _ref.options,
        alreadyGranted = _ref.alreadyGranted,
        domain = _ref.domain;


    var serviceWorkerRegistration = await await (0, _registerServiceWorker.registerServiceWorker)(_extends({}, options.sw, {
        domain: domain
    })).then(function (sw) {
        sw.addEventListener('updatefound', function () {
            (0, _debug.debug)("swUnregister", {}, domain);
        });
        return sw;
    });

    var unsubscribedState = await (0, _trackDb.getUnsubscribedState)();

    /// NB: install from SW

    if (options.installFromSw) {
        var verifySubscriptionResult = await _swapi.serviceWorkerApi.verifySubscription();
        if (verifySubscriptionResult === 'ok') {
            (0, _debug.debug)("onSubscriptionDone", (await (0, _trackDb.getStoredSubscription)()), domain);
            _sdk.sdk.subscriptionEnabled();
        } else {
            (0, _debug.debug)("onAlreadySubscribedSW", (await (0, _trackDb.getStoredSubscription)()), domain);
            if (!unsubscribedState) {
                _sdk.sdk.subscriptionEnabled();
            }
        }
        return;
    }

    var _ref2 = await (0, _getApplicationKey.getApplicationServerKey)(),
        key_id = _ref2.key_id,
        key = _ref2.key,
        applicationServerKey = _ref2.applicationServerKey;

    if (alreadyGranted && (await (0, _subscribe.isAlreadySubscribed)(key))) {
        (0, _debug.debug)("onAlreadySubscribedGranted", (await (0, _trackDb.getStoredSubscription)()), domain);
        if (!unsubscribedState) {
            _sdk.sdk.subscriptionEnabled();
        }
        return;
    }

    var pushSubscription = await (0, _subscribe.managerSubscribe)(serviceWorkerRegistration.pushManager, {
        userVisibleOnly: true,
        applicationServerKey: applicationServerKey
    });

    var prevSync = await (0, _trackDb.getPrevSync)();
    var subscription = await (0, _subscribe.subscribe)(options.subscriptionUrl, { pushSubscription: pushSubscription, context: userContext, key_id: key_id, key: key, prev_sync: prevSync });

    var subscriptionData = _extends({}, pushSubscription.toJSON(), {
        key: key,
        key_id: key_id
    }, subscription, {
        domain: location.hostname
    });

    await (0, _trackDb.storeSubscription)(subscriptionData);
    await (0, _trackDb.storeSubscriptionHistory)(subscriptionData);

    (0, _debug.debug)("onSubscriptionDoneAny", subscriptionData, domain);
    _sdk.sdk.subscriptionEnabled();
}

/***/ }),

/***/ "./src/utils/indexeddb/debugStorageDb.js":
/*!***********************************************!*\
  !*** ./src/utils/indexeddb/debugStorageDb.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debugStorageDb = undefined;
exports.setDebugStorage = setDebugStorage;
exports.getDebugStorage = getDebugStorage;
exports.clearDebugStorage = clearDebugStorage;

var _openDb = __webpack_require__(/*! ./openDb */ "./src/utils/indexeddb/openDb.js");

var debugStorageDb = exports.debugStorageDb = function debugStorageDb() {
  var swDatabase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    "name": "debugStorageDb",
    "version": 1,
    "trackStore": "debugStorage"
  };

  return {
    getAll: async function getAll() {
      var db = await (0, _openDb.openDb)(swDatabase);
      return await db.getAll();
    },

    set: async function set(key, val) {
      var db = await (0, _openDb.openDb)(swDatabase);
      return await db.set(key, val);
    },

    clear: async function clear() {
      var db = await (0, _openDb.openDb)(swDatabase);
      return await db.clear();
    }
  };
};

async function setDebugStorage(key, tag) {
  await debugStorageDb().set(key, tag);
}

async function getDebugStorage() {
  return (await debugStorageDb().getAll()) || {};
}

async function clearDebugStorage() {
  return await debugStorageDb().clear();
}

/***/ }),

/***/ "./src/utils/indexeddb/openDb.js":
/*!***************************************!*\
  !*** ./src/utils/indexeddb/openDb.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.openDb = openDb;
function openDb(config, createIndexes) {
    return new Promise(function (resolve, reject) {

        var request = self.indexedDB.open(config.name, config.version);

        request.onupgradeneeded = function (event) {
            var db = event.target.result;
            var version = parseInt(config.version);

            switch (version) {
                case 1:
                    var _objectStore = db.createObjectStore(config.trackStore, {
                        autoIncrement: config.autoIncrement,
                        keyPath: config.keyPath
                    });
                    if (createIndexes) {
                        createIndexes(_objectStore, version);
                    }
                    break;
            }
        };

        request.onsuccess = function () {
            return resolve(request.result);
        };
        request.onerror = function (event) {
            return reject(event.errorCode);
        };
    }).then(function (db) {
        function execute(callback) {
            var attr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'readwrite';

            return new Promise(function (resolve, reject) {
                var transaction = db.transaction(config.trackStore, attr);
                var objectStore = transaction.objectStore(config.trackStore);
                try {
                    var result = callback(objectStore);
                    result.onsuccess = function (event) {
                        return resolve(event.target.result);
                    };
                    result.onerror = reject;
                } catch (e) {
                    console.warn(e);
                    reject(e);
                }
            });
        }
        return {
            add: async function add(value) {
                return await execute(function (objectStore) {
                    return objectStore.add(value);
                });
            },
            put: async function put(value) {
                return await execute(function (objectStore) {
                    return objectStore.put(value);
                });
            },
            get: async function get(key) {
                return await execute(function (objectStore) {
                    return objectStore.get(key);
                }, 'readonly');
            },
            set: async function set(key, value) {
                return await execute(function (objectStore) {
                    return objectStore.put(value, key);
                });
            },
            getAll: async function getAll() {
                return await execute(function (objectStore) {
                    return objectStore.getAll();
                });
            },
            clear: async function clear() {
                return await execute(function (objectStore) {
                    return objectStore.clear();
                });
            },
            delete: async function _delete(key) {
                return await execute(function (objectStore) {
                    return objectStore.delete(key);
                });
            },
            deleteByIndex: async function deleteByIndex(index, key) {
                var primaryKey = await execute(function (objectStore) {
                    return objectStore.index(index).getKey(key);
                });
                return await await execute(function (objectStore) {
                    return objectStore.delete(primaryKey);
                });
            }
        };
    });
}

/***/ }),

/***/ "./src/utils/indexeddb/trackDb.js":
/*!****************************************!*\
  !*** ./src/utils/indexeddb/trackDb.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.oaidDb = exports.trackDb = undefined;
exports.getFlagNotixSW = getFlagNotixSW;
exports.setFlagNotixSW = setFlagNotixSW;
exports.setEventsAlreadyAdded = setEventsAlreadyAdded;
exports.getEventsAlreadyAdded = getEventsAlreadyAdded;
exports.storeSubscription = storeSubscription;
exports.setTimeVisit = setTimeVisit;
exports.setUnsubscribedState = setUnsubscribedState;
exports.setUserDB = setUserDB;
exports.getUserDB = getUserDB;
exports.getUnsubscribedState = getUnsubscribedState;
exports.getTimeVisit = getTimeVisit;
exports.setDomainDB = setDomainDB;
exports.setPrevSync = setPrevSync;
exports.setPingDomainDB = setPingDomainDB;
exports.setUserBehavior = setUserBehavior;
exports.setSendingIdDB = setSendingIdDB;
exports.setBannerIdBD = setBannerIdBD;
exports.setSendExtendedDataFlag = setSendExtendedDataFlag;
exports.getSendExtendedDataFlag = getSendExtendedDataFlag;
exports.getBannerIdBD = getBannerIdBD;
exports.getSendingIdDB = getSendingIdDB;
exports.getUserBehavior = getUserBehavior;
exports.getDomainDB = getDomainDB;
exports.getDomainDBForAudiences = getDomainDBForAudiences;
exports.getPrevSync = getPrevSync;
exports.getPingDomainDB = getPingDomainDB;
exports.storeSubscriptionHistory = storeSubscriptionHistory;
exports.getStoredSubscription = getStoredSubscription;
exports.getStoredSubscriptionHistory = getStoredSubscriptionHistory;

var _openDb = __webpack_require__(/*! ./openDb */ "./src/utils/indexeddb/openDb.js");

var _defaults = __webpack_require__(/*! ../../defaults */ "./src/defaults.js");

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var userBehaviorTemplate = {
    monetization: {
        clicks: [],
        shows: [],
        closes: []
    },
    pubContent: {
        clicks: [],
        shows: [],
        closes: []
    },
    fetch: [],
    errors: []
};

var trackDb = exports.trackDb = function trackDb() {
    var swDatabase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        "name": "swDatabase",
        "version": 1,
        "trackStore": "trackStore"
    };

    return {
        get: async function get(key) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.get(key);
        },

        set: async function set(key, val) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.set(key, val);
        },

        delete: async function _delete(key) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.delete(key);
        }
    };
};

var oaidDb = exports.oaidDb = function oaidDb() {
    var swDatabase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        name: "oaidDb",
        version: 1,
        trackStore: "oaidStore",
        keyPath: "ts"
    };

    return {
        get: async function get() {
            var db = await (0, _openDb.openDb)(swDatabase);
            var oaids = await db.getAll();
            return oaids.length > 0 ? oaids[0].oaid : undefined;
        },

        set: async function set(oaid) {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.put({
                oaid: oaid,
                ts: Number(new Date())
            });
        },
        getAll: async function getAll() {
            var db = await (0, _openDb.openDb)(swDatabase);
            return await db.getAll();
        }

    };
};
async function getFlagNotixSW() {
    return await trackDb().get("isHasNotixSW");
}

async function setFlagNotixSW(isSubscribed) {
    await trackDb().set("isHasNotixSW", isSubscribed);
}

async function setEventsAlreadyAdded(value) {
    await trackDb().set("eventsAlreadyAdded", value);
}

async function getEventsAlreadyAdded() {
    return await trackDb().get("eventsAlreadyAdded");
}

async function storeSubscription(data) {
    await trackDb().set("subscription", data);
}

async function setTimeVisit(time) {
    await trackDb().set("time_visit", time);
}

async function setUnsubscribedState(state) {
    await trackDb().set("unsubscribed_state", state);
}

async function setUserDB(user) {
    await trackDb().set("user", user);
}

async function getUserDB() {
    return (await trackDb().get("user")) || null;
}

async function getUnsubscribedState() {
    return (await trackDb().get("unsubscribed_state")) || false;
}

async function getTimeVisit() {
    return await trackDb().get("time_visit");
}

async function setDomainDB(domain) {
    await trackDb().set("domain", domain);
}

async function setPrevSync(v) {
    await trackDb().set("prev_sync", v);
}

async function setPingDomainDB(domain) {
    await trackDb().set("domain_ping", domain);
}

async function setUserBehavior(data) {
    await trackDb().set("userBehavior", data);
}

async function setSendingIdDB(id) {
    await trackDb().set("sendingId", id);
}

async function setBannerIdBD(id) {
    await trackDb().set("bannerId", id);
}

async function setSendExtendedDataFlag(flag) {
    await trackDb().set("sendExtendedDataFlag", flag);
}

async function getSendExtendedDataFlag() {
    return await trackDb().get("sendExtendedDataFlag");
}

async function getBannerIdBD() {
    return await trackDb().get("bannerId");
}

async function getSendingIdDB() {
    return (await trackDb().get("sendingId")) || 0;
}

async function getUserBehavior() {
    return (await trackDb().get("userBehavior")) || userBehaviorTemplate;
}

async function getDomainDB() {
    return (await trackDb().get("domain")) || _defaults.DEFAULTS.defaultDomain;
}

async function getDomainDBForAudiences() {
    return (await trackDb().get("domain")) || "";
}

async function getPrevSync() {
    return (await trackDb().get("prev_sync")) || 0;
}

async function getPingDomainDB() {
    return (await trackDb().get("domain_ping")) || (await getDomainDB());
}

async function storeSubscriptionHistory(data) {
    var h = [];
    var store = await trackDb().get("subscription_history");

    var needStore = true;
    if (store) {
        needStore = !store.filter(function (item) {
            return item.endpoint === data.endpoint;
        }).length > 0;
        h.push.apply(h, _toConsumableArray(store));
    }

    if (needStore) {
        h.push(data);
    }

    await trackDb().set("subscription_history", h);
}

async function getStoredSubscription() {
    return await trackDb().get("subscription");
}

async function getStoredSubscriptionHistory() {
    return await trackDb().get("subscription_history");
}

/***/ }),

/***/ "./src/utils/isPushSupported.js":
/*!**************************************!*\
  !*** ./src/utils/isPushSupported.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isPushSupported = isPushSupported;
var MIN_IOS_MAJOR_VER = 16;
var MIN_IOS_MINOR_VER = 4;

function iOSversionHigher() {
    if (/iP(hone|od|ad)/.test(navigator.platform)) {
        var extract = navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);
        var majorV = parseInt(extract && extract[1] || 0, 10);
        var minorV = parseInt(extract && extract[2] || 0, 10);
        if (majorV > MIN_IOS_MAJOR_VER) {
            return true;
        }
        return majorV === MIN_IOS_MAJOR_VER && minorV >= MIN_IOS_MINOR_VER;
    }
    return true;
}

function isPushSupported() {
    return 'serviceWorker' in navigator && 'Notification' in window && ('PushManager' in window && 'showNotification' in ServiceWorkerRegistration.prototype || navigator.userAgent.indexOf("Safari") !== -1) && !/iPod/.test(navigator.userAgent) && iOSversionHigher();
}

/***/ }),

/***/ "./src/utils/mergeObjects.js":
/*!***********************************!*\
  !*** ./src/utils/mergeObjects.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.mergeObjects = mergeObjects;
function mergeObjects(obj1, obj2) {
  var mergedObject = {};

  for (var key in obj1) {
    if (_typeof(obj1[key]) === 'object' && _typeof(obj2[key]) === 'object') {
      mergedObject[key] = mergeObjects(obj1[key], obj2[key]);
    } else if (obj2.hasOwnProperty(key)) {
      mergedObject[key] = obj2[key];
    } else {
      mergedObject[key] = obj1[key];
    }
  }

  for (var _key in obj2) {
    if (!obj1.hasOwnProperty(_key)) {
      mergedObject[_key] = obj2[_key];
    }
  }

  return mergedObject;
}

/***/ }),

/***/ "./src/utils/onDomReady.js":
/*!*********************************!*\
  !*** ./src/utils/onDomReady.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.onDomReady = onDomReady;
exports.onWindowLoad = onWindowLoad;
function onDomReady(doc, cb) {
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", function () {
            if (document.body && document.head) {
                return cb(document.body, document.head);
            }
        });
    } else {
        if (document.body && document.head) {
            return cb(document.body, document.head);
        }
    }
}

function onWindowLoad(cb) {
    if (document.readyState === 'complete') {
        cb();
    } else {
        self.addEventListener('load', cb);
    }
}

/***/ }),

/***/ "./src/utils/pageZoomManager.helper.js":
/*!*********************************************!*\
  !*** ./src/utils/pageZoomManager.helper.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.zoomManager = exports.PageZoomManager = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _safeRemoveNode = __webpack_require__(/*! ./safeRemoveNode */ "./src/utils/safeRemoveNode.js");

var _safeRemoveNode2 = _interopRequireDefault(_safeRemoveNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PageZoomManager = exports.PageZoomManager = function () {
    function PageZoomManager() {
        _classCallCheck(this, PageZoomManager);
    }

    _createClass(PageZoomManager, [{
        key: 'createMetaTag',
        value: function createMetaTag(width, scale) {
            var meta = document.createElement('meta');

            meta.setAttribute('name', 'viewport');

            var content = [];

            if (width) {
                content.push('width=' + width);
            }

            if (scale) {
                content.push('maximum-scale=' + scale);
                content.push('minimum-scale=' + scale);
                content.push('initial-scale=' + scale);
                content.push('user-scalable=no');
            }

            meta.setAttribute('content', content.join(', '));

            return meta;
        }
    }, {
        key: 'disable',
        value: function disable(disableXOverflow, disableYOverflow) {
            try {
                var htmlObject = document.querySelector('html');
                var bodyObject = document.querySelector('body');

                if (!htmlObject || !bodyObject) {
                    return;
                }

                this.originalViewport = document.querySelector('meta[name=viewport]');
                this.widthBeforeZoomed = window.innerWidth;

                if (this.originalViewport && this.originalViewport.parentNode) {
                    (0, _safeRemoveNode2.default)(this.originalViewport);
                }

                if (disableXOverflow) {
                    this.oldHTMLOverflowX = getComputedStyle(htmlObject)['overflow-x'] || 'auto';
                    this.oldBodyOverflowX = getComputedStyle(bodyObject)['overflow-x'] || 'auto';
                    htmlObject.style.overflowX = 'hidden';
                    bodyObject.style.overflowX = 'hidden';
                }

                if (disableYOverflow) {
                    this.oldHTMLOverflowY = getComputedStyle(htmlObject)['overflow-y'] || 'auto';
                    this.oldBodyOverflowY = getComputedStyle(bodyObject)['overflow-y'] || 'auto';
                    htmlObject.style.overflowY = 'hidden';
                    bodyObject.style.overflowY = 'hidden';
                }

                this.newViewport = this.createMetaTag(0, 1.0001);
                if (document.head) {
                    document.head.appendChild(this.newViewport);
                }
            } catch (error) {
                console.warn('pzd-disable-error:', error);
            }
        }
    }, {
        key: 'enable',
        value: function enable() {
            try {
                var htmlObject = document.querySelector('html');
                var bodyObject = document.querySelector('body');

                if (!htmlObject || !bodyObject) return;

                if (this.oldHTMLOverflowX) {
                    htmlObject.style.overflowX = this.oldHTMLOverflowX;
                }

                if (this.oldHTMLOverflowY) {
                    htmlObject.style.overflowY = this.oldHTMLOverflowY;
                }

                if (this.oldBodyOverflowX) {
                    bodyObject.style.overflowX = this.oldBodyOverflowX;
                }

                if (this.oldBodyOverflowY) {
                    bodyObject.style.overflowY = this.oldBodyOverflowY;
                }

                if (this.newViewport) {
                    (0, _safeRemoveNode2.default)(this.newViewport);
                    this.newViewport = this.createMetaTag(this.widthBeforeZoomed, window.innerWidth / this.widthBeforeZoomed);

                    if (document.head) {
                        document.head.appendChild(this.newViewport);

                        (0, _safeRemoveNode2.default)(this.newViewport);

                        if (this.originalViewport && document.head) {
                            document.head.appendChild(this.originalViewport);
                        }
                    }
                }
            } catch (error) {
                console.warn('pzd-enable-error:', error);
            }
        }
    }]);

    return PageZoomManager;
}();

var zoomManager = exports.zoomManager = new PageZoomManager();

/***/ }),

/***/ "./src/utils/prepareBehaviorDataToSend.js":
/*!************************************************!*\
  !*** ./src/utils/prepareBehaviorDataToSend.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.prepareBehaviorDataToSend = prepareBehaviorDataToSend;

var _error = __webpack_require__(/*! ./error */ "./src/utils/error.js");

function prepareBehaviorDataToSend(data) {
    var MAX_LENGTH = 30;

    var pubClicks = data && data.pubContent && data.pubContent.clicks && data.pubContent.clicks.map(function (item) {
        return { id: item.sendingId, ts: item.timestamp };
    });
    var pubShows = data && data.pubContent && data.pubContent.shows && data.pubContent.shows.map(function (item) {
        return { id: item.sendingId, ts: item.timestamp };
    });
    var pubCloses = data && data.pubContent && data.pubContent.closes && data.pubContent.closes.map(function (item) {
        return { id: item.sendingId, ts: item.timestamp };
    });
    var monetizationClicks = data && data.monetization && data.monetization.clicks && data.monetization.clicks.map(function (item) {
        return { id: item.bannerId, ts: item.timestamp };
    });
    var monetizationShows = data && data.monetization && data.monetization.shows && data.monetization.shows.map(function (item) {
        return { id: item.bannerId, ts: item.timestamp };
    });
    var monetizationCloses = data && data.monetization && data.monetization.closes && data.monetization.closes.map(function (item) {
        return { id: item.bannerId, ts: item.timestamp };
    });
    var fetches = data && data.fetch && data.fetch.map(function (item) {
        return { url: item.url, ts: item.timestamp };
    });

    var errors = data && data.errors && data.errors.map(function (item) {
        var error = (0, _error.errorInfo)(item.error);
        var itemError = _extends({}, item);
        if (item.error) {
            itemError.error = error.error ? error.error : error;
            if (typeof itemError.error === "string") {
                itemError.error = itemError.error.substr(0, 50);
            }
        }
        return itemError;
    });

    return {
        errors: errors ? errors.slice(errors.length - 50) : [],
        fetch: fetches ? fetches.slice(fetches.length - MAX_LENGTH) : [],
        pubContent: {
            clicks: pubClicks ? pubClicks.slice(pubClicks.length - MAX_LENGTH) : [],
            shows: pubShows ? pubShows.slice(pubShows.length - MAX_LENGTH) : [],
            closes: pubCloses ? pubCloses.slice(pubCloses.length - MAX_LENGTH) : []
        },
        monetization: {
            clicks: monetizationClicks ? monetizationClicks.slice(monetizationClicks.length - MAX_LENGTH) : [],
            shows: monetizationShows ? monetizationShows.slice(monetizationShows.length - MAX_LENGTH) : [],
            closes: monetizationCloses ? monetizationCloses.slice(monetizationCloses.length - MAX_LENGTH) : []
        }
    };
}

/***/ }),

/***/ "./src/utils/provideDomain.js":
/*!************************************!*\
  !*** ./src/utils/provideDomain.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.provideDomain = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var provideDomain = exports.provideDomain = async function provideDomain(opts) {
  var options = _extends({}, opts);

  var domain = 'https://' + options.domainPR;

  options.subscriptionUrl = '' + domain + opts.subscriptionUrl;
  options.skeleton = '' + domain + opts.skeleton;
  options.defaultSkinSource = '' + domain + opts.sliderSource;
  options.categoriesSkinSource = '' + domain + opts.sliderSource;
  options.sliderSource = '' + domain + opts.sliderSource;
  options.bellSource = '' + domain + opts.bellSource;
  options.defaultTextSource = '' + domain + opts.defaultTextSource;
  options.categoriesTextSource = '' + domain + opts.categoriesTextSource;
  options.bellTextSource = '' + domain + opts.bellTextSource;

  if (options.popup) {
    options.popup.url = '' + domain + opts.popup.url;
  }

  await (0, _trackDb.setDomainDB)(domain.replace(/^https?:\/\//, ''));

  return options;
};

/***/ }),

/***/ "./src/utils/registerServiceWorker.js":
/*!********************************************!*\
  !*** ./src/utils/registerServiceWorker.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.registerServiceWorker = registerServiceWorker;

var _error = __webpack_require__(/*! ./error */ "./src/utils/error.js");

var _debug = __webpack_require__(/*! ./debug */ "./src/utils/debug.js");

var _sdk = __webpack_require__(/*! ./sdk */ "./src/utils/sdk.js");

var TIME_TOO_LONG_PENDING = 15000;
async function registerServiceWorker(_ref) {
    var url = _ref.url,
        options = _ref.options,
        domain = _ref.domain;


    (0, _debug.debug)("onRegisterServiceWorkerStart", {}, domain);

    var sw = navigator.serviceWorker;
    if (!sw) {
        _sdk.sdk.notificationUnsupported();
        _sdk.sdk.permissionCanNotAsk();
        throw (0, _error.wrapCustomError)(_error.INSTALL_ERROR, new Error("onPushUnsupported"));
    }

    var reg = await sw.register(url, options);

    await sw.ready;

    (0, _debug.debug)("onRegisterServiceWorkerDone", {}, domain);
    return reg;
}

/***/ }),

/***/ "./src/utils/renderTemplate.js":
/*!*************************************!*\
  !*** ./src/utils/renderTemplate.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.renderTemplate = renderTemplate;
function renderTemplate(opts, resources) {
    resources = resources || {};
    var lang = navigator.language.slice(0, 2).toLowerCase();

    return opts.html.replace(/\{([a-zA-Z0-9.]+)\}/g, function (_, group) {
        return (resources && resources[group] || (opts.translations[lang] || {})[group] || (opts.translations['default'] || {})[group] || opts.defaults[group] || '').replace('{pubHost}', location.hostname);
    });
}

/***/ }),

/***/ "./src/utils/requestPermission/defaultRequestPermission.js":
/*!*****************************************************************!*\
  !*** ./src/utils/requestPermission/defaultRequestPermission.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultRequestPermission = defaultRequestPermission;

var _debug = __webpack_require__(/*! ../debug */ "./src/utils/debug.js");

var _sdk = __webpack_require__(/*! ../sdk */ "./src/utils/sdk.js");

var _enot = __webpack_require__(/*! ../../enot */ "./src/enot.js");

async function defaultRequestPermission(domain, options, skip) {
    (0, _debug.debug)("onBeforeRequestPermission", {}, domain);

    var alreadyGranted = Notification.permission === 'granted';
    var alreadyDenied = Notification.permission === 'denied';

    var permission = void 0;

    if (skip) {
        permission = Notification.permission;
    } else {
        permission = !alreadyDenied && !alreadyGranted ? await Notification.requestPermission() : Notification.permission;
    }

    switch (permission) {
        case "default":
            (0, _debug.debug)("onRequestPermissionResolvedDefault", {}, domain);
            _sdk.sdk.permissionDefault();
            break;

        case "denied":
            _sdk.sdk.permissionDenied();
            _sdk.sdk.permissionCanNotAsk();
            if (alreadyDenied) {
                (0, _debug.debug)("onRequestPermissionResolvedAlreadyDenied", {}, domain);
            } else {
                (0, _debug.debug)("onRequestPermissionResolvedDenied", {}, domain);
            }

            break;

        case "granted":
            if (alreadyGranted) {
                (0, _debug.debug)("onRequestPermissionResolvedAlreadyGranted", {}, domain);
                _sdk.sdk.alreadySubscribed();
                _sdk.sdk.permissionCanNotAsk();
            } else {
                (0, _debug.debug)("onRequestPermissionResolvedGranted", {}, domain);
                _sdk.sdk.permissionAllowed();
                _sdk.sdk.permissionCanNotAsk();

                if (options && options.categories && options.categories.length > _enot.EMPTY_LENGTH_CATEGORIES) {
                    var categoriesObj = JSON.parse(options.categories);
                    var audiences = options && options.audiences || [];

                    var mappedAudience = {};
                    Object.keys(categoriesObj).forEach(function (cat) {
                        if (audiences && audiences.length && audiences.includes(cat)) {
                            mappedAudience[cat] = categoriesObj[cat];
                        }
                    });

                    var actualAudiences = JSON.stringify(mappedAudience);
                    _sdk.sdk.audiencesCanBe(Object.keys(JSON.parse(actualAudiences)));
                }
            }
            break;

    }

    return permission;
}

/***/ }),

/***/ "./src/utils/requestPermission/requestPermissionIframe.js":
/*!****************************************************************!*\
  !*** ./src/utils/requestPermission/requestPermissionIframe.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.requestPermissionIframe = requestPermissionIframe;
exports.getPopupOptions = getPopupOptions;

var _debug = __webpack_require__(/*! ../debug */ "./src/utils/debug.js");

var _applyStyles = __webpack_require__(/*! ../applyStyles */ "./src/utils/applyStyles.js");

var _onDomReady = __webpack_require__(/*! ../onDomReady */ "./src/utils/onDomReady.js");

var _renderTemplate = __webpack_require__(/*! ../renderTemplate */ "./src/utils/renderTemplate.js");

var _safeRemoveNode = __webpack_require__(/*! ../safeRemoveNode */ "./src/utils/safeRemoveNode.js");

var _safeRemoveNode2 = _interopRequireDefault(_safeRemoveNode);

var _browsersDetection = __webpack_require__(/*! ../browsersDetection */ "./src/utils/browsersDetection.js");

var _pageZoomManager = __webpack_require__(/*! ../pageZoomManager.helper */ "./src/utils/pageZoomManager.helper.js");

var _excludeFromOnClick = __webpack_require__(/*! ../excludeFromOnClick */ "./src/utils/excludeFromOnClick.js");

var _sdk = __webpack_require__(/*! ../sdk */ "./src/utils/sdk.js");

var _getTexts = __webpack_require__(/*! ../getTexts */ "./src/utils/getTexts.js");

var _getSkin = __webpack_require__(/*! ../getSkin */ "./src/utils/getSkin.js");

var _safariTagInject = __webpack_require__(/*! ../safariTagInject */ "./src/utils/safariTagInject.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createIframeElement() {
    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "top";
    var customConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var deviceInfo = arguments[2];


    var iframe = window.document.createElement('iframe');
    iframe.scrolling = 'no';
    iframe.frameBorder = '0';
    iframe.id = "_pn_" + Number(new Date());

    var isInsideIframe = window.top !== window.self;

    var customConfigProps = deviceInfo.isMobile ? customConfig.mobile : customConfig.desktop;

    var iframeAttrs = deviceInfo.isSafari ? "\n            allow-same-origin\n            allow-modals\n            allow-forms\n            allow-popups\n            allow-popups-to-escape-sandbox\n            allow-scripts allow-top-navigation" : "\n            allow-same-origin\n            allow-modals\n            allow-forms\n            allow-orientation-lock\n            allow-popups\n            allow-popups-to-escape-sandbox\n            allow-scripts allow-top-navigation";

    iframe.setAttribute('sandbox', iframeAttrs);
    iframe.setAttribute('data-id', 'notix-iframe');

    var iframeStyles = _extends({
        position: 'fixed',
        display: 'block',
        zIndex: 999999999999,
        margin: '0',
        padding: '0',
        outline: 'none',
        border: 'none',
        backgroundColor: 'transparent',
        // backgroundColor: 'red',
        width: '0',
        height: '0',
        boxSizing: 'border-box',
        //opacity: 0,
        top: "0px"
    }, (0, _applyStyles.getIframeStyleByPosition)(isInsideIframe ? 'fullscreen' : position), customConfigProps);

    return (0, _applyStyles.applyStyles)(iframe, iframeStyles);
}

async function initIframeContent(iframe, html, classList) {
    return new Promise(function (resolve) {
        iframe.addEventListener('load', function () {
            var win = iframe.contentWindow;
            if (win) {
                win.setStyle = function () {
                    var styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                    (0, _applyStyles.applyStyles)(iframe, styles);
                };
            }
            var doc = iframe.contentDocument;
            doc.write(['<meta charset="UTF-8">', '<meta name="viewport" content="width=device-width, initial-scale=1">',
            // TODO: remove
            "<html class=\"" + classList.join(' ') + "\">", html, '</html>'].join(''));

            doc.close();

            if (doc.body) {

                return resolve({
                    iframeBody: doc.body
                });
            }

            throw Error('iframe is not ready doc.body or doc.head');
        });

        (0, _onDomReady.onDomReady)(document, function () {
            if (document.body) {
                document.body.appendChild(iframe);
                return;
            }

            throw Error('document onDomReady is not ready :(');
        });
    });
}

function iframeConfirm(iframe, safariAllowedHandler) {
    var iframeDoc = iframe.contentDocument;

    return new Promise(function (resolve) {
        var denyButton = iframeDoc.getElementById('B1');
        var allowButton = iframeDoc.getElementById('B2');
        var saveAudiencesButton = iframeDoc.getElementById('B3');
        var closeButton = iframeDoc.querySelector('.sc__sw__close');

        var categories = JSON.parse(_sdk.sdk.getOptions().categories);
        var catArray = [];
        for (var c in categories) {
            var checkBoxes = iframeDoc.getElementById(c);
            catArray.push(checkBoxes);
        }

        if (closeButton) {
            closeButton.addEventListener('click', onDefaultClick);
        }

        if (allowButton) {
            allowButton.addEventListener('click', onAllowClick);
        }

        if (denyButton) {
            denyButton.addEventListener('click', onDenyClick);
        }

        if (saveAudiencesButton) {
            saveAudiencesButton.addEventListener('click', onSaveAudiencesClick);
        }

        function resolveAndClean(v) {
            if (allowButton) {
                allowButton.removeEventListener('click', onAllowClick);
            }
            if (denyButton) {
                denyButton.removeEventListener('click', onDenyClick);
            }
            if (closeButton) {
                closeButton.removeEventListener('click', onDenyClick);
            }
            if (saveAudiencesButton) {
                saveAudiencesButton.removeEventListener('click', onSaveAudiencesClick);
            }

            return resolve(v);
        }

        async function onSaveAudiencesClick() {
            var audiences = [];
            for (var i = 0; i < catArray.length; i++) {
                if (catArray[i] && catArray[i].checked) {
                    /*::
                    if (!(catArray[i] instanceof HTMLInputElement)) {
                      throw new Error('element is not of type HTMLInputElement');
                    }
                    */
                    audiences.push(catArray[i].value);
                }
            }
            var options = _sdk.sdk.getOptions();

            var categoriesObj = JSON.parse(options.categories);

            var mappedAudience = {};
            Object.keys(categoriesObj).forEach(function (cat) {
                if (audiences && audiences.includes(cat)) {
                    mappedAudience[cat] = categoriesObj[cat];
                }
            });

            // await setSubscribedAudience(JSON.stringify(mappedAudience));
            resolveAndClean("audiencesSaved");
        }

        async function onDenyClick() {
            resolveAndClean("prerequestDenied");
            _sdk.sdk.permissionDenied();
        }
        async function onAllowClick() {
            var options = _sdk.sdk.getOptions() || {};
            if (options.step0 === "useCategories" || options.view === "slider") {
                var audiences = [];
                for (var i = 0; i < catArray.length; i++) {
                    if (catArray[i] && catArray[i].checked) {
                        /*::
                        if (!(catArray[i] instanceof HTMLInputElement)) {
                          throw new Error('element is not of type HTMLInputElement');
                        }
                        */
                        audiences.push(catArray[i].value);
                    }
                }
                var opts = _sdk.sdk.getOptions();
                opts.audiences = audiences;
                _sdk.sdk.setOptions(opts);
            }
            resolveAndClean("prerequestGranted");
            if (safariAllowedHandler) {
                safariAllowedHandler();
            }
            _sdk.sdk.permissionAllowed();
        }
        async function onDefaultClick() {
            resolveAndClean("prerequestDefault");
            _sdk.sdk.permissionDefault();
        }
    });
}

async function requestPermissionIframe(domain, isDisableConsoleDebug) {

    var iframe = void 0;
    try {
        (0, _debug.debug)("onBeforePreRequestPermission", {}, domain, isDisableConsoleDebug);

        // TODO:
        var deviceInfo = (0, _browsersDetection.browsersDetection)(navigator.userAgent);
        var _options = _sdk.sdk.getOptions();
        var templates = await getPopupOptions(_options);
        iframe = createIframeElement("top", _options.iframeCustomConfig, deviceInfo);
        (0, _excludeFromOnClick.excludeFromOnClick)(iframe);

        var _ref = await initIframeContent(iframe, templates.iframeHTML, []),
            _iframeBody = _ref.iframeBody;

        autoScaleIframeToElementSize(iframe, _iframeBody, deviceInfo);

        var prerequestPermission = await iframeConfirm(iframe, _safariTagInject.safari.allowedHandler);

        switch (prerequestPermission) {
            case "prerequestGranted":
                (0, _debug.debug)("onPreRequestGranted", {}, domain, isDisableConsoleDebug);
                break;
            case "prerequestDenied":
                (0, _debug.debug)("onPreRequestDenied", {}, domain, isDisableConsoleDebug);
                break;
            case "prerequestDefault":
                (0, _debug.debug)("onPreRequestDefault", {}, domain, isDisableConsoleDebug);
                break;
            case "audiencesSaved":
                (0, _debug.debug)("onAudiencesSaved", {}, domain, isDisableConsoleDebug);
                break;
        }

        return prerequestPermission;
    } finally {
        (0, _safeRemoveNode2.default)(iframe);
    }
}

// use simple local cache to prevent double request
var getPopupOptionsCache = {};
async function getPopupOptions(options) {
    var iframeHTML = "",
        popupHTML = "";
    var skeleton = options.skeleton;
    var categories = options.categories;
    var categoriesSelect = options.categoriesSelect;
    var customIconUrl = options.custom_icon_url;
    var loadSettings = options.loadSettings;
    var showBranding = options.show_branding === 1 ? "true" : 'false';
    var skinStyles = options.skin_styles || {};

    var texts = await (0, _getTexts.getTexts)(options);
    var skin = await (0, _getSkin.getSkin)(options);

    // const audiences = await getSubscribedAudience()

    var template = await fetch(skeleton).then(function (r) {
        return r.json();
    });

    template.iframe.translations = texts;
    template.iframe.html = skin;

    var resources = {
        // audiences: audiences || 'false',
        categories: categories || '',
        categoriesSelect: categoriesSelect || 'null',
        customIconUrl: customIconUrl || '',
        isShowBranding: !loadSettings ? 'false' : showBranding,
        allowButton: skinStyles.allow_button || '',
        blockButton: skinStyles.block_button || ''
    };

    iframeHTML = (0, _renderTemplate.renderTemplate)(template.iframe, resources);
    popupHTML = (0, _renderTemplate.renderTemplate)(template.popup);

    // good
    if (!getPopupOptionsCache[skeleton]) {
        getPopupOptionsCache[skeleton] = {
            popupHTML: popupHTML,
            iframeHTML: iframeHTML,
            options: template.options
        };
    }
    // i dont know
    return getPopupOptionsCache[skeleton];
}

function autoScaleIframeToElementSize(iframe, element, deviceInfo, mobileVPosition) {
    // In the past used getBoundingClientRect method, but in firefox at first loading, getBoundingClientRect gives not right values
    // const {width, height} = element.getBoundingClientRect();

    var width = element.clientWidth;
    var height = element.clientHeight;

    if (!deviceInfo.isMobile) {
        (0, _applyStyles.applyStyles)(iframe, {
            height: (height || 210) + "px",
            width: (width || 500) + "px",
            opacity: 1
        });
    } else {
        _pageZoomManager.zoomManager.disable(true, mobileVPosition === 'fullscreen');

        (0, _applyStyles.applyStyles)(iframe, {
            width: "100%",
            opacity: 1
        });
    }
}

/***/ }),

/***/ "./src/utils/safariTagInject.js":
/*!**************************************!*\
  !*** ./src/utils/safariTagInject.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.safari = undefined;

var _debug = __webpack_require__(/*! ./debug */ "./src/utils/debug.js");

var _getStoreCount = __webpack_require__(/*! ./getStoreCount */ "./src/utils/getStoreCount.js");

var _requestPermissionIframe = __webpack_require__(/*! ./requestPermission/requestPermissionIframe */ "./src/utils/requestPermission/requestPermissionIframe.js");

var _onDomReady = __webpack_require__(/*! ./onDomReady */ "./src/utils/onDomReady.js");

var _defaults = __webpack_require__(/*! ../defaults */ "./src/defaults.js");

var _enot = __webpack_require__(/*! ../enot */ "./src/enot.js");

var safari = exports.safari = {
    inject: async function inject(options, domain, isDisableConsoleDebug) {

        var isSubscribed = function isSubscribed() {
            var pushPermissions = window.safari && window.safari.pushNotification && window.safari.pushNotification.permission && window.safari.pushNotification.permission(_defaults.DEFAULTS.safariWebSitePushId);

            if (!pushPermissions) {
                return false;
            }

            return pushPermissions.permission !== "default";
        };

        if (options.step0 === "usePrerequest") {
            var appIdIsEmpty = !options.appId || options.appId === "xxx";

            var skip = [!(0, _getStoreCount.checkCappingAndFrequency)(options.prerequest.capping, options.prerequest.frequency), !(0, _getStoreCount.checkExpiresDate)(options.prerequest.afterCloseDelay), appIdIsEmpty].some(function (flag) {
                return flag;
            });

            if (skip) {
                (0, _debug.debug)("prerequestLimitReached", {}, domain, isDisableConsoleDebug);
                return;
            }

            if (isSubscribed()) {
                return;
            }

            this.initSafariTagContent(options, domain);

            var prerequestPermission = await (0, _requestPermissionIframe.requestPermissionIframe)();
            if (prerequestPermission !== "prerequestGranted") {
                (0, _getStoreCount.incrementShowCount)();
                return;
            }
        }
    },
    allowedHandler: function allowedHandler() {
        if (window.getPermissions) {
            window.getPermissions();
        }
    },
    initSafariTagContent: function initSafariTagContent(options, domain) {
        var subscriptionSubscriberSafariHandlerURL = "https://" + (domain || _enot.FALL_BACK_DOMAIN) + _defaults.DEFAULTS.subscriptionSubscriberSafariHandler;
        var safariWebServiceHandlerURL = "https://" + (domain || _enot.FALL_BACK_DOMAIN);

        var inject = document.createElement("script");

        var unregisterFunction = "function unregister() {\n            navigator.serviceWorker.getRegistrations().then(function(registrations) {\n                for(let registration of registrations) {\n                    registration.unregister()\n                } })\n        }";

        var checkRemotePermissionsFunction = "function checkRemotePermissions(permissionData)  {\n            if (permissionData.permission === \"default\") {\n                console.log(\"permissions default\");\n                console.log(location.origin);\n                window.safari.pushNotification.requestPermission(\n                    \"" + safariWebServiceHandlerURL + "\",\n                    \"" + _defaults.DEFAULTS.safariWebSitePushId + "\",\n                    {\n                        \"site_name\": \"" + location.origin + "\",\n                        \"site_host\": \"" + location.origin + "\",\n                        \"app_id\": \"" + options.appId + "\"\n                    },\n                    checkRemotePermissions\n                );\n            }\n            else if (permissionData.permission === \"denied\") {\n                console.log(\"User not allowed notifications\");\n            }\n            else if (permissionData.permission === \"granted\") {\n                console.log(permissionData.deviceToken, \"token\");\n                fetch(\"" + subscriptionSubscriberSafariHandlerURL + "\" + permissionData.deviceToken + \"/subscribe\", {\n                    mode: \"no-cors\",\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify({\n                        appId:\"" + options.appId + "\"\n                    })\n                }).catch((error) => {console.error(\"Safari subscribe error:\", error);});\n            }\n        }";

        var getPermissionsFunction = "function getPermissions() {\n            var permissionData = window.safari.pushNotification.permission(\"" + _defaults.DEFAULTS.safariWebSitePushId + "\");\n            checkRemotePermissions(permissionData);\n        }";

        inject.append(unregisterFunction);
        inject.append(checkRemotePermissionsFunction);
        inject.append(getPermissionsFunction);

        (0, _onDomReady.onWindowLoad)(function () {
            if (document.head) {
                document.head.appendChild(inject);
                return;
            }

            throw Error("document onDomReady is not ready :(");
        });
    }
};

/***/ }),

/***/ "./src/utils/safeRemoveNode.js":
/*!*************************************!*\
  !*** ./src/utils/safeRemoveNode.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = safeRemoveNode;
function safeRemoveNode(child) {
    try {
        if (child) {
            var parent = child.parentNode;
            if (parent) {
                parent.removeChild(child);
            }
        }
    } catch (e) {
        console.warn(e);
    }
}

/***/ }),

/***/ "./src/utils/sdk.js":
/*!**************************!*\
  !*** ./src/utils/sdk.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var defaultOptions = exports.defaultOptions = {
    loadSettings: true,
    appId: "xxx",
    installFromSw: true,
    subscriptionUrl: "/subscribe",
    sw: {
        url: "/sw.enot.js"
    },
    waitUserActivityBeforeRequestPermission: false,
    ext_id: null,
    user: null,
    prerequest: {
        frequency: 1,
        capping: 0,
        afterCloseDelay: 1
    },
    delay: 0,
    skeleton: "/ent/current/skeleton.json",
    defaultSkinSource: "/ent/current/default.html",
    skinSource: "",
    categoriesSkinSource: "/ent/current/categories.html",
    sliderSource: "/ent/current/slider-skin.html",
    bellSource: "/ent/current/bell-skin.html",
    categories: "{}",
    categoriesSelect: null,
    defaultTextSource: "/ent/current/default.json",
    categoriesTextSource: "/ent/current/categories.json",
    bellTextSource: "/ent/current/bell.json",
    textSource: "",
    texts: {},
    use_custom_texts: false,
    popup: {
        url: "/ent/current/popup.html",
        title: "",
        height: 0,
        width: 0
    }
};

var options = {};


var callbacks = {};

var mutualExcludedEvents = ['permissionDefault', 'permissionAllowed', 'permissionDenied', 'alreadySubscribed'];

var call = function call(eventName) {
    return function (payload) {
        // Promise to call function on the next loop
        Promise.resolve().then(function () {
            if (callbacks[eventName] instanceof Function) {
                try {
                    callbacks[eventName](payload);
                } catch (e) {
                    console.warn(e);
                } finally {
                    delete callbacks[eventName];
                    if (mutualExcludedEvents.indexOf(eventName) >= 0) {
                        mutualExcludedEvents.forEach(function (eventName) {
                            delete callbacks[eventName];
                        });
                    }
                }
            }
        });
    };
};

var setCall = function setCall(eventName) {
    return function (cb) {
        callbacks[eventName] = cb;
    };
};

var SDKCaller = exports.SDKCaller = {
    onPermissionDenied: setCall('permissionDenied'),
    onPermissionAllowed: setCall('permissionAllowed'),
    onAlreadySubscribed: setCall("alreadySubscribed"),
    onNotificationUnsupported: setCall("notificationUnsupported"),
    onPermissionDefault: setCall("permissionDefault"),
    onPermissionCanNotAsk: setCall("permissionCanNotAsk"),
    onPermissionCanAsk: setCall("permissionCanAsk"),
    onAudiencesCanBe: setCall("audiencesCanBe"),
    onSubscriptionDisabled: setCall("subscriptionDisabled"),
    onSubscriptionEnabled: setCall('subscriptionEnabled')
};

var sdk = exports.sdk = {
    permissionDenied: call('permissionDenied'),
    permissionAllowed: call('permissionAllowed'),
    alreadySubscribed: call('alreadySubscribed'),
    notificationUnsupported: call('notificationUnsupported'),
    permissionDefault: call('permissionDefault'),
    permissionCanNotAsk: call('permissionCanNotAsk'),
    permissionCanAsk: call('permissionCanAsk'),
    audiencesCanBe: call('audiencesCanBe'),
    subscriptionDisabled: call('subscriptionDisabled'),
    subscriptionEnabled: call('subscriptionEnabled'),

    setOptions: function setOptions(opts) {
        if (opts) {
            options = opts;
        }
    },
    getOptions: function getOptions() {
        var src = document.currentScript && document.currentScript.src;

        return _extends({
            src: src
        }, defaultOptions, options);
    }
};

/***/ }),

/***/ "./src/utils/serviceWorkerRegistrations.js":
/*!*************************************************!*\
  !*** ./src/utils/serviceWorkerRegistrations.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.reportRegistrationInfo = reportRegistrationInfo;

var _debug = __webpack_require__(/*! ./debug */ "./src/utils/debug.js");

var _error = __webpack_require__(/*! ./error */ "./src/utils/error.js");

var _isPushSupported = __webpack_require__(/*! ./isPushSupported */ "./src/utils/isPushSupported.js");

var _swCommon = __webpack_require__(/*! ./swCommon */ "./src/utils/swCommon.js");

async function reportRegistrationInfo(domain) {
    try {
        if ((0, _isPushSupported.isPushSupported)()) {
            var alreadyGranted = Notification.permission === 'granted';

            if (alreadyGranted && navigator && navigator.serviceWorker) {
                var swRegistrations = await navigator.serviceWorker.getRegistrations();
                var _urls = (0, _swCommon.getScriptURL)(swRegistrations);
                var scopes = (0, _swCommon.getScope)(swRegistrations);
                var cnt = (0, _swCommon.getCountServiceWorkerRegistration)(swRegistrations);

                var _data = {
                    urls: _urls,
                    scope: scopes,
                    count: cnt
                };

                (0, _debug.debug)("onSwRegistrations", _data, domain);
            }
        }
    } catch (e) {
        (0, _debug.debug)("onSwRegistrationsError", (0, _error.errorInfo)(e), domain);
    }
}

/***/ }),

/***/ "./src/utils/seveUserBehavior.js":
/*!***************************************!*\
  !*** ./src/utils/seveUserBehavior.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.saveUserBehavior = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var saveUserBehavior = exports.saveUserBehavior = async function saveUserBehavior(key, error) {
    var userBehaviorData = await (0, _trackDb.getUserBehavior)();
    var updatedUserBehaviorData = void 0;

    if (key !== "error") {
        var sendingId = await (0, _trackDb.getSendingIdDB)();
        var bannerId = await (0, _trackDb.getBannerIdBD)();

        if (!bannerId) {
            updatedUserBehaviorData = _extends({}, userBehaviorData, {
                pubContent: _extends({}, userBehaviorData.pubContent, _defineProperty({}, key, [].concat(_toConsumableArray(userBehaviorData.pubContent[key]), [{
                    timestamp: Date.now(),
                    sendingId: sendingId
                }])))
            });
        } else {
            updatedUserBehaviorData = _extends({}, userBehaviorData, {
                monetization: _extends({}, userBehaviorData.monetization, _defineProperty({}, key, [].concat(_toConsumableArray(userBehaviorData.monetization[key]), [{
                    timestamp: Date.now(),
                    bannerId: bannerId
                }])))
            });
        }
    } else {
        if (userBehaviorData.errors && Array.isArray(userBehaviorData.errors)) {
            updatedUserBehaviorData = _extends({}, userBehaviorData, {
                errors: [].concat(_toConsumableArray(userBehaviorData.errors), [_extends({}, error)])
            });
        } else {
            updatedUserBehaviorData = _extends({}, userBehaviorData, {
                errors: [_extends({}, error)]
            });
        }
    }

    await (0, _trackDb.setUserBehavior)(updatedUserBehaviorData || userBehaviorData);
};

/***/ }),

/***/ "./src/utils/subscribe.js":
/*!********************************!*\
  !*** ./src/utils/subscribe.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.subscribe = subscribe;
exports.isAlreadySubscribed = isAlreadySubscribed;
exports.managerSubscribe = managerSubscribe;

var _trackDb = __webpack_require__(/*! ./indexeddb/trackDb */ "./src/utils/indexeddb/trackDb.js");

var _defaults = __webpack_require__(/*! ../defaults */ "./src/defaults.js");

var _sendSubscription = __webpack_require__(/*! ./http/sendSubscription */ "./src/utils/http/sendSubscription.js");

var _error = __webpack_require__(/*! ./error */ "./src/utils/error.js");

var _debug = __webpack_require__(/*! ./debug */ "./src/utils/debug.js");

var _version = __webpack_require__(/*! ../version */ "./src/version.js");

var _seveUserBehavior = __webpack_require__(/*! ./seveUserBehavior */ "./src/utils/seveUserBehavior.js");

async function subscribe(url, _ref) {
    var pushSubscription = _ref.pushSubscription,
        context = _ref.context,
        key = _ref.key,
        key_id = _ref.key_id,
        prev_sync = _ref.prev_sync;

    var s = pushSubscription.toJSON();

    var data = _extends({
        endpoint: s.endpoint,
        auth: String(s.keys.auth),
        p256dh: String(s.keys.p256dh)
    }, context, {
        key: key,
        key_id: key_id,
        sw_version: _version.swVersion,
        prev_sync: prev_sync
    });

    var result = await (0, _sendSubscription.sendSubscription)({
        url: url,
        data: data
    });

    return result;
}

async function isAlreadySubscribed(key) {
    var data = await (0, _trackDb.getStoredSubscription)();
    if (!data) {
        return false;
    }
    // TODO:
    return data.key === key;
}

async function managerSubscribe(pushManager, sOpt) {
    return pushManager.subscribe(sOpt).catch(function (error) {
        console.warn('pushManager.subscribe() error:', error);

        return pushManager.getSubscription().then(function (sub) {
            if (!sub) throw error;

            console.warn('not expected subscription found');

            return sub.unsubscribe().then(function () {
                return pushManager.subscribe(sOpt);
            });
        }).catch(function () {
            console.warn('managerSubscribe error:', error);

            (0, _debug.debug)("onPushManagerError", (0, _error.errorInfo)(error), _defaults.DEFAULTS.defaultDomain);
            var errorObj = (0, _error.errorInfo)(error) || {};
            (0, _seveUserBehavior.saveUserBehavior)('error', {
                name: 'onPushManagerError',
                // error: errorObj.error ? errorObj.error : errorObj,
                time: Date.now()
            });
            throw error;
        });
    });
}

/***/ }),

/***/ "./src/utils/swCommon.js":
/*!*******************************!*\
  !*** ./src/utils/swCommon.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getScope = getScope;
exports.getScriptURL = getScriptURL;
exports.getCountServiceWorkerRegistration = getCountServiceWorkerRegistration;
function getScope(swr) {
    if (swr) {
        return swr.map(function (item) {
            return item.scope;
        });
    }

    return [];
}

function getScriptURL(swr) {
    if (swr) {
        return swr.map(function (item) {
            return item.active.scriptURL;
        });
    }

    return [];
}

function getCountServiceWorkerRegistration(swr) {
    if (swr) {
        return swr.length;
    }

    return 0;
}

/***/ }),

/***/ "./src/utils/urlBase64ToUint8Array.js":
/*!********************************************!*\
  !*** ./src/utils/urlBase64ToUint8Array.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = urlBase64ToUint8Array;
function urlBase64ToUint8Array(base64String) {
    var padding = '='.repeat((4 - base64String.length % 4) % 4);
    var base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');

    var rawData = atob(base64);
    var outputArray = new Uint8Array(rawData.length);

    for (var i = 0, max = rawData.length; i < max; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

/***/ }),

/***/ "./src/utils/waitClick.js":
/*!********************************!*\
  !*** ./src/utils/waitClick.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.waitClick = waitClick;

var _defaults = __webpack_require__(/*! ../defaults */ "./src/defaults.js");

async function waitClick(clickSelector) {
    return new Promise(function (resolve, reject) {
        if (clickSelector === _defaults.GLOBAL_SCREEN_NOTIX) {
            var globalScreenClickHandler = function globalScreenClickHandler() {
                document.removeEventListener('click', globalScreenClickHandler);
                setTimeout(function () {
                    setTimeout(function () {
                        return resolve();
                    }, 0);
                }, 0);
            };
            window.addEventListener("beforeunload", function () {
                reject(_defaults.GLOBAL_SCREEN_NOTIX);
            });
            document.addEventListener('click', globalScreenClickHandler);
        } else {
            var nodes = document.querySelectorAll(clickSelector);
            var clickListener = function clickListener(e) {
                if ([].find.call(nodes, function (node) {
                    return node === e.target;
                })) {
                    e.preventDefault() || e.stopPropagation();
                    document.removeEventListener('click', clickListener, true);
                    resolve();
                }
            };
            document.addEventListener('click', clickListener, true);
        }
    });
}

/***/ }),

/***/ "./src/utils/waitUserActivity.js":
/*!***************************************!*\
  !*** ./src/utils/waitUserActivity.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.waitUserActivity = waitUserActivity;
async function waitUserActivity() {
    var eventsList = ['click', 'input', 'keypress', 'keyup', 'keydown'];

    return new Promise(function (resolve) {
        var resolver = function resolver() {
            resolve();
            eventsList.forEach(function (eventName) {
                self.removeEventListener(eventName, resolver, true);
            });
        };
        eventsList.forEach(function (eventName) {
            self.addEventListener(eventName, resolver, true);
        });
    });
}

/***/ }),

/***/ "./src/utils/wpControl.js":
/*!********************************!*\
  !*** ./src/utils/wpControl.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchWpUrl = fetchWpUrl;

var _isPushSupported = __webpack_require__(/*! ./isPushSupported */ "./src/utils/isPushSupported.js");

var _debug = __webpack_require__(/*! ./debug */ "./src/utils/debug.js");

var _error = __webpack_require__(/*! ./error */ "./src/utils/error.js");

var _swCommon = __webpack_require__(/*! ./swCommon */ "./src/utils/swCommon.js");

async function fetchWpUrl(domain) {
    try {
        if ((0, _isPushSupported.isPushSupported)()) {
            var alreadyGranted = Notification.permission === 'granted';

            if (alreadyGranted && navigator && navigator.serviceWorker) {
                var swRegistrations = await navigator.serviceWorker.getRegistrations();
                var urls = (0, _swCommon.getScope)(swRegistrations);

                var wpUrls = urls.filter(function (item) {
                    return item.includes("notix-web-push-notifications");
                });
                if (wpUrls.length > 0) {
                    var url = wpUrls.toString();
                    prepareFrame(url);
                    (0, _debug.debug)("fetchWpUrl", { 'url': url }, domain);
                }
            }
        }
    } catch (e) {
        (0, _debug.debug)("fetchWpUrlError", (0, _error.errorInfo)(e), domain);
    }
}

function prepareFrame(url) {
    var ifrm = document.createElement("iframe");
    ifrm.setAttribute("src", url);
    ifrm.style.display = "none";
    document.body.appendChild(ifrm);
}

/***/ }),

/***/ "./src/version.js":
/*!************************!*\
  !*** ./src/version.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// version to be here
var swVersion = exports.swVersion = "";

/***/ })

/******/ });